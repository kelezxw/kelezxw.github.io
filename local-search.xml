<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Flutter Sign In With AppleId</title>
    <link href="/2024/02/21/flutter/flutter-signInWithApple/"/>
    <url>/2024/02/21/flutter/flutter-signInWithApple/</url>
    
    <content type="html"><![CDATA[<p>使用插件和文档：<a href="https://pub-web.flutter-io.cn/packages/sign_in_with_apple">sign_in_with_apple</a></p><h3 id="1-develop开发者账号和Flutter项目"><a href="#1-develop开发者账号和Flutter项目" class="headerlink" title="1. develop开发者账号和Flutter项目"></a>1. develop开发者账号和Flutter项目</h3><p>ios的<strong>Identifiers</strong>记得要加上<code>Sign In with Apple</code> capability；</p><p>key和Service ID仅在Web或Android集成时需要。如果只打算在iOS上集成，那就不需要配置；<br>因为ios端会自动和apple服务器连接验证信息，只有使用android和web端的apple id登录才需要配置service id(里面有回调地址)，为了和apple服务器通信验证身份，所以才需要key。</p><p>ios在xcode工程里面要加上Sign In with Apple capability；</p><h3 id="2-注意事项："><a href="#2-注意事项：" class="headerlink" title="2. 注意事项："></a>2. 注意事项：</h3><p>1、如果你要使用android和web端的apple id登录才需要配置service id，如果仅仅是ios端，那就不需要。</p><p>2、只有第一次登录(完全授权)才能返回userIdentifier，familyName，givenName，email这些全部信息，再次点击就没有familyName，givenName，email这几项了，真烦啊，所以你要在第一次登录时后台存一下这些数据，然后按照userIdentifier找找是不是已存在；</p><p>如果你还想再模拟第一次授权登录，在<a href="https://appleid.apple.com/%E7%BD%91%E7%AB%99%EF%BC%8C%E7%99%BB%E5%BD%95%E5%92%8C%E5%AE%89%E5%85%A8%E2%80%94%E9%80%9A%E8%BF%87appleid%E7%99%BB%E5%BD%95%E8%BF%99%E9%87%8C%E5%88%A0%E6%8E%89%E4%BD%A0%E6%8E%88%E6%9D%83%E7%9A%84app%EF%BC%8C%E5%B0%B1%E5%8F%AF%E4%BB%A5%E4%BA%86%E3%80%82">https://appleid.apple.com/网站，登录和安全—通过appleid登录这里删掉你授权的app，就可以了。</a></p><p>3、如果用户选择隐藏email,会返回一个代理邮箱，用户还可以更换实际的familyName，givenName。</p><h3 id="3-示例"><a href="#3-示例" class="headerlink" title="3. 示例"></a>3. 示例</h3><p>示例代码：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">void</span> appleIdLogin() <span class="hljs-keyword">async</span> &#123;<br>  <span class="hljs-keyword">final</span> credential = <span class="hljs-keyword">await</span> SignInWithApple.getAppleIDCredential(<br>    scopes: [<br>      AppleIDAuthorizationScopes.email,<br>      AppleIDAuthorizationScopes.fullName,<br>    ],<br>  );<br>  <span class="hljs-comment">// SignInWithApple.</span><br>  <span class="hljs-built_in">print</span>(credential.userIdentifier);<br>  <span class="hljs-built_in">print</span>(credential.familyName);<br>  <span class="hljs-built_in">print</span>(credential.givenName);<br>  <span class="hljs-built_in">print</span>(credential.email);<br>  <span class="hljs-built_in">print</span>(credential.authorizationCode);<br>  <span class="hljs-built_in">print</span>(credential.identityToken);<br>  <span class="hljs-built_in">print</span>(credential.state);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/image/article/flutter/flutter-signInWithApple/1.png"></p>]]></content>
    
    
    <categories>
      
      <category>Flutter</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Flutter</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Flutter In App Purchases</title>
    <link href="/2024/02/10/flutter/flutter-inapp-purchases/"/>
    <url>/2024/02/10/flutter/flutter-inapp-purchases/</url>
    
    <content type="html"><![CDATA[<p>使用插件：<a href="https://pub-web.flutter-io.cn/packages/in_app_purchase">in_app_purchase</a><br>google play地址：<a href="https://play.google.com/console/u/1/developers/4680574610336798026/app-list?pli=1">Google Play</a></p><p>ios内购参考链接：<br>  <a href="https://www.jianshu.com/p/72748db72a77">商品配置和测试配置</a><br>  <a href="https://www.dengshunlai.com/blog/iap.html">恢复购买</a></p><p>android内购参考链接：<br>  <a href="https://www.jianshu.com/p/f6b01d108981">账号设置</a></p><p>in_app_purchase 是 Flutter 官方团队出的插件，支持 iOS 和 Android 平台的内购功能。</p><h3 id="1-开发者账号设置"><a href="#1-开发者账号设置" class="headerlink" title="1. 开发者账号设置"></a>1. 开发者账号设置</h3><p>Google Play Console 和 App Store Connect 的账号设置都比较简单，按照文档来就行了，其中支付相关的沙盒测试人员，收款账户协议这些都是在应用外层的，只有商品信息是在应用内设置的，这一点两个平台是一致的。</p><h4 id="android部分："><a href="#android部分：" class="headerlink" title="android部分："></a>android部分：</h4><p>1、设置付款资料，必须先设置付款资料才能进行下面的设置(就是收款账号把，为什么叫付款资料？看来是google视角)；<br>2、设置应用内商品；<br><img src="/image/article/flutter/flutter-inapp-purchases/1.png"><br>3、添加测试账号；<br><img src="/image/article/flutter/flutter-inapp-purchases/2.png"><br>4、测试内购必须使用内部测试版本；<br>google play有三个测试类型，开放式测试，封闭式测试，内部测试，开放式测试是可以分发给任何人，封闭式测试是分发给一部分人灰度测试，这些人必须在测试账号里面或者收到邀请，但是封闭式测试是需要发布给google审核的，内部测试是开发人员测试用的。要测试内购需要测试员账号，所以是用内部测试；必须在内部测试的测试人员那个页面的下面点击复制链接，从这里链接下载的app才能获取到商品，否则是空的；<br>5、android的订阅通知是需要配置Google开发者通知的<br>参考链接：<a href="https://developer.android.com/google/play/billing/rtdn-reference?hl=zh-cn#grant_publish_rights_on_your_topic">Google Play Bill Pub&#x2F;Sub</a><br><a href="https://console.cloud.google.com/apis/dashboard">在这里配置发布订阅信息</a><br>创建发布主题<br><img src="/image/article/flutter/flutter-inapp-purchases/4.png"><br><img src="/image/article/flutter/flutter-inapp-purchases/5.png"><br>创建订阅者和接口(订阅消息会往这个服务端接口推送)<br><img src="/image/article/flutter/flutter-inapp-purchases/6.png"><br>最后在Google Play Console的设置里面配置一下这个发布主题就行了<br><img src="/image/article/flutter/flutter-inapp-purchases/7.png"><br>订阅信息类型如下：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs markdown">/**<br><span class="hljs-bullet">   *</span> notificationType    int<br><span class="hljs-bullet">   *</span> 通知的类型。它可以具有以下值：<br><span class="hljs-bullet">   *</span> (1) SUBSCRIPTION<span class="hljs-emphasis">_RECOVERED - 从帐号保留状态恢复了订阅。</span><br><span class="hljs-emphasis">   * (2) SUBSCRIPTION_</span>RENEWED - 续订了处于活动状态的订阅。<br><span class="hljs-bullet">   *</span> (3) SUBSCRIPTION<span class="hljs-emphasis">_CANCELED - 自愿或非自愿地取消了订阅。如果是自愿取消，在用户取消时发送。</span><br><span class="hljs-emphasis">   * (4) SUBSCRIP￼￼TION_</span>PURCHASED - 购买了新的订阅。<br><span class="hljs-bullet">   *</span> (5) SUBSCRIPTION<span class="hljs-emphasis">_ON_</span>HOLD - 订阅已进入帐号保留状态（如已启用）。<br><span class="hljs-bullet">   *</span> (6) SUBSCRIPTION<span class="hljs-emphasis">_IN_</span>GRACE<span class="hljs-emphasis">_PERIOD - 订阅已进入宽限期（如已启用）。</span><br><span class="hljs-emphasis">   * (7) SUBSCRIPTION_</span>RESTARTED - 用户已通过“Play”&gt;“帐号”&gt;“订阅”重新激活其订阅（需要选择使用订阅恢复功能）。<br><span class="hljs-bullet">   *</span> (8) SUBSCRIPTION<span class="hljs-emphasis">_PRICE_</span>CHANGE<span class="hljs-emphasis">_CONFIRMED - 用户已成功确认订阅价格变动。</span><br><span class="hljs-emphasis">   * (9) SUBSCRIPTION_</span>DEFERRED - 订阅的续订时间点已延期。<br><span class="hljs-bullet">   *</span> (10) SUBSCRIPTION<span class="hljs-emphasis">_PAUSED - 订阅已暂停。</span><br><span class="hljs-emphasis">   * (11) SUBSCRIPTION_</span>PAUSE<span class="hljs-emphasis">_SCHEDULE_</span>CHANGED - 订阅暂停计划已更改。<br><span class="hljs-bullet">   *</span> (12) SUBSCRIPTION<span class="hljs-emphasis">_REVOKED - 用户在有效时间结束前已撤消订阅。</span><br><span class="hljs-emphasis">   * (13) SUBSCRIPTION_</span>EXPIRED - 订阅已过期。<br><span class="hljs-emphasis">*/</span><br></code></pre></td></tr></table></figure><h4 id="ios部分："><a href="#ios部分：" class="headerlink" title="ios部分："></a>ios部分：</h4><p>1、开发者证书那一套我就不说了，Identifiers那里的In-app purchases是默认勾选的；<br>2、添加内购商品信息，在app store connect 里面的  功能-app内购项目  模块，商品有四种：消耗型商品，非消耗型商品，自动续期订阅，非续期订阅。其中非消耗型商品，自动续期订阅这两种是需要恢复购买功能的。<br>3、在用户和访问模块左下方添加沙盒测试员，测试购买流程，这玩意烦得很，还必须是没注册过苹果账号的邮箱；<br><img src="/image/article/flutter/flutter-inapp-purchases/3.png"><br>4、正式提交审核app的时候需要选择之前创建的商品，测试的时候不用管；<br>5、协议，税务，银行卡信息，其他信息没什么，那个CNAPS代码是这个发卡银行具体支行的代码；</p><h3 id="2-注意事项"><a href="#2-注意事项" class="headerlink" title="2. 注意事项"></a>2. 注意事项</h3><p>1、其中非消耗型商品，自动续期订阅这两种是需要恢复购买功能的，不然app会被拒绝；</p><p>为什么需要恢复购买这个行为？？？按道理说服务端其实已经存了购买记录并且和App的账号体系绑定，换设备了也可以恢复，由软件提供商自己判断就行了，那么恢复购买是基于什么考虑的呢？</p><ul><li>苹果希望支付行为和Apple ID绑定，而不是仅仅是和应用绑定；</li><li>并不是所有的App都有账号体系，所以需要恢复购买这个行为；</li><li>软件提供商有可能会要求更换设备重新购买商品，恢复购买是为了保护用户的权益；</li></ul><p>2、android不需要加<code>com.android.billingclient:billing</code>这个依赖，因为我们是flutter插件；</p><p>3、google play有三个测试类型，开放式测试，封闭式测试，内部测试，开放式测试是可以分发给任何人，封闭式测试是分发给一部分人灰度测试，这些人必须在测试账号里面或者收到邀请，但是封闭式测试是需要发布给google审核的，内部测试是开发人员测试用的。要测试内购需要测试员账号，所以是封闭式测试或者内部测试；<br>我发布了一个内部测试，发现删不掉了，靠！<br>新建一个测试轨道，也删不掉，只能暂停，牛逼。</p><p>4、google play 商店中appbundle要删除就必须把与他从已经关联的版本中分离出来，这样appbundle详情页才会有删除按钮；</p><p>5、我的app并没有集成广告，但是发布封闭式测试总是提示：</p><p>此版本包含 com.google.android.gms.permission.AD_ID 权限，但您在 Play 管理中心的声明中指出您的应用未使用广告 ID。您必须更新广告 ID 声明。</p><p>原因是我用了google_sign_in这个插件，它是依赖于firebase的，firebase项目开启了google Analytics，这玩意在项目打包阶段自动会加入一个权限，把aab文件后缀改成zip，解压之后在</p><p>base&#x2F;manifest&#x2F;AndroidManifest.xml文件中你就能看见ads权限声明了，如下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dart">&lt;uses-permission android:name=<span class="hljs-string">&quot;com.google.android.gms.permission.AD_ID&quot;</span> /&gt;<br></code></pre></td></tr></table></figure><p><a href="https://stackoverflow.com/questions/74127836/your-manifest-file-doesnt-include-the-com-google-android-gms-permission-ad-id-p">stackoverflow</a>上的解决方案是下面这段代码，不允许添加这条权限，那么google Analytics也不会生效</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dart">&lt;uses-permission android:name=<span class="hljs-string">&quot;com.google.android.gms.permission.AD_ID&quot;</span> tools:node=<span class="hljs-string">&quot;remove&quot;</span>/&gt;<br></code></pre></td></tr></table></figure><p>那么干脆取消google Analytics算了，在firebase项目设置—集成 这里；</p><p>好了，我试过了，不管用，去掉设置依然还是会加入这段ad_id权限代码；</p><p>尝试用tools:node&#x3D;”remove”来解决问题，这需要在最上面的<code>&lt;manifest</code>这里加</p><p>xmlns:tools&#x3D;”<a href="http://schemas.android.com/tools">http://schemas.android.com/tools</a>“</p><p>最后是这样，<a href="https://stackoverflow.com/questions/55334431/facing-below-error-toolsnode-associated-with-an-element-type-uses-permission">参考链接</a>：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dart">&lt;manifest xmlns:android=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span> xmlns:tools=<span class="hljs-string">&quot;http://schemas.android.com/tools&quot;</span>&gt;<br></code></pre></td></tr></table></figure><p>有效！！！，这条权限是去掉了，但是商店里任然说有广告，我很无语，又查了一圈好像是<a href="https://support.google.com/googleplay/android-developer/answer/6048248#zippy=">google要求必须加上去广告ID</a>，哎，说不清道不明那就当我有广告吧，配置改回去。</p><p>6、android需要安装google 三件套才能用支付内购，我用的三星手机，三星毕竟是全球商品，内置有三件套其中的两个服务框架，所以只需要安装google play store就行了，先在商店里安装HiGoPlay ，然后用这个安装google play store</p><h3 id="3-代码实现"><a href="#3-代码实现" class="headerlink" title="3. 代码实现"></a>3. 代码实现</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;dart:async&#x27;</span>;<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:soulmate/utils/plugin/plugin.dart&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:soulmate/widgets/library/projectLibrary.dart&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:in_app_purchase/in_app_purchase.dart&#x27;</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppPurchase</span> </span>&#123;<br>  <span class="hljs-comment">///<span class="language-markdown">订单信息订阅</span></span><br>  <span class="hljs-keyword">static</span> <span class="hljs-keyword">late</span> StreamSubscription&lt;<span class="hljs-built_in">dynamic</span>&gt; _subscription;<br><br>  <span class="hljs-comment">///<span class="language-markdown">订单业务回调</span></span><br>  <span class="hljs-keyword">static</span> <span class="hljs-built_in">Function?</span> orderCallback;<br><br>  <span class="hljs-comment">///<span class="language-markdown">初始化支付订单状态订阅</span></span><br>  <span class="hljs-keyword">static</span> initAppPayConfig() <span class="hljs-keyword">async</span> &#123;<br>    <span class="hljs-keyword">final</span> Stream purchaseUpdated = InAppPurchase.instance.purchaseStream;<br>    _subscription = purchaseUpdated.listen((purchaseDetailsList) &#123;<br>      _listenToPurchaseUpdated(purchaseDetailsList);<br>    &#125;, onDone: () &#123;<br>      _subscription.cancel();<br>    &#125;, onError: (error) &#123;<br>      <span class="hljs-comment">// handle error here.</span><br>    &#125;);<br>  &#125;<br><br>  <span class="hljs-comment">///<span class="language-markdown">支付状态逻辑处理</span></span><br>  <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> _listenToPurchaseUpdated(<br>      <span class="hljs-built_in">List</span>&lt;PurchaseDetails&gt; purchaseDetailsList) &#123;<br>    purchaseDetailsList.forEach((PurchaseDetails purchaseDetails) <span class="hljs-keyword">async</span> &#123;<br>      <span class="hljs-keyword">if</span> (purchaseDetails.status == PurchaseStatus.pending) &#123;<br>        <span class="hljs-comment">///<span class="language-markdown">购买进行中，展示加载框</span></span><br>        Loading.<span class="hljs-keyword">show</span>();<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// APPPlugin.logger.d(purchaseDetails.status);</span><br>        <span class="hljs-comment">// APPPlugin.logger.d(purchaseDetails.purchaseID);</span><br>        Loading.dismiss();<br>        <span class="hljs-keyword">if</span> (purchaseDetails.status == PurchaseStatus.error) &#123;<br>          <span class="hljs-comment">///<span class="language-markdown">购买失败，展示失败信息</span></span><br>          <span class="hljs-comment">// Loading.error(purchaseDetails.error!.message!);</span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (purchaseDetails.status == PurchaseStatus.purchased ||<br>            purchaseDetails.status == PurchaseStatus.restored) &#123;<br>          <span class="hljs-comment">///<span class="language-markdown">购买成功，展示成功信息</span></span><br>          <span class="hljs-comment">// print(purchaseDetails.status);</span><br>          <span class="hljs-comment">// print(&#x27;purchaseID：$&#123;purchaseDetails.purchaseID&#125;&#x27;);</span><br>          <span class="hljs-comment">// print(&#x27;productID：$&#123;purchaseDetails.productID&#125;&#x27;);</span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (purchaseDetails.status == PurchaseStatus.restored) &#123;<br>          <span class="hljs-comment">///<span class="language-markdown">恢复购买</span></span><br>          <span class="hljs-comment">// print(purchaseDetails);</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> (purchaseDetails.pendingCompletePurchase) &#123;<br>          <span class="hljs-comment">///<span class="language-markdown">这个方法是为了应对购买成功后，app崩溃了，重新打开app，此时需要通知IAP平台，已经完成了购买流程</span></span><br>          InAppPurchase.instance.completePurchase(purchaseDetails);<br>        &#125;<br>        <span class="hljs-comment">// APPPlugin.logger.d(purchaseDetails.status);</span><br>        <span class="hljs-comment">///<span class="language-markdown">调用回调的后台接口，通知后台购买成功或者失败</span></span><br>        <span class="hljs-keyword">if</span> (orderCallback != <span class="hljs-keyword">null</span>) &#123;<br>          orderCallback!(purchaseDetails);<br>        &#125;<br>      &#125;<br>    &#125;);<br>  &#125;<br><br>  <span class="hljs-comment">///<span class="language-markdown">获取ios和android商店里面配置的商品列表</span></span><br>  <span class="hljs-keyword">static</span> Future&lt;<span class="hljs-built_in">List</span>&lt;ProductDetails&gt;&gt; getServerProducts(<br>      <span class="hljs-built_in">Set</span>&lt;<span class="hljs-built_in">String</span>&gt; pIds) <span class="hljs-keyword">async</span> &#123;<br>    <span class="hljs-comment">///<span class="language-markdown">根据商品id获取云端商品列表</span></span><br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-keyword">final</span> <span class="hljs-built_in">bool</span> isAvailable = <span class="hljs-keyword">await</span> InAppPurchase.instance.isAvailable();<br>      <span class="hljs-keyword">if</span> (!isAvailable) &#123;<br>        <span class="hljs-keyword">return</span> [];<br>      &#125;<br>      <span class="hljs-keyword">final</span> ProductDetailsResponse response =<br>          <span class="hljs-keyword">await</span> InAppPurchase.instance.queryProductDetails(pIds);<br>      <span class="hljs-keyword">if</span> (response.notFoundIDs.isNotEmpty) &#123;<br>        <span class="hljs-keyword">return</span> [];<br>      &#125;<br>      <span class="hljs-keyword">return</span> response.productDetails;<br>    &#125; <span class="hljs-keyword">catch</span> (err) &#123;<br>      APPPlugin.logger.e(err);<br>    &#125;<br>    <span class="hljs-keyword">return</span> [];<br>  &#125;<br><br>  <span class="hljs-comment">///<span class="language-markdown">购买商品 type 1:购买 2:订阅</span></span><br>  <span class="hljs-keyword">static</span> payProductNow(<br>      ProductDetails productDetails, <span class="hljs-built_in">int</span> type, <span class="hljs-built_in">String</span> orderId) &#123;<br>    <span class="hljs-keyword">if</span> (productDetails == <span class="hljs-keyword">null</span>) &#123;<br>      exSnackBar(<span class="hljs-string">&quot;please check you product&quot;</span>, type: ExSnackBarType.warning);<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">final</span> PurchaseParam purchaseParam = PurchaseParam(<br>        productDetails: productDetails, applicationUserName: orderId);<br>    <span class="hljs-comment">// 消耗型商品(一次性购买)和非消耗型商品(月度订阅，年度订阅)的购买是不一样的</span><br>    <span class="hljs-keyword">if</span> (type == <span class="hljs-number">1</span>) &#123;<br>      InAppPurchase.instance.buyConsumable(purchaseParam: purchaseParam);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      InAppPurchase.instance.buyNonConsumable(purchaseParam: purchaseParam);<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">///<span class="language-markdown">恢复购买</span></span><br>  <span class="hljs-comment">///<span class="language-markdown">消耗型项目，非消耗型，自动续期订阅，非续期订阅</span></span><br>  <span class="hljs-comment">///<span class="language-markdown">恢复购买是恢复非消耗型的商品或者自动续期订阅这两种类型</span></span><br>  <span class="hljs-comment">///<span class="language-markdown">这个需要提供一个手动按钮恢复，不然上架不给过哦</span></span><br>  <span class="hljs-keyword">static</span> restorePuchases() <span class="hljs-keyword">async</span> &#123;<br>    <span class="hljs-keyword">await</span> InAppPurchase.instance.restorePurchases();<br>  &#125;<br><br>  <span class="hljs-comment">///<span class="language-markdown">取消支付订阅</span></span><br>  <span class="hljs-keyword">static</span> disposeSubscription() &#123;<br>    _subscription.cancel();<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Flutter</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Flutter</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>文本语音互相转换</title>
    <link href="/2024/01/26/investigation/tts-stt/"/>
    <url>/2024/01/26/investigation/tts-stt/</url>
    
    <content type="html"><![CDATA[<h1 id="TTS-文字转语音-Text-To-Speech"><a href="#TTS-文字转语音-Text-To-Speech" class="headerlink" title="TTS 文字转语音 Text To Speech"></a>TTS 文字转语音 Text To Speech</h1><p>要求：</p><ul><li>能自动识别文本语言，最好也支持混合语言文本（我们并不知道用户的语言是什么）；</li><li>输出的语音要求支持多个角色，比如男声、女声、儿童声等；</li><li>价格便宜。</li></ul><h3 id="1、chatgpt-Text-to-speech"><a href="#1、chatgpt-Text-to-speech" class="headerlink" title="1、chatgpt Text to speech"></a>1、chatgpt Text to speech</h3><p><a href="https://platform.openai.com/docs/guides/text-to-speech">文档链接</a><br>可以自动识别语言，混合语言也可以，价格是$0.015 &#x2F; 1K characters；<br>问题是目前的角色太少了，只发布了6个，不满足我们的需求</p><h3 id="2、微软的文本转语音"><a href="#2、微软的文本转语音" class="headerlink" title="2、微软的文本转语音"></a>2、微软的文本转语音</h3><p><a href="https://learn.microsoft.com/en-us/azure/ai-services/speech-service/quickstarts/setup-platform?pivots=programming-language-csharp&tabs=linux,ubuntu,dotnetcli,dotnet,jre,maven,nodejs,mac,pypi">微软说明文档</a></p><p>对接很简单，问题是你必须指定输入的是什么语言，如果是混合语言输入，<a href="https://learn.microsoft.com/en-us/answers/questions/1291981/how-do-i-change-multilingual-jennys-language-in-py">必须使用xml的方式</a>，我们的产品是并不会提前知道输出的是什么语言，所以不符合要求</p><p>中间部署服务发生的一个小插曲，我们的linux系统是Ubuntu22.04，<a href="https://stackoverflow.com/questions/72751026/how-to-fix-microsoft-cognitive-speech-error-failed-to-initialize-platform-azur">报错问题</a>，：</p><blockquote><p>The Speech SDK does not yet support OpenSSL 3.0, which is the default in Ubuntu 22.04 and Debian 12.<br>就是说微软的sdk要求linux系统是Ubuntu 22.04，但是却不支持openssl3.0，但是这玩意还是Ubuntu 22.04的默认配置，所以需要手动卸载然后安装低版本的openssl，真是坑爹</p></blockquote><h3 id="3、elevenlabs"><a href="#3、elevenlabs" class="headerlink" title="3、elevenlabs"></a>3、elevenlabs</h3><p><a href="https://elevenlabs.io/">文档链接</a><br>两个google机器学习相关的前员工创办的公司，能自动识别输入语言，支持混合语言，有多个输出语音角色可选，免费版账号有3个角色，nice，就它了</p><h2 id="STT-语音转文本-Speech-To-Text"><a href="#STT-语音转文本-Speech-To-Text" class="headerlink" title="STT 语音转文本 Speech To Text"></a>STT 语音转文本 Speech To Text</h2><p>要求：</p><ul><li>能自动识别语音的语言种类，最好混合语种输入也行（我们并不知道用户的语言是什么）；</li><li>价格便宜。</li></ul><p>其实一开始是找了几个开源的语音转文本库，合适的是这个：<a href="https://github.com/Uberi/speech_recognition">Uberi&#x2F;speech_recognition</a></p><p>发现它是混合了google microsoft这些厂家的技术，既然如此，我们自己去看文档就行了，不需要这个封装一层；</p><h3 id="1、google-cloud"><a href="#1、google-cloud" class="headerlink" title="1、google cloud"></a>1、google cloud</h3><p>看基本功能，这些都没问题，问题就在于自动识别语言，默认情况下你是必须手动指定你的语音文件的语言，如果语音文件中你说的是中文，传给sdk的说语音是英文，那这个就识别不出来。</p><p>google也是有自动识别语言功能的，但是它是让你传语言数组参数，这个数组最多三个语言，自动匹配相似的语言，<a href="https://cloud.google.com/speech-to-text/v2/docs/multiple-languages?hl=zh-cn">官方文档</a></p><p>不符合要求</p><p>2、microsoft<br>基本功能我就不说了，自动识别语言的问题，<a href="https://learn.microsoft.com/en-us/azure/ai-services/speech-service/language-identification?tabs=once&pivots=programming-language-python">官方文档在这</a></p><p>和google类似最多传入10个语言，不匹配会返回最相似的一个，原话在此：</p><blockquote><p>语音服务会返回提供的一种候选语言，即使这些语言不在音频中也是如此。例如，如果提供<code>fr-FR</code>（法语）和<code>en-US</code>（英语）作为候选，但讲德语，则将返回<code>fr-FR</code>或。<code>en-US</code></p></blockquote><p>不符合要求</p><h3 id="3、chatgpt"><a href="#3、chatgpt" class="headerlink" title="3、chatgpt"></a>3、chatgpt</h3><p><a href="https://platform.openai.com/docs/guides/speech-to-text/quickstart">文档链接</a><br>支持混合语种的语音输入，价格是$0.006 &#x2F; minute，满足要求</p>]]></content>
    
    
    <categories>
      
      <category>技术调研</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ai</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Flutter Messaging Push</title>
    <link href="/2023/11/24/flutter/flutter-messaging-push/"/>
    <url>/2023/11/24/flutter/flutter-messaging-push/</url>
    
    <content type="html"><![CDATA[<p>使用插件：<a href="https://pub-web.flutter-io.cn/packages/firebase_messaging">firebase_messaging</a><br>项目设置文档：<a href="https://firebase.flutter.dev/docs/messaging/overview">Firebase Messaging</a><br>使用文档：<a href="https://firebase.google.com/docs/cloud-messaging?hl=zh-cn">Firebase Cloud Messaging</a></p><p>这个插件的作用是实现 Flutter 应用的推送功能，Firebase Cloud Messaging (FCM) 是 Google 提供的一种跨平台消息传递解决方案，可以让开发者向 Android、iOS 和 Web 应用发送通知和数据消息。<br>我本来想偷懒，直接使用国内的jpush的，突然想起jpush的离线推送问题(ios有自己的apns推送，google有自己的message推送，由于国内墙的问题，google服务不能用，所以国内app的离线推送都有点问题，这个就不细说了)jpush是通过厂商通道vip账户解决的这个问题，在国外这一套自然也就行不通(跟客服确认过不行)，最后还是要老老实实看message的文档。</p><h3 id="1-注册firebase账号，创建应用"><a href="#1-注册firebase账号，创建应用" class="headerlink" title="1. 注册firebase账号，创建应用"></a>1. 注册firebase账号，创建应用</h3><p><a href="https://console.firebase.google.com/?hl=zh-cn&_gl=1*nyz7us*_ga*NTgwMTcyNzQuMTcyNTE3NTA2Mw..*_ga_CW55HF8NVT*MTczMzg5NzgyMy4yLjEuMTczMzg5ODA3Ny41MC4wLjA.">FireBase控制台</a></p><p>创建一个项目</p><p><img src="/image/article/flutter/flutter-googleSignIn/1.png"></p><p>在项目下新建android和ios应用</p><p><img src="/image/article/flutter/flutter-googleSignIn/2.png"></p><h3 id="2-项目设置"><a href="#2-项目设置" class="headerlink" title="2. 项目设置"></a>2. 项目设置</h3><h4 id="2-1-firebase平台的设置"><a href="#2-1-firebase平台的设置" class="headerlink" title="2.1 firebase平台的设置"></a>2.1 firebase平台的设置</h4><p>adnroid:</p><p>因为之前我使用firebase设置了项目的常规部分，android的包名，sha1都已经配置好了，所以不需要额外配置，这里有个注意事项，如果你在使用flutterEmbedding v1需要设置background service , V2是不需要的，如何判断你的项目是什么版本呢，查看android&#x2F;src&#x2F;main&#x2F;AndroidManifest.xml</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;meta-data android:name=<span class="hljs-string">&quot;flutterEmbedding&quot;</span> android:value=<span class="hljs-string">&quot;2&quot;</span> /&gt;<br></code></pre></td></tr></table></figure><p>ios:<br>ios需要在云消息传递中设置apns推送证书或者apns秘钥，秘钥方式是推荐的用法，因为apns证书每年都需要更换，秘钥是永不过期的(真好)。在开发者页面左侧的keys新建一个，包含你要用的功能（我加了Apple Push Notifications service (APNs)和Sign In with Apple），下载p8文件，保存好，它只能下载一次。在firebase后台上传p8秘钥文件后还有两个id,一个是<strong>Key ID</strong>在keys界面可以看到，还有个团队id在开发者账号页可以看到。</p><p>此外还需要在xcode的Signing&amp;Capabilities中加上Push Notifications</p><h4 id="2-2-flutter项目的设置"><a href="#2-2-flutter项目的设置" class="headerlink" title="2.2 flutter项目的设置"></a>2.2 flutter项目的设置</h4><p>设置文档：<a href="https://firebase.google.com/docs/cloud-messaging/flutter/client?hl=zh-cn#platform-specific_setup_and_requirements">Firebase Cloud Messaging Setup</a></p><p><strong>第一步</strong>是安装firebase的cli,登录这步遇到了问题，装完cli之后，firebase login就是不行：<br><img src="/image/article/flutter/flutter-messaging-push/1.png"><br>我在google上搜了好半天，据说是firebase登录使用全局代理也不行，<a href="https://github.com/firebase/firebase-tools/issues/155">Issue155</a><br>根据issue的评论找到一个<a href="https://stackoverflow.com/questions/27098328/firebase-in-nodejs-with-http-proxy/28155536#28155536">stackoverflow的解决方法</a>，就是要设置一个本地的代理：</p><p><code>export http_proxy=http://127.0.0.1:1234</code>像这样的(根据你自己的梯子来)，不用担心,export只在目前的命令行窗口生效，是临时的；</p><p>设置完代理<code>http_proxy</code>还是执行<code>firebase login</code>命令，依旧不行，我就全部设置一遍；</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">export</span> <span class="hljs-attribute">https_proxy</span>=http://127.0.0.1:7890 <span class="hljs-attribute">http_proxy</span>=http://127.0.0.1:7890 <span class="hljs-attribute">all_proxy</span>=socks5://127.0.0.1:7890<br></code></pre></td></tr></table></figure><p>然后就好了，可能是all_proxy生效了，有firewall，干个啥是真不容易啊<br><img src="/image/article/flutter/flutter-messaging-push/2.png"></p><p><strong>第二步</strong>是全局安装<code>flutterfire_cli</code>这玩意顾名思义就是flutter项目的专属cli，装完之后配置一个全局变量：export PATH&#x3D;”$PATH”:”$HOME&#x2F;.pub-cache&#x2F;bin”</p><p>然后用命令在flutter项目根目录执行 flutterfire configure 配置flutter项目,</p><p>它还会自动下载google-services.json文件，位置在android&#x2F;app&#x2F;google-services.json；</p><p>还会自动生成一个默认配置文件lib&#x2F;firebase_options.dart</p><p>还会在android&#x2F;build.gradle中加依赖<code>classpath &#39;com.google.gms:google-services:4.3.10&#39;</code></p><p>ios也会自动加文件：ios&#x2F;firebase_app_id_file.json</p><p><font color='red'>注意</font>：</p><p>在第一步安装firebase cli的文档中，login之后文档说需要执行初始化：firebase init 命令，它是原生项目才需要的，我们的flutter项目是不需要的，firebase cli只负责登录，获取项目信息，flutter项目是要靠第二步的cli生成配置的。<br>在很多例子和文档在flutter项目的main.dart中执行了,其实不需要。</p><h3 id="3-使用"><a href="#3-使用" class="headerlink" title="3. 使用"></a>3. 使用</h3><p>初始化配置</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">/// <span class="language-markdown">初始化</span></span><br><span class="hljs-keyword">await</span> Firebase.initializeApp(options: DefaultFirebaseOptions.currentPlatform);<br><span class="hljs-comment">/// <span class="language-markdown">权限请求</span></span><br>NotificationSettings settings = <span class="hljs-keyword">await</span> FirebaseMessaging.instance.requestPermission(<br>  alert: <span class="hljs-keyword">true</span>,<br>  announcement: <span class="hljs-keyword">false</span>,<br>  badge: <span class="hljs-keyword">true</span>,<br>  carPlay: <span class="hljs-keyword">false</span>,<br>  criticalAlert: <span class="hljs-keyword">false</span>,<br>  provisional: <span class="hljs-keyword">false</span>,<br>  sound: <span class="hljs-keyword">true</span>,<br>);<br></code></pre></td></tr></table></figure><p>android 默认的推送图标不正确，需要加一行</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs haskell">&lt;meta-<span class="hljs-class"><span class="hljs-keyword">data</span></span><br>      android:name=<span class="hljs-string">&quot;com.google.firebase.messaging.default_notification_icon&quot;</span><br>      android:resource=<span class="hljs-string">&quot;@drawable/push_logo&quot;</span> /&gt;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Flutter</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Flutter</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Flutter Mobile Ads</title>
    <link href="/2023/11/08/flutter/flutter-mobile-ads/"/>
    <url>/2023/11/08/flutter/flutter-mobile-ads/</url>
    
    <content type="html"><![CDATA[<p>使用插件：<a href="https://pub-web.flutter-io.cn/packages/google_mobile_ads">google_mobile_ads</a><br>文档地址：<a href="https://developers.google.cn/admob/flutter/quick-start">Google AdMob</a></p><p>这个插件的作用是在 Flutter 应用中集成 Google Mobile Ads SDK，通过 Google 的广告平台在应用中展示广告，从而实现应用的变现。没错就是你玩游戏的时候看到的那些魔性小广告。我们集成这个插件的目的就是为了在应用中展示广告，用户获取应用内积分用于购买虚拟物品，我们获取广告收益。</p><h3 id="1-注册Google-AdMob账号"><a href="#1-注册Google-AdMob账号" class="headerlink" title="1. 注册Google AdMob账号"></a>1. 注册Google AdMob账号</h3><p>google家的嘛，你得先有个google账号才能去注册;<br>注册地址：<a href="https://admob.google.com/home/">Google AdMob</a></p><p>填写账号信息，收款银行卡信息等等这些就按照要求填吧</p><p><font color='red'>注意事项</font>：账号注册的地区写了就不能改了，这个地区要和收款银行卡一致，据说后面google还会往这个地区的一个地址里面寄一个包裹邮件，包含pin码，必须要校验这个码，才能收钱(我还没走到这一步项目就暂停了,非常可惜)；</p><p>下一步还需要验证这个地区的一个手机验证码，我第一次注册写的是美国，尴尬了，又注册了第二个是中国。</p><h3 id="2-创建应用，分别创建android和ios应用"><a href="#2-创建应用，分别创建android和ios应用" class="headerlink" title="2. 创建应用，分别创建android和ios应用"></a>2. 创建应用，分别创建android和ios应用</h3><p>没有项目的概念，直接添加应用，android和ios各一个，每个应用里面可以设置广告单元，不同的广告单元对应不同的虚拟价值。<br>广告类型有四种：</p><ul><li>横幅广告<br>  横幅广告是在设备屏幕的顶部或底部展示的矩形广告。它们可以是静态的或动态的，并且可以包含文本、图像或视频。横幅广告会停留在界面上，并且可在一段时间后自动刷新。占用一部分屏幕，很让人讨厌的那种，哈哈。</li><li>插屏广告<br>  插屏广告是在应用的自然停顿点展示的全屏广告。它们通常在用户完成一个任务或操作后出现，例如在游戏关卡结束时。这个广告类型是最常见的，就是被动观看有点烦人。</li><li>激励广告<br>  激励广告是全屏广告，用户观看广告后可以获得奖励，例如游戏内货币或额外的生命。用户必须主动选择观看这些广告，并且在观看完毕后才能获得奖励。这个广告类型是用户为了获取奖励，自己主动点击的，所以接受度还行，我用的也是这种。</li><li>原生广告<br>  原生广告是与应用内容无缝集成的广告。它们可以根据应用的外观和感觉进行自定义，以提供更好的用户体验，并且可以在应用的不同部分展示。这个广告类型是最难做的，要求设计师和开发者配合，设计出一个和应用内容无缝集成的广告。</li></ul><p>初始化插件的代码如下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:google_mobile_ads/google_mobile_ads.dart&#x27;</span>;<br><span class="hljs-keyword">void</span> main() &#123;<br>  WidgetsFlutterBinding.ensureInitialized();<br>  MobileAds.instance.initialize();<br>  runApp(MyApp());<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-1-创建并配置Android项目："><a href="#2-1-创建并配置Android项目：" class="headerlink" title="2.1 创建并配置Android项目："></a>2.1 创建并配置Android项目：</h4><p>填写基本信息略；<br>配置：<br>AdMob 应用 ID 必须包含在 AndroidManifest.xml 中，否则会导致应用在启动时崩溃。<br>修改这个文件：android&#x2F;app&#x2F;src&#x2F;main&#x2F;AndroidManifest.xml</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">&lt;manifest&gt;<br>    &lt;application&gt;<br>        &lt;!-- Sample AdMob app ID: ca-app-pub-3940256099942544~3347511713 --&gt;<br>        &lt;meta-data<br>            android:name=<span class="hljs-string">&quot;com.google.android.gms.ads.APPLICATION_ID&quot;</span><br>            android:value=<span class="hljs-string">&quot;ca-app-pub-xxxxxxxxxxxxxxxx~yyyyyyyyyy&quot;</span>/&gt;<br>    &lt;application&gt;<br>&lt;manifest&gt;<br></code></pre></td></tr></table></figure><h4 id="2-2-创建并配置ios项目："><a href="#2-2-创建并配置ios项目：" class="headerlink" title="2.2 创建并配置ios项目："></a>2.2 创建并配置ios项目：</h4><p>填写基本信息略；<br>配置：<br>AdMob 应用 ID 必须包含在 Info.plist 中。<br>修改这个文件：ios&#x2F;Runner&#x2F;Info.plist</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">key</span>&gt;</span>GADApplicationIdentifier<span class="hljs-tag">&lt;/<span class="hljs-name">key</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">string</span>&gt;</span>ca-app-pub-################~##########<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span><br></code></pre></td></tr></table></figure><p><font color='red'>注意事项</font>：ios配置的时候我把<key>GADApplicationIdentifier</key>写到上一个facebook配置的array里面去了，太傻逼了，app直接崩溃了，希望你别学我。</p><h3 id="3-播放广告示例"><a href="#3-播放广告示例" class="headerlink" title="3. 播放广告示例"></a>3. 播放广告示例</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:get/get_utils/src/platform/platform.dart&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:google_mobile_ads/google_mobile_ads.dart&#x27;</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GoogleAds</span> </span>&#123;<br>  <span class="hljs-comment">/// <span class="language-markdown">这是广告单元信息--测试阶段是写的假的-todo</span></span><br>  <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> adUnitId = GetPlatform.isAndroid<br>      ? <span class="hljs-string">&#x27;ca-app-pub-3940256099942544/5224354917&#x27;</span><br>      : <span class="hljs-string">&#x27;ca-app-pub-3940256099942544/1712485313&#x27;</span>;<br>  <span class="hljs-comment">/// <span class="language-markdown">广告</span></span><br>  <span class="hljs-keyword">static</span> RewardedAd? _rewardedAd;<br>  <span class="hljs-comment">/// <span class="language-markdown">加载广告</span></span><br>  <span class="hljs-keyword">static</span> googleAdsLoad() <span class="hljs-keyword">async</span> &#123;<br>    RewardedAd.load(<br>        adUnitId: adUnitId,<br>        request: <span class="hljs-keyword">const</span> AdRequest(),<br>        rewardedAdLoadCallback: RewardedAdLoadCallback(<br>          <span class="hljs-comment">// Called when an ad is successfully received.</span><br>          onAdLoaded: (ad) &#123;<br>            ad.fullScreenContentCallback = FullScreenContentCallback(<br>              <span class="hljs-comment">// Called when the ad showed the full screen content.</span><br>                onAdShowedFullScreenContent: (ad) &#123;&#125;,<br>                <span class="hljs-comment">// Called when an impression occurs on the ad.</span><br>                onAdImpression: (ad) &#123;&#125;,<br>                <span class="hljs-comment">// Called when the ad failed to show full screen content.</span><br>                onAdFailedToShowFullScreenContent: (ad, err) &#123;<br>                  <span class="hljs-comment">// Dispose the ad here to free resources.</span><br>                  ad.dispose();<br>                &#125;,<br>                <span class="hljs-comment">// Called when the ad dismissed full screen content.</span><br>                onAdDismissedFullScreenContent: (ad) &#123;<br>                  <span class="hljs-comment">// Dispose the ad here to free resources.</span><br>                  ad.dispose();<br>                &#125;,<br>                <span class="hljs-comment">// Called when a click is recorded for an ad.</span><br>                onAdClicked: (ad) &#123;&#125;);<br><br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;<span class="hljs-subst">$ad</span> loaded.&#x27;</span>);<br>            <span class="hljs-comment">// Keep a reference to the ad so you can show it later.</span><br>            _rewardedAd = ad;<br>          &#125;,<br>          <span class="hljs-comment">// Called when an ad request failed.</span><br>          onAdFailedToLoad: (LoadAdError error) &#123;<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;RewardedAd failed to load: <span class="hljs-subst">$error</span>&#x27;</span>);<br>          &#125;,<br>        ),<br>    );<br>  &#125;<br>  <span class="hljs-comment">/// <span class="language-markdown">展示广告</span></span><br>  <span class="hljs-keyword">static</span> showAds()&#123;<br>    _rewardedAd?.<span class="hljs-keyword">show</span>(onUserEarnedReward: (AdWithoutView ad, RewardItem rewardItem) &#123;<br>      <span class="hljs-comment">// Reward the user for watching an ad.</span><br>    &#125;);<br>  &#125;<br>  <span class="hljs-comment">/// <span class="language-markdown">销毁广告</span></span><br>  <span class="hljs-keyword">static</span> disposeAds() &#123;<br>    _rewardedAd?.dispose();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Flutter</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Flutter</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Flutter Facebook Auth</title>
    <link href="/2023/09/23/flutter/flutter-facebookAuth/"/>
    <url>/2023/09/23/flutter/flutter-facebookAuth/</url>
    
    <content type="html"><![CDATA[<p>使用插件：<a href="https://pub-web.flutter-io.cn/packages/flutter_facebook_auth">flutter_facebook_auth</a><br>文档地址：<a href="https://facebook.meedu.app/">https://facebook.meedu.app/</a></p><p>首先声明，插件和文档的操作步骤是没有问题的，但是最后我们并没有使用facebook的登录，因为facebook的企业审核需要提供企业最近的水电缴费单或者税务账单以证明公司实际办公地址的真实性，这个我们提供不了，哈哈，所以此文档就仅供参考了。</p><h3 id="1-账号"><a href="#1-账号" class="headerlink" title="1. 账号"></a>1. 账号</h3><p>首先你要有一个facebook的账号（之前用google的企业邮箱注册的好几个账号都被禁了，用gmail邮箱注册的是可以用的，不明所以），然后用这个账号在<a href="https://developers.facebook.com/apps/creation/?locale=en">facebook开发者网站</a>注册一个应用：<br><img src="/image/article/flutter/flutter-facebookAuth/1.png"></p><p>Use cases 这一栏选择使用facebook 登录：<br><img src="/image/article/flutter/flutter-facebookAuth/2.png"></p><p>然后一步步完成；</p><h3 id="2-配置项目"><a href="#2-配置项目" class="headerlink" title="2. 配置项目"></a>2. 配置项目</h3><p>最后来到应用配置界面：<br><img src="/image/article/flutter/flutter-facebookAuth/3.png"></p><p>第一步的定制登录按钮里面需要获取邮箱的就需要加上：<br><img src="/image/article/flutter/flutter-facebookAuth/4.png"></p><p>你可以先把APP setting里面的基本信息补充完整一下，隐私协议、服务条款、icon等等。</p><h4 id="配置Android："><a href="#配置Android：" class="headerlink" title="配置Android："></a>配置Android：</h4><p>然后再快速启动中配置android和ios项目，这这里配置其实和在<a href="https://developers.facebook.com/docs/facebook-login/android/?locale=en">开发文档</a>中配置是一样的<br><img src="/image/article/flutter/flutter-facebookAuth/5.png"></p><p>在android的第三步设置包名和启动Activity<br><img src="/image/article/flutter/flutter-facebookAuth/6.png"></p><p>第四步是设置秘钥，人家平台都是要sha1，它要的好像是sha1的base64 key hashes，debug和release都需要，这个在项目setting的basic下新建platform填写，有个生成的命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">keytool -exportcert -<span class="hljs-built_in">alias</span> YOUR_RELEASE_KEY_ALIAS -keystore YOUR_RELEASE_KEY_PATH | openssl sha1 -binary | openssl <span class="hljs-built_in">base64</span><br></code></pre></td></tr></table></figure><p>然后来到第六步，配置Flutter项目了，一共需要三个值：</p><p><code>facebook_app_id</code><br><code>fb_login_protocol_scheme</code> <br><code>facebook_client_token</code> </p><p>app_id信息在 App setting &gt; basic 里面；<br>scheme是字符串拼接：fb[app_id];<br>client_token 在 App setting &gt; advanced &gt; security里面；</p><p>修改文件：<br>在<code>/android/app/src/main/res/values/strings.xml</code>文件中添加三个参数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">&lt;string name=<span class="hljs-string">&quot;facebook_app_id&quot;</span>&gt;1234&lt;/string&gt;<br>&lt;string name=<span class="hljs-string">&quot;fb_login_protocol_scheme&quot;</span>&gt;fb1234&lt;/string&gt;<br>&lt;string name=<span class="hljs-string">&quot;facebook_client_token&quot;</span>&gt;56789&lt;/string&gt;<br></code></pre></td></tr></table></figure><p>在<code>/android/app/src/main/AndroidManifest.xml</code>文件中增加两个meta-data和一个权限：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">&lt;application android:label=<span class="hljs-string">&quot;@string/app_name&quot;</span> ...&gt;<br>    ...<br>   &lt;meta-data android:name=<span class="hljs-string">&quot;com.facebook.sdk.ApplicationId&quot;</span> android:value=<span class="hljs-string">&quot;@string/facebook_app_id&quot;</span>/&gt;<br>   &lt;meta-data android:name=<span class="hljs-string">&quot;com.facebook.sdk.ClientToken&quot;</span> android:value=<span class="hljs-string">&quot;@string/facebook_client_token&quot;</span>/&gt;<br>    ...<br>&lt;/application&gt;<br><br>&lt;uses-permission android:name=<span class="hljs-string">&quot;android.permission.INTERNET&quot;</span>/&gt;<br></code></pre></td></tr></table></figure><p>额滴个神啊，终于把Android配置完了。</p><h4 id="配置IOS："><a href="#配置IOS：" class="headerlink" title="配置IOS："></a>配置IOS：</h4><p>ios简单多了，第二步配置Bundle ID：<br><img src="/image/article/flutter/flutter-facebookAuth/7.png"></p><p>第四步配置Info.plist文件我就不写了，参数就还是那几个，注意别写错位置了，另外有些部分和googleSignin的配置有重叠，小心点就行了，配置完这个，ios端就行了。</p><p>最后添加一个测试账号：<br><img src="/image/article/flutter/flutter-facebookAuth/8.png"></p><h3 id="3-使用插件"><a href="#3-使用插件" class="headerlink" title="3. 使用插件"></a>3. 使用插件</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">void</span> facebookLogin() <span class="hljs-keyword">async</span> &#123;<br>    <span class="hljs-keyword">final</span> LoginResult result = <span class="hljs-keyword">await</span> FacebookAuth.instance.login();<br>    <span class="hljs-keyword">if</span> (result.status == LoginStatus.success) &#123;<br>      <span class="hljs-keyword">final</span> AccessToken accessToken = result.accessToken!;<br>      <span class="hljs-built_in">print</span>(accessToken);<br>      <span class="hljs-built_in">print</span>(result);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-built_in">print</span>(result.status);<br>      <span class="hljs-built_in">print</span>(result.message);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-遇到的问题"><a href="#4-遇到的问题" class="headerlink" title="4. 遇到的问题"></a>4. 遇到的问题</h3><p>账号问题：</p><p>2023-09-21搞了一天也没好，最后发现是这个facebook账号被禁用了广告功能，不能创建商业账号，而使用用户email这些数据是需要验证商业账号的，之前为什么不用验证呢，因为新政策是刚出的20231027之后针对新注册app生效的新政策，靠！这里是<a href="https://developers.facebook.com/docs/permissions">新政策公告</a><br><img src="/image/article/flutter/flutter-facebookAuth/9.png"><br><img src="/image/article/flutter/flutter-facebookAuth/10.png"></p><p>我进行公司信息验证之后，状态就变了，现在还在审核中，公司审核需要提供公司的营业执照或者税务什么的文件，还需要有一个当地的电话号码（暂时不需要验证码）<br><img src="/image/article/flutter/flutter-facebookAuth/11.png"></p><p>按照最新的政策，必须公司验证通过，才能正常使用登录功能！！！</p><p>几天之后，公司验证没通过！还需要追加提供企业最近的水电缴费单或者税务账单以证明公司实际办公地址的真实性，这个我们提供不了，哦吼，完犊子，只能不用facebook auth了。</p>]]></content>
    
    
    <categories>
      
      <category>Flutter</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Flutter</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Flutter Google Sign_In</title>
    <link href="/2023/09/20/flutter/flutter-googleSignIn/"/>
    <url>/2023/09/20/flutter/flutter-googleSignIn/</url>
    
    <content type="html"><![CDATA[<p>使用插件：<a href="https://pub-web.flutter-io.cn/packages/google_sign_in">google_sign_in</a></p><p>这个插件是基于firebase的，firebase是google旗下提供给移动应用和web平台使用的开放平台；</p><h3 id="1-注册firebase账号"><a href="#1-注册firebase账号" class="headerlink" title="1. 注册firebase账号"></a>1. 注册firebase账号</h3><p>google登录嘛，你得先有个google账号才能去注册firebase;<br><a href="https://console.firebase.google.com/?hl=zh-cn&_gl=1*nyz7us*_ga*NTgwMTcyNzQuMTcyNTE3NTA2Mw..*_ga_CW55HF8NVT*MTczMzg5NzgyMy4yLjEuMTczMzg5ODA3Ny41MC4wLjA.">FireBase控制台</a></p><h3 id="2-创建项目和应用，在项目下创建android和ios应用"><a href="#2-创建项目和应用，在项目下创建android和ios应用" class="headerlink" title="2. 创建项目和应用，在项目下创建android和ios应用"></a>2. 创建项目和应用，在项目下创建android和ios应用</h3><p>创建一个项目</p><p><img src="/image/article/flutter/flutter-googleSignIn/1.png"></p><p>在项目下新建android和ios应用</p><p><img src="/image/article/flutter/flutter-googleSignIn/2.png"></p><h4 id="2-1-创建Android项目："><a href="#2-1-创建Android项目：" class="headerlink" title="2.1 创建Android项目："></a>2.1 创建Android项目：</h4><p><img src="/image/article/flutter/flutter-googleSignIn/3.png"></p><p>第一步写完之后其实就结束了，后面直接下一步下一步完成就行了(SHA-1签名肯定是要填的，不过现在不填，晚点填也可以)。第二步要你下载google-services.json文件放在项目中，如果只是用google登录这个插件，那么其实是不需要的，除非你用到了其他google服务。<br>(我在使用google message推送的时候是需要这个文件的，但是是根据配置它自动下载的，位置在android&#x2F;app&#x2F;google-services.json)</p><p>点击完成之后，设置Android项目：</p><p><img src="/image/article/flutter/flutter-googleSignIn/4.png"></p><p>上图所示页面需要添加指纹，就是SHA-1秘钥，debug和release的都需要填写，发布google play商店的时候，我用的是google play自带的签名，所有需要把这个签名也加进来；</p><p>值得注意的一点是，如果你没有自己生成z证书签名，androdi stduio会使用自己的默认debug签名证书，mac的文件位置：.android&#x2F;debug.keystore；</p><p>生成证书参考：<a href="https://bestkele.com/2019/12/20/flutter/flutter-android-jks">flutter android 打包自定义jks</a><br>获取签名SHA-1的方法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">keytool -list -v -keystore  &lt;jks路径&gt;<br></code></pre></td></tr></table></figure><h4 id="2-2-创建ios项目："><a href="#2-2-创建ios项目：" class="headerlink" title="2.2 创建ios项目："></a>2.2 创建ios项目：</h4><p><img src="/image/article/flutter/flutter-googleSignIn/5.png"></p><p>这里的第二步需要下载一个GoogleService-Info.plist文件，这个文件需要放在ios&#x2F;Runner这个目录下，其他的就没什么了；</p><h3 id="3-配置OAuth屏幕的凭据和OAuth权限请求页面"><a href="#3-配置OAuth屏幕的凭据和OAuth权限请求页面" class="headerlink" title="3. 配置OAuth屏幕的凭据和OAuth权限请求页面"></a>3. 配置OAuth屏幕的凭据和OAuth权限请求页面</h3><p><a href="https://console.cloud.google.com/apis/credentials">OAuth屏幕</a></p><p><img src="/image/article/flutter/flutter-googleSignIn/6.png"></p><p>在左上角切换你刚才在firebase里面新建的项目，如果找不到，试试看看[全部]选项；</p><p>然后点击左侧菜单 OAuth权限请求页面，配置你的项目信息；</p><p>如果你一切顺利，这时候在凭据菜单内会有三个OAuth2.0 客户端ID，那么就没什么问题了；</p><p>在这里我遇到一个奇怪的错误，等会在下面再说；</p><h3 id="4-使用"><a href="#4-使用" class="headerlink" title="4. 使用"></a>4. 使用</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:google_sign_in/google_sign_in.dart&#x27;</span>;<br><br><span class="hljs-comment">//google登录</span><br><span class="hljs-keyword">final</span> GoogleSignIn googleSignIn = GoogleSignIn(scopes: [<span class="hljs-string">&#x27;email&#x27;</span>]);<br><br><span class="hljs-keyword">void</span> googleLogin() <span class="hljs-keyword">async</span> &#123;<br>    GoogleSignInAccount? googleResult = <span class="hljs-keyword">await</span> googleSignIn.signIn();<br>    <span class="hljs-built_in">print</span>(googleResult);<br>&#125;<br></code></pre></td></tr></table></figure><p>使用时有个注意的地方，google账号会保持登录状态一段时间，如果我们想每次点击登录按钮都提示登录。那么就需要退出登录状态，达到切换账号的目的：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs dart">googleSignIn.isSignedIn().then((value) <span class="hljs-keyword">async</span>&#123;<br>    <span class="hljs-built_in">print</span>(value);<br>    <span class="hljs-comment">// 如果不退出，那已登录状态会保持一段时间，就不能达到切换账号的目的了</span><br>    <span class="hljs-keyword">if</span>(value == <span class="hljs-keyword">true</span>)&#123;<br>    <span class="hljs-keyword">await</span> googleSignIn.signOut();<br>    &#125;<br>    GoogleSignInAccount? googleResult = <span class="hljs-keyword">await</span> googleSignIn.signIn();<br>    <span class="hljs-built_in">print</span>(googleResult);<br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="5-遇到的问题"><a href="#5-遇到的问题" class="headerlink" title="5. 遇到的问题"></a>5. 遇到的问题</h3><p>很快啊，ios嗖的一下就好了；<br>android遇到了问题，报错信息如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">[ERROR:flutter/runtime/dart_vm_initializer.cc(41)] <br>Unhandled Exception: PlatformException(sign_in_failed, <br>com.google.android.gms.common.api.ApiException: 10: , null, null)<br></code></pre></td></tr></table></figure><p>靠，这个问题高了好几个小时，按照stackoverflow的回答，我也一直以为这个是SHA-1签名的问题，我删除证书，重新新建，删除SHA-1，重新设置，但是问题依然存在，在此期间我升级了开发工具，清除android缓存,flutter缓存，添加了sha1和sha256两种秘钥，折腾死了也没好。</p><p>然后在github搜啊搜，看到这个问题：<a href="https://github.com/flutter/flutter/issues/33393">ISSUE #33393</a></p><p>Issue中提示填写好<a href="https://console.cloud.google.com/apis/credentials">OAuth屏幕</a>的所有必填信息，我填过了啊，其实这个Issue和我遇到的问题不太一样，但是据此我得出结论，问题就出在OAuth这一块的设置上。</p><p><img src="/image/article/flutter/flutter-googleSignIn/7.png"></p><p>图上的android是我自己手动加上去的，为什么ios和web是自动加上去的，android却没有呢，在我手动加上去之后，google 登录就好了，我草！！！</p><p>然后我把firebase项目里面android应用所有的SHA 证书指纹全部删除了，还是能登录，不应该啊，但是确实是可以，太奇怪了，哎！保险起见，我还是把debug和release签名的两个SHA-1加进去了，保险点吧，毕竟后面用其他第三方服务也是需要的。</p><p>后来我新建应用的时候，增加sha1, OAuth2.0客户端id是自动增加上去的，加几个SHA-1就会自动新增几个OAuth2.0客户端id，看来是这只是个偶然的bug，希望你们不会遇到；</p>]]></content>
    
    
    <categories>
      
      <category>Flutter</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Flutter</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>俄罗斯地铁线路图双语版</title>
    <link href="/2023/08/02/other/subway/"/>
    <url>/2023/08/02/other/subway/</url>
    
    <content type="html"><![CDATA[<h3 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h3><img src="/image/article/other/subway/zh.png" width="100%"/><h3 id="俄文版"><a href="#俄文版" class="headerlink" title="俄文版"></a>俄文版</h3><img src="/image/article/other/subway/ru.jpeg" width="100%"/><p>最近在看一部小说，俄罗斯的地铁三部曲，刚开始看第一本《地铁2033》，里面的地铁站名太多了，记不住，如果知道地铁站的方位会有助于理解内容，在这里记录一下</p><p>参考链接：<br><a href="http://ru.eyuzhijia.com/143.html?_=1535369883659">http://ru.eyuzhijia.com/143.html?_=1535369883659</a></p>]]></content>
    
    
    <categories>
      
      <category>随手记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数学表达式解析</title>
    <link href="/2023/07/26/investigation/expression/"/>
    <url>/2023/07/26/investigation/expression/</url>
    
    <content type="html"><![CDATA[<h1 id="数学表达式解析"><a href="#数学表达式解析" class="headerlink" title="数学表达式解析"></a>数学表达式解析</h1><p>要做一个解析字符串表达式的东西，解析之后给前端或者后端函数计算用；</p><p>要求能解析基本的加减乘除数学表达式，并且支持自定义函数；</p><ol><li><p>先看java的：</p><p> 1、exp4j</p><p> 官网：<a href="https://www.objecthunter.net/exp4j/#Custom_functions">https://www.objecthunter.net/exp4j/#Custom_functions</a><br> 最后一版是2017-01-30，属实挺老的<br> 参考链接，下面有内置函数列表，竟然没有sum：<br> <a href="https://ibit.tech/archives/exp4j-introduction">https://ibit.tech/archives/exp4j-introduction</a><br> 这里有个坑爹的地方，这个Function必须是exp4j的格式，它要求必须定义参数个数，<br> 那么我想实现一个可变参数的sum就不行了<br> 除了这个问题，其他都是满足要求的</p><p> 2、JEP</p><p> 最新版本是2021-04-06<br> 官网：<a href="https://www.singularsys.com/jep/doc/html/usage.html#gettingstarted">https://www.singularsys.com/jep/doc/html/usage.html#gettingstarted</a></p><p> 看了下例子，语法有点难受，不用</p><p> 3、ibit-exp4j</p><p> 地址：<a href="https://github.com/ibit-tech/ibit-exp4j">https://github.com/ibit-tech/ibit-exp4j</a></p><p> 他是在exp4j基础上封装了一版，简化参数，我一看，比不封装还难用呢</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//矮子里面拔高个，选exp4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">Function</span> <span class="hljs-variable">sumFn</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Funct</span>、ion(<span class="hljs-string">&quot;sum&quot;</span>,<span class="hljs-number">3</span>) &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">apply</span><span class="hljs-params">(<span class="hljs-type">double</span>... args)</span> &#123;<br>            <span class="hljs-type">double</span> <span class="hljs-variable">sumResult</span> <span class="hljs-operator">=</span> <span class="hljs-number">0.0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">double</span> number : args) &#123;<br>                sumResult += number;<br>            &#125;<br>            <span class="hljs-keyword">return</span> sumResult;<br>        &#125;<br>    &#125;;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Expression</span> <span class="hljs-variable">expression</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ExpressionBuilder</span>(<span class="hljs-string">&quot;2 * sum(2,sum(4,5,1),2) - x&quot;</span>)<br>                .function(sumFn)<br>                .variables(<span class="hljs-string">&quot;x&quot;</span>)<br>                .build()<br>                .setVariable(<span class="hljs-string">&quot;x&quot;</span>, <span class="hljs-number">2</span>);<br><br>        <span class="hljs-type">double</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> expression.evaluate();<br>        System.out.println(<span class="hljs-string">&quot;Result: &quot;</span> + result); <span class="hljs-comment">//26</span><br>    &#125;<br></code></pre></td></tr></table></figure></li><li><p>python的</p><p> python有个内置的函数eval可以解析表达式</p><p> global_vars和local_vars是定义全局和局部变量的参数，视具体情况而定，一般情况下不写这两个参数就是默认使用全局的自定义函数</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 定义两个函数</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">x, y</span>):<br>    <span class="hljs-keyword">return</span> x + y<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">sub</span>(<span class="hljs-params">x, y</span>):<br>    <span class="hljs-keyword">return</span> x - y<br><span class="hljs-comment"># 全局命名空间，</span><br>global_vars = &#123;<span class="hljs-string">&#x27;add&#x27;</span>: add, <span class="hljs-string">&#x27;sub&#x27;</span>: sub&#125;<br><span class="hljs-comment"># 局部命名空间</span><br>local_vars = &#123;<span class="hljs-string">&#x27;x&#x27;</span>: <span class="hljs-number">3</span>, <span class="hljs-string">&#x27;y&#x27;</span>: <span class="hljs-number">4</span>&#125;<br><span class="hljs-comment"># 要执行的表达式</span><br>expression = <span class="hljs-string">&quot;sub(5, 4) + add(x, y)*2&quot;</span><br><span class="hljs-comment"># 执行表达式，返回结果</span><br>result = <span class="hljs-built_in">eval</span>(expression, global_vars, local_vars)<br><span class="hljs-built_in">print</span>(result)  <span class="hljs-comment"># 输出 15</span><br></code></pre></td></tr></table></figure></li><li><p>javascript</p><p> 搜了一会看到一个js的表达式解析，牛逼的math.js：</p><p> 官网：<a href="https://mathjs.org/docs/expressions/parsing.html">https://mathjs.org/docs/expressions/parsing.html</a></p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// create a parser</span><br><span class="hljs-keyword">const</span> parser = math.<span class="hljs-title function_">parser</span>()<br><br><span class="hljs-comment">// evaluate expressions</span><br>parser.evaluate(<span class="hljs-string">&#x27;sqrt(3^2 + 4^2)&#x27;</span>)      <span class="hljs-comment">// 5</span><br>parser.evaluate(<span class="hljs-string">&#x27;sqrt(-4)&#x27;</span>)             <span class="hljs-comment">// 2i</span><br>parser.evaluate(<span class="hljs-string">&#x27;2 inch to cm&#x27;</span>)         <span class="hljs-comment">// 5.08 cm</span><br>parser.evaluate(<span class="hljs-string">&#x27;cos(45 deg)&#x27;</span>)          <span class="hljs-comment">// 0.7071067811865476</span><br><br><span class="hljs-comment">// define variables and functions</span><br>parser.evaluate(<span class="hljs-string">&#x27;x = 7 / 2&#x27;</span>)            <span class="hljs-comment">// 3.5</span><br>parser.evaluate(<span class="hljs-string">&#x27;x + 3&#x27;</span>)                <span class="hljs-comment">// 6.5</span><br>parser.evaluate(<span class="hljs-string">&#x27;f(x, y) = x^y&#x27;</span>)        <span class="hljs-comment">// f(x, y)</span><br>parser.evaluate(<span class="hljs-string">&#x27;f(2, 3)&#x27;</span>)              <span class="hljs-comment">// 8</span><br><br><span class="hljs-comment">// get and set variables and functions</span><br><span class="hljs-keyword">const</span> x = parser.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;x&#x27;</span>)               <span class="hljs-comment">// x = 3.5</span><br><span class="hljs-keyword">const</span> f = parser.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;f&#x27;</span>)               <span class="hljs-comment">// function</span><br><span class="hljs-keyword">const</span> g = <span class="hljs-title function_">f</span>(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>)                       <span class="hljs-comment">// g = 27</span><br>parser.<span class="hljs-title function_">set</span>(<span class="hljs-string">&#x27;h&#x27;</span>, <span class="hljs-number">500</span>)<br>parser.evaluate(<span class="hljs-string">&#x27;h / 2&#x27;</span>)                <span class="hljs-comment">// 250</span><br>parser.<span class="hljs-title function_">set</span>(<span class="hljs-string">&#x27;hello&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">name</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;hello, &#x27;</span> + name + <span class="hljs-string">&#x27;!&#x27;</span><br>&#125;)<br>parser.evaluate(<span class="hljs-string">&#x27;hello(&quot;user&quot;)&#x27;</span>)        <span class="hljs-comment">// &quot;hello, user!&quot;</span><br><br><span class="hljs-comment">// clear defined functions and variables</span><br>parser.<span class="hljs-title function_">clear</span>()<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>技术调研</category>
      
    </categories>
    
    
    <tags>
      
      <tag>javascript</tag>
      
      <tag>python</tag>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>消息中间件</title>
    <link href="/2023/02/02/concept/message-middleware/"/>
    <url>/2023/02/02/concept/message-middleware/</url>
    
    <content type="html"><![CDATA[<h1 id="消息中间件"><a href="#消息中间件" class="headerlink" title="消息中间件"></a>消息中间件</h1><p>Kafka：zookeeper是kafaka的集群管理工具</p><p>优点：</p><ul><li>百万级别的吞吐量</li><li>客户端语言支持很丰富</li><li>在日志管理领域很成熟</li></ul><p>缺点：</p><ul><li>消息是无序的</li><li>队列消息有失败的概率（有其他方式避免）</li><li>不支持延迟队列</li></ul><p>RocketMQ：</p><p>    很好用，万单位的吞吐量，比kafaka轻量级（kafaka的cpu消耗高），消息准确率也高， 高性能、满足可靠性、分布式事物、支持水平扩展、上亿级别的消息堆积、主从之间的切换等等。MQ的所有优点它基本都满足。但是它最大的缺点：商业版收费。因此它有许多功能是不对外提供的</p><p>RabbitMQ：</p><p>    很好用，和RocketMQ差不多，免费，消息不会丢失，不支持消息回溯</p><p>kafaka主要用于大数据量的处理，性能很高，针对日志领域设计的，对消息小概率丢失可忽略不计的业务场景，会有延迟；</p><p>rabbitMQ主要适合消息准确率和实时性要求高，轻量级的场景。</p><p>参考链接：<br><a href="https://blog.csdn.net/qq_44836294/article/details/108048637">https://blog.csdn.net/qq_44836294&#x2F;article&#x2F;details&#x2F;108048637</a></p>]]></content>
    
    
    <categories>
      
      <category>概念知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基于docker和mysql配置waline评论系统</title>
    <link href="/2022/10/07/other/waline/"/>
    <url>/2022/10/07/other/waline/</url>
    
    <content type="html"><![CDATA[<h3 id="一、waline介绍"><a href="#一、waline介绍" class="headerlink" title="一、waline介绍"></a>一、waline介绍</h3><p>在waline之前有一款评论系统叫做valine，valine 是一款样式精美，操作简单，部署高效的评论系统。它不含服务端，前端直接和 LeanCloud 存储服务交互，非常棒！但是valine它存在着一些问题：</p><p>源码不开放：在1.4.0版本之后，作者不再推送源代码；</p><p>XSS安全问题：评论的数据存在XSS安全问题，因为没有服务端，所以前端搞定XSS问题是治标不治本的；</p><p>隐私泄露：评论数据会泄露ip和邮箱；</p><p>统计数据篡改：可以通过开放接口修改统计数据；</p><p>在此基础上，waline就出现了，它包含完整的前端和服务端，解决了上面valine的问题，同时还有垃圾评论过滤和邮件通知等等新功能。</p><h3 id="二、docker部署"><a href="#二、docker部署" class="headerlink" title="二、docker部署"></a>二、docker部署</h3><p>安装docker，mysql过程省略；</p><h4 id="1、初始化表结构"><a href="#1、初始化表结构" class="headerlink" title="1、初始化表结构"></a>1、初始化表结构</h4><p>手动创建一个数据库waline_comment(名称随意)，然后下载<a href="https://github.com/walinejs/waline/blob/main/assets/waline.sql">waline.sql文件</a>，运行这个文件；</p><p>注意事项：因为 waline 使用了比较老的 mysql 密码认证方式，导致使用 mysql8 的时候，出现无法认证和无法创建用户的错误。mysql8的加密方式需要修改，或者新建个用户使用老的加密方式，大概是这样的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 新建一个waline用户，修改加密方式，当然你也可以直接使用root</span><br>CREATE USER <span class="hljs-string">&#x27;waline&#x27;</span>@<span class="hljs-string">&#x27;%&#x27;</span> IDENTIFIED WITH mysql_native_password BY <span class="hljs-string">&#x27;your_password&#x27;</span>;<br><span class="hljs-comment"># 只授权这一个数据库</span><br>GRANT ALL PRIVILEGES ON waline_comment.* TO <span class="hljs-string">&#x27;waline&#x27;</span>;<br><span class="hljs-comment"># 刷新权限</span><br>flush privileges;<br></code></pre></td></tr></table></figure><h4 id="2、部署waline"><a href="#2、部署waline" class="headerlink" title="2、部署waline"></a>2、部署waline</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 拉取镜像</span><br>docker pull lizheming/waline:latest<br><span class="hljs-comment"># 创建容器</span><br>docker run -d --name waline -p 8360:8360 \<br>  -v /mydocker/waline/data:/app/data \<br>  -e TZ=<span class="hljs-string">&quot;Asia/Shanghai&quot;</span> \<br>  -e MYSQL_HOST=<span class="hljs-string">&quot;公网IP&quot;</span> \<br>  -e MYSQL_DB=<span class="hljs-string">&quot;waline_comment&quot;</span> \<br>  -e MYSQL_USER=<span class="hljs-string">&quot;waline&quot;</span> \<br>  -e MYSQL_PASSWORD=<span class="hljs-string">&quot;数据库密码&quot;</span> \<br>  -e AUTHOR_EMAIL=<span class="hljs-string">&quot;作者邮箱&quot;</span> \<br>  -e SITE_NAME=<span class="hljs-string">&quot;kele blog&quot;</span> \<br>  -e SENDER_NAME=<span class="hljs-string">&quot;博客留言&quot;</span> \<br>  -e SMTP_SERVICE=<span class="hljs-string">&quot;QQ&quot;</span> \ <span class="hljs-comment">#有很多可选的服务商，这是配置评论通知的</span><br>  -e SMTP_USER=<span class="hljs-string">&quot;您的邮箱&quot;</span> \<br>  -e SMTP_PASS=<span class="hljs-string">&quot;授权码&quot;</span> \<br>  -e DISABLE_USERAGENT=<span class="hljs-string">&quot;false&quot;</span> \ <span class="hljs-comment">#是否开启浏览器标识</span><br>  -e AVATAR_PROXY=<span class="hljs-string">&quot;https://avatar.75cdn.workers.dev&quot;</span> \ <span class="hljs-comment">#头像加速镜像地址</span><br>  -e IPQPS=<span class="hljs-string">&quot;30&quot;</span> \ <span class="hljs-comment">#ip发言频率</span><br>  --restart always \<br>  lizheming/waline:latest<br></code></pre></td></tr></table></figure><p>mysql 的参数参考这里：<br><img src="/image/article/other/waline/mysql.png" width="100%"/><br>部署完成之后，访问<a href="http://ip地址:8360/ui/register">http://ip地址:8360/ui/register</a> 地址，便能看到注册界面<br><img src="/image/article/other/waline/register.png" width="100%"/></p><h4 id="3、hexo博客fluid主题接入waline评论系统"><a href="#3、hexo博客fluid主题接入waline评论系统" class="headerlink" title="3、hexo博客fluid主题接入waline评论系统"></a>3、hexo博客fluid主题接入waline评论系统</h4><p>修改配置文件 _config.fluid.yml</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 文章页面</span><br>post:<br>  banner_img_height: 60<br>  updated:<br>    <span class="hljs-built_in">enable</span>: <span class="hljs-literal">true</span><br>  meta:<br>    views:  <span class="hljs-comment"># 阅读次数</span><br>        <span class="hljs-built_in">enable</span>: <span class="hljs-literal">true</span><br>        <span class="hljs-built_in">source</span>: <span class="hljs-string">&quot;busuanzi&quot;</span>  <span class="hljs-comment"># 统计数据来源，可选：leancloud | busuanzi   注意不蒜子会间歇抽风</span><br>        format: <span class="hljs-string">&quot;&#123;&#125; 次&quot;</span><br>  <span class="hljs-comment"># 开启评论</span><br>  comments:<br>    <span class="hljs-built_in">enable</span>: <span class="hljs-literal">true</span><br>    <span class="hljs-built_in">type</span>: waline<br><span class="hljs-comment"># waline参数</span><br>waline:<br>  serverURL: <span class="hljs-string">&#x27;你的评论系统网址&#x27;</span><br>  path: window.location.pathname<br>  meta: [<span class="hljs-string">&#x27;nick&#x27;</span>, <span class="hljs-string">&#x27;mail&#x27;</span>, <span class="hljs-string">&#x27;link&#x27;</span>]<br>  requiredMeta: []<br>  lang: <span class="hljs-string">&#x27;zh-CN&#x27;</span><br>  emoji: [<span class="hljs-string">&#x27;https://cdn.jsdelivr.net/gh/walinejs/emojis/weibo&#x27;</span>]<br>  wordLimit: 0<br>  pageSize: 10<br>  <span class="hljs-comment"># 开启点赞</span><br>  reaction: <span class="hljs-literal">true</span><br>  locale: &#123;placeholder: 留下只言片语&#125;<br></code></pre></td></tr></table></figure><p>效果图：<br><img src="/image/article/other/waline/preview.png" width="100%"/></p><h3 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h3><p><a href="https://waline.js.org/guide/get-started/client.html">waline官方文档</a></p><p><a href="https://www.zdynb.cn/2022/shi-yong-docker-bu-shu-waline.html">其他文章</a></p>]]></content>
    
    
    <categories>
      
      <category>随手记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>git仓库迁移</title>
    <link href="/2022/09/07/investigation/git-move/"/>
    <url>/2022/09/07/investigation/git-move/</url>
    
    <content type="html"><![CDATA[<h1 id="git仓库迁移"><a href="#git仓库迁移" class="headerlink" title="git仓库迁移"></a>git仓库迁移</h1><hr><p>今天学到个新知识，仓库迁移的，遇到一个问题是希望把gitee上面的代码迁移到内网的gitlab上，当然是包括所有的历史记录和分支，tag等等；</p><p>主要用法是这样：</p><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs dsconfig"><span class="hljs-string">1</span>、克隆远程仓库镜像到本地<br><span class="hljs-string">git</span> <span class="hljs-string">clone</span> <span class="hljs-built_in">--mirror</span> 仓库地址<br><span class="hljs-string">2</span>、切换至文件夹<br><span class="hljs-string">cd</span> <span class="hljs-string">dir</span><br><span class="hljs-string">3</span>、设置<span class="hljs-string">remote</span><br><span class="hljs-string">git</span> <span class="hljs-string">remote</span> <span class="hljs-built_in">set-url</span> <span class="hljs-string">origin</span> 新代码仓库地址<br><span class="hljs-string">4</span>、推送镜像到新仓库<br><span class="hljs-string">git</span> <span class="hljs-string">push</span> –-<span class="hljs-string">mirror</span><br></code></pre></td></tr></table></figure><p>注意事项：</p><p>一、第一步拉原始仓库镜像，保险起见，最好是找个新文件夹操作，不要影响以前的本地仓库；</p><p>我想既然可以拉ssh和http，是不是本地也可以，果然！！</p><p>我是这么写的，拉的本地文件夹：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">git clone --mirror D:<span class="hljs-regexp">/workspace/</span>java<span class="hljs-regexp">/backend2/</span>.git<br></code></pre></td></tr></table></figure><p>这里涉及另一个知识点，clone有三种方式 ：</p><p>举个具体的例子：gitlab远程仓库有master，a，b三个分支；</p><p>D盘的本地仓库有，master，a，两个本地分支，一个remote的b分支，当前在a分支</p><p><strong>1、git  clone  url</strong></p><p>这是我们最常用的方法，</p><p><em>clone远程仓库会有一个master本地分支，a，b两个remote关联远程分支；</em></p><p><em>clone本地仓库会有一个本地当前分支a，master，b两个remote关联远程分支</em></p><p><strong>2、git clone –bare url</strong></p><p>称为裸仓库克隆；</p><p>clone远程仓库会有一个master，a，b三个本地分支；</p><p>clone本地仓库会有master，a两个本地分支，b丢失；</p><p><strong>3、git clone –mirror url</strong></p><p>称为镜像仓库克隆</p><p>clone远程仓库会有一个master，a，b三个本地分支；</p><p>clone本地仓库会有master，a两个本地分支，一个remote的b分支；</p><p>所以说mirror是最完美的复刻</p><p>二、设置remote</p><p>这一步git remote set-url  —push origin url；</p><p>其中—push 是设置推送的远程地址，还可以设置—fetch的地址，如果两个一致，那就直接：<br>git remote set-url origin url 就行了。</p><p>设置不同的地址之后是这样：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">$ git remote -v<br>origin  D:<span class="hljs-regexp">/workspace/</span>java<span class="hljs-regexp">/backend2/</span>.git (fetch)<br>origin  ssh:<span class="hljs-regexp">//gi</span>t@<span class="hljs-number">192.168</span>.<span class="hljs-number">1.100</span>:<span class="hljs-number">20222</span><span class="hljs-regexp">/backenddevelopergroup/</span>xiao.git  (push)<br></code></pre></td></tr></table></figure><p>三、推送镜像到gitlab上一个新的空仓库</p><p>用新仓库，不然的话，如果是已存在分支的仓库，他会删除你已存在的分支，再推送自己的分支；</p><p>这里我又遇到一个报错：deny updating hidden ref</p><p>原因是我拉的是本地仓库，会有一些本地分支和remote的远程分支，本地分支能推上去，而这些远程关联的分支称为hidden ref，</p><p>它是不允许推到仓库的，这一点我没搞明白，不知道是gitlab设置的原因还是什么；</p><p>我的做法是在本地手动checkout 一下这些hidden ref，相当于把他们都变成了本地分支，然后就能推上去了，over！</p><p>参考链接：</p><p><a href="https://blog.csdn.net/shouhuzhezhishen/article/details/126012426">https://blog.csdn.net/shouhuzhezhishen/article/details/126012426</a></p>]]></content>
    
    
    <categories>
      
      <category>技术调研</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>flutter1.22的echart在鸿蒙OS上的一些兼容性bug</title>
    <link href="/2022/03/30/flutter/harmony-echart/"/>
    <url>/2022/03/30/flutter/harmony-echart/</url>
    
    <content type="html"><![CDATA[<p>Flutter应用在其他Android机器都是好的，但是鸿蒙系统不能正确显示图表，解决了显示问题之后，切换数据也不刷新，真烦人啊，上网搜了一大圈，低版本的Android也会出现这个问题，所以导致这个问题的底层原因是鸿蒙是低版本Android??</p><p>一、华为鸿蒙系统不能显示图表</p><p>1、相显示图表必须使用webview的混合显示模式</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">if</span> (<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Platform</span>.</span></span>isAndroid) <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">WebView</span>.</span></span>platform = <span class="hljs-constructor">SurfaceAndroidWebView()</span>;<br></code></pre></td></tr></table></figure><p>在 initState，update，dispose 三个地方注意一下</p><p>2、网页的宽高问题</p><p>此时渲染出来的图表宽高是0，我也不想深究原因了，直接加了200ms延迟，这样他就获取到了Flutter元素控件的宽高，或者写死固定宽高当然也可以。</p><p>上述修改主要增加了混合模式和一个初始化图表延迟200毫秒，显示图表没问题</p><p>二、图表update不生效</p><p>1、update改写，直接reload，这样就可以了，按钮切换图表刷新正常；</p><p>2、不过当页面不在正前方时，图表的update依然不生效，—华为鸿蒙有问题，其他是好的</p><p>3、把chart的div设置固定宽高是可以的，通过js设置宽高可行吗？</p><p>不行，混合渲染是图表会在上层，初始的宽高会生效，但是再设置就不生效了，小米，鸿蒙都不行，舍弃</p>]]></content>
    
    
    <categories>
      
      <category>Flutter</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>Flutter</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ios callkit</title>
    <link href="/2022/03/29/investigation/ios-callkit/"/>
    <url>/2022/03/29/investigation/ios-callkit/</url>
    
    <content type="html"><![CDATA[<h1 id="ios-callkit"><a href="#ios-callkit" class="headerlink" title="ios callkit"></a>ios callkit</h1><p>一、基本概念</p><p>        CallKit是iOS10系统推出的一个系统级别的功能，它的主要作用是提供了一些Api供拥有语音和视频通话功能的App（VoIP功能）在使用语音和视频功能的时候能够使用系统的通话界面进行接听，同时在手机通话记录中会存在本次记录，点击记录还能够直接回拨。</p><p>        Android有个类似的功能叫做：Android ConnectionService</p><p>二、个中曲折</p><p>        CallKit功能推出后，反响很好，各大网络电话App那是相当开心，微信还出了一个版本拥有这个功能，但是好景不长，2018年，工信部就出面在大陆地区的App Store中的应用必须删除CallKit功能，一是动了三大运营商的奶酪，二是通话记录会被监听。</p><p>        上架App Store就会出现下面的提示：</p><p><img src="/image/article/investigation/ios-callkit/4a1f1b45-fe30-4589-8988-ca56099dc5b5.png"></p><p>三、其他问题</p><p>1、据说国内下载的微信登录海外账号还是可以支持CallKit的，飞书也有，可能是因为它们体量大，有特殊渠道；</p><p>2、android的实现技术实际上是一个后台常驻服务，但是现在Android管的也比较严，所以在App杀掉进程之后会不支持；</p><p>3、我暂时想到的场景就是通过CallKit实现火警客服电话的呼入和呼出，避免运营商屏蔽和备注骚扰电话的问题；</p><p>4、在自家App拥有VoIP网络电话的功能之后，使用CallKit是锦上添花的功能，否则CallKit就是不必要的。</p>]]></content>
    
    
    <categories>
      
      <category>技术调研</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ios</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GIS 各种坐标系</title>
    <link href="/2022/03/18/concept/gis/"/>
    <url>/2022/03/18/concept/gis/</url>
    
    <content type="html"><![CDATA[<p>原文地址：<a href="http://wandergis.com/coordtransform/">http://wandergis.com/coordtransform/</a></p><h3 id="coordtransform-坐标转换"><a href="#coordtransform-坐标转换" class="headerlink" title="coordtransform 坐标转换"></a>coordtransform 坐标转换</h3><p>一个提供了百度坐标（BD09）、国测局坐标（火星坐标，GCJ02）、和WGS84坐标系之间的转换的工具模块另外还提供了<a href="https://github.com/wandergis/coordTransform_py">python版本的代码</a></p><h4 id="支持node、浏览器（AMD方式和直接引用方式）"><a href="#支持node、浏览器（AMD方式和直接引用方式）" class="headerlink" title="支持node、浏览器（AMD方式和直接引用方式）"></a>支持node、浏览器（AMD方式和直接引用方式）</h4><ul><li>GitHub地址：<a href="https://github.com/wandergis/coordtransform">https://github.com/wandergis/coordtransform</a></li><li>npm地址：<a href="https://www.npmjs.com/package/coordtransform">https://www.npmjs.com/package/coordtransform</a></li><li>项目主页：<a href="http://wandergis.github.io/coordtransform/">http://wandergis.github.io/coordtransform/</a></li></ul><h4 id="为什么写这个模块"><a href="#为什么写这个模块" class="headerlink" title="为什么写这个模块"></a>为什么写这个模块</h4><p>随着移动互联网的兴起，几乎每一个app都会去收集用户位置，如果恰好你在处理与地理定位相关的代码，并且不了解地理坐标系的话，肯定要被我大天朝各种坐标系搞晕。写这个模块的目的也是因为项目中app获取的坐标是百度sdk获取的，在做webgis可视化的时候各种偏，各种坐标不对，当时的心情……</p><h3 id="当前互联网地图的坐标系现状"><a href="#当前互联网地图的坐标系现状" class="headerlink" title="当前互联网地图的坐标系现状"></a>当前互联网地图的坐标系现状</h3><h4 id="地球坐标-WGS84"><a href="#地球坐标-WGS84" class="headerlink" title="地球坐标 (WGS84)"></a>地球坐标 (WGS84)</h4><ul><li>国际标准，从 GPS 设备中取出的数据的坐标系</li><li>国际地图提供商使用的坐标系</li></ul><h4 id="火星坐标-GCJ-02-也叫国测局坐标系"><a href="#火星坐标-GCJ-02-也叫国测局坐标系" class="headerlink" title="火星坐标 (GCJ-02)也叫国测局坐标系"></a>火星坐标 (GCJ-02)也叫国测局坐标系</h4><ul><li>中国标准，从国行移动设备中定位获取的坐标数据使用这个坐标系</li><li>国家规定： 国内出版的各种地图系统（包括电子形式），必须至少采用GCJ-02对地理位置进行首次加密。</li></ul><h4 id="百度坐标-BD-09"><a href="#百度坐标-BD-09" class="headerlink" title="百度坐标 (BD-09)"></a>百度坐标 (BD-09)</h4><ul><li>百度标准，百度 SDK，百度地图，Geocoding 使用</li><li>(本来就乱了，百度又在火星坐标上来个二次加密)</li></ul><h3 id="开发过程需要注意的事"><a href="#开发过程需要注意的事" class="headerlink" title="开发过程需要注意的事"></a>开发过程需要注意的事</h3><p>1、从设备获取经纬度（GPS）坐标</p><p>如果使用的是百度sdk那么可以获得百度坐标（bd09）或者火星坐标（GCJ02),默认是bd09<br>如果使用的是ios的原生定位库，那么获得的坐标是WGS84<br>如果使用的是高德sdk,那么获取的坐标是GCJ02<br>2、互联网在线地图使用的坐标系</p><ul><li>火星坐标系：<ul><li>iOS 地图（其实是高德）</li><li>Google地图</li><li>搜搜、阿里云、高德地图</li></ul></li><li>百度坐标系：<ul><li>当然只有百度地图</li></ul></li><li>WGS84坐标系：<ul><li>国际标准，谷歌国外地图、osm地图等国外的地图一般都是这个</li></ul></li></ul><p> <strong>举个栗子</strong></p><p>笔者所在的公司app使用的是百度的sdk,需要对定位坐标做web可视化效果，百度地图提供的js api满足不了需求，选用leaflet来做可视化，这里要说到百度地图了，它使用的坐标系和切图的原点都不一致，并且其加偏还是非线性的，因此无法利用常用的加载方法去加载，放弃使用它的底图，选用了符合标准的高德底图，高德底图使用的是国测局坐标也就是GCJ02坐标系，如果简单的将app获取的经纬度叠加上去，就有可能你本来在百度大厦的位置就显示在西二旗地铁站了甚至更远，因此需要将bd09转成gcj02坐标系，这个时候这个库就有了用武之地，对点批量转换再加载到底图上，就可以让点显示在本应该出现的位置。</p><p>另外如果你拿到了一些WGS84的坐标，想加载到各种底图上就可以根据这个库在底图坐标系和你的数据坐标系之间进行转换。希望对大家有用吧。</p><h3 id="安装（install）"><a href="#安装（install）" class="headerlink" title="安装（install）"></a>安装（install）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install coordtransform<br></code></pre></td></tr></table></figure><h3 id="示例用法（Example-amp-Usage）"><a href="#示例用法（Example-amp-Usage）" class="headerlink" title="示例用法（Example&amp;Usage）"></a>示例用法（Example&amp;Usage）</h3><p>1、NodeJs用法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//国测局坐标(火星坐标,比如高德地图在用),百度坐标,wgs84坐标(谷歌国外以及绝大部分国外在线地图使用的坐标)</span><br><span class="hljs-keyword">var</span> coordtransform=<span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;coordtransform&#x27;</span>);<br><span class="hljs-comment">//百度经纬度坐标转国测局坐标</span><br><span class="hljs-keyword">var</span> bd09togcj02=coordtransform.<span class="hljs-title function_">bd09togcj02</span>(<span class="hljs-number">116.404</span>, <span class="hljs-number">39.915</span>);<br><span class="hljs-comment">//国测局坐标转百度经纬度坐标</span><br><span class="hljs-keyword">var</span> gcj02tobd09=coordtransform.<span class="hljs-title function_">gcj02tobd09</span>(<span class="hljs-number">116.404</span>, <span class="hljs-number">39.915</span>);<br><span class="hljs-comment">//wgs84转国测局坐标</span><br><span class="hljs-keyword">var</span> wgs84togcj02=coordtransform.<span class="hljs-title function_">wgs84togcj02</span>(<span class="hljs-number">116.404</span>, <span class="hljs-number">39.915</span>);<br><span class="hljs-comment">//国测局坐标转wgs84坐标</span><br><span class="hljs-keyword">var</span> gcj02towgs84=coordtransform.<span class="hljs-title function_">gcj02towgs84</span>(<span class="hljs-number">116.404</span>, <span class="hljs-number">39.915</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(bd09togcj02);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(gcj02tobd09);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(wgs84togcj02);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(gcj02towgs84);<br><span class="hljs-comment">//result</span><br><span class="hljs-comment">//bd09togcj02: [ 116.39762729119315, 39.90865673957631 ]</span><br><span class="hljs-comment">//gcj02tobd09: [ 116.41036949371029, 39.92133699351021 ]</span><br><span class="hljs-comment">//wgs84togcj02: [ 116.41024449916938, 39.91640428150164 ]</span><br><span class="hljs-comment">//gcj02towgs84: [ 116.39775550083061, 39.91359571849836 ]</span><br></code></pre></td></tr></table></figure><p>2、浏览器用法 直接引用目录内的index.js，会有一个coordtransform的全局对象暴露出来，也支持用AMD加载器加载</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>coordTransform<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>请按F12打开控制台查看结果<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;index.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">            <span class="hljs-comment">//国测局坐标(火星坐标,比如高德地图在用),百度坐标,wgs84坐标(谷歌国外以及绝大部分国外在线地图使用的坐标)</span></span><br><span class="language-javascript">            <span class="hljs-comment">//百度经纬度坐标转国测局坐标</span></span><br><span class="language-javascript">            <span class="hljs-keyword">var</span> bd09togcj02 = coordtransform.<span class="hljs-title function_">bd09togcj02</span>(<span class="hljs-number">116.404</span>, <span class="hljs-number">39.915</span>);</span><br><span class="language-javascript">            <span class="hljs-comment">//国测局坐标转百度经纬度坐标</span></span><br><span class="language-javascript">            <span class="hljs-keyword">var</span> gcj02tobd09 = coordtransform.<span class="hljs-title function_">gcj02tobd09</span>(<span class="hljs-number">116.404</span>, <span class="hljs-number">39.915</span>);</span><br><span class="language-javascript">            <span class="hljs-comment">//wgs84转国测局坐标</span></span><br><span class="language-javascript">            <span class="hljs-keyword">var</span> wgs84togcj02 = coordtransform.<span class="hljs-title function_">wgs84togcj02</span>(<span class="hljs-number">116.404</span>, <span class="hljs-number">39.915</span>);</span><br><span class="language-javascript">            <span class="hljs-comment">//国测局坐标转wgs84坐标</span></span><br><span class="language-javascript">            <span class="hljs-keyword">var</span> gcj02towgs84 = coordtransform.<span class="hljs-title function_">gcj02towgs84</span>(<span class="hljs-number">116.404</span>, <span class="hljs-number">39.915</span>);</span><br><span class="language-javascript">            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(bd09togcj02);</span><br><span class="language-javascript">            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(gcj02tobd09);</span><br><span class="language-javascript">            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(wgs84togcj02);</span><br><span class="language-javascript">            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(gcj02towgs84);</span><br><span class="language-javascript">            <span class="hljs-comment">//result</span></span><br><span class="language-javascript">            <span class="hljs-comment">//bd09togcj02: [ 116.39762729119315, 39.90865673957631 ]</span></span><br><span class="language-javascript">            <span class="hljs-comment">//gcj02tobd09: [ 116.41036949371029, 39.92133699351021 ]</span></span><br><span class="language-javascript">            <span class="hljs-comment">//wgs84togcj02: [ 116.41024449916938, 39.91640428150164 ]</span></span><br><span class="language-javascript">            <span class="hljs-comment">//gcj02towgs84: [ 116.39775550083061, 39.91359571849836 ]</span></span><br><span class="language-javascript">        </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>概念知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>javascript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一些前端项目转换工具</title>
    <link href="/2022/03/03/investigation/transition/"/>
    <url>/2022/03/03/investigation/transition/</url>
    
    <content type="html"><![CDATA[<h1 id="一些前端项目转换工具"><a href="#一些前端项目转换工具" class="headerlink" title="一些前端项目转换工具"></a>一些前端项目转换工具</h1><p><img src="/image/article/investigation/transition/c7898cf8-fbb4-47ae-9ed5-0449a7c18329.jpg"></p><p><img src="/image/article/investigation/transition/3dd4907e-a404-4193-b626-c59c09f75c9d.png"></p><p>mpvue：star 20.4k  mini program  vue</p><p>文档：<a href="http://mpvue.com/">http://mpvue.com/</a></p><p>原理：<a href="https://www.bookstack.cn/read/CS-Interview-Knowledge-Map/spilt.16.MP-mp-ch.md#%E6%A1%86%E6%9E%B6%E5%8E%9F%E7%90%86">https://www.bookstack.cn/read/CS-Interview-Knowledge-Map/spilt.16.MP-mp-ch.md#%E6%A1%86%E6%9E%B6%E5%8E%9F%E7%90%86</a></p><p>美团出品，实现使用vue语法规范书写页面，可同时转化为H5和微信小程序，新版本也支持其他平台小程序。</p><p>先说下vue的编译原理，</p><p>1、vue-loader加载vue文件解析成js文件；</p><p>2、js经过vue的vue-template-compiler处理成ast语法树（这个语法树可以在下一步生成vue的VNode，也可以是weex的组件，这就是多端实现的底层逻辑）；</p><p>3、ast经过vue的creatElement处理再结合data数据变成VNode，就是虚拟Dom，虚拟dom就可以用diff了（有些文章这一步叫做生成render function，实际上render function返回的就是vnode）；</p><p>4、vue的render方法最后会把VNode转换为实际的dom结构</p><p>mpvue干了什么呢？</p><p>1、首先它修改了vue的runtime，vue的runtime支持生成vue的结构和weex的结构，现在加上了生成小程序的结构；</p><p>2、mpvue使用自己的模板加载器 mpvue-template-compiler直接生成了ast和render function，这里的ast和render function就跟vue的有点不一样了，但是和VNode基本类似；</p><p>3、再下一步用 mpvue-template-compiler的compileToWxml生成wxml，就是小程序的模板。</p><p>这里解释了模板的转化，生命周期，data数据的转化我就不说了（我不懂啊）；</p><p>提一嘴腾讯出的wepy框架，也是vue模板生成小程序，但是语法是vue语法加上自定义的规范，学习成本高一些，也没有mpvue好用，但是他是最早的小程序框架，值得夸奖；</p><p>wepy文档：<a href="https://wepyjs.github.io/wepy-docs/2.x/#/base/intro">https://wepyjs.github.io/wepy-docs/2.x/#/base/intro</a></p><p>个人感觉：mpvue出的比较早，是个很伟大的尝试，但是也因为出的比较早，局限性就大一些，项目立项之初，它主要考虑的是微信小程序，所以内部很多逻辑是和微信绑定的，实际上只是写法上利用了vue，其他的比如路由跳转还是要用小程序的，组件库可以用小程序的，第三方ui组件库的必须支持mpvue的一些特殊要求才行，还是很有局限性的；但是主要的局限性是不能生成APP。</p><p>trao：star 30.6k   因为部门是叫做凹凸实验室，谐音和奥特曼很像。当时就决定以后有新的开源项目，就以奥特曼来命名，所以 Taro（泰罗）是第一个。</p><p>文档：<a href="https://taro-docs.jd.com/taro/docs/">https://taro-docs.jd.com/taro/docs/</a></p><p>原理介绍：<a href="https://blog.csdn.net/sinat_17775997/article/details/103391294">https://blog.csdn.net/sinat_17775997&#x2F;article&#x2F;details&#x2F;103391294</a></p><p>京东出品，最新的trao3可以使用react&#x2F;vue等框架，同时生成H5，微信京东字节小程序，RN等，尼玛，真牛逼！</p><p>1、trao支持的小程序众多，意味着内部封装继承的程度就更高，不同的客户端小程序在转换之前都必须支持统一的组件写法和api；</p><p>2、在页面组件转化逻辑上，它的本质也是上面的转化图，vue或者react编写的代码转化为ast，再根据不同的小程序端逻辑处理，生成不同端的页面代码；</p><p>3、在路由和api层面，参考对标的也是微信小程序，所以你不能用vue和react的路由；</p><p>4、taro有自己封装的组件库，是以微信小程序为标准设计的（其实我感觉广大的小程序都是依据微信小程序的理念设计的，本质上也就是h5加一部分原生的hybrid），当然api也是自己封装过的；</p><p>5、taro也支持vuex和redux，牛逼牛逼！</p><p>这里提到了一些babel的知识，挺有意思的：</p><ul><li>Babel 可以解析还没有进入 ECMAScript 规范的语法。例如装饰器这样的提案，虽然现在没有进入标准但是已经广泛使用有一段时间了；</li><li>Babel 提供插件机制解析 TypeScript、Flow、JSX这样的 JavaScript 超集，不必单独处理这些语言；</li><li>Babel 拥有庞大的生态，有非常多的文档和样例代码可供参考；除去 parser 本身，Babel 还提供各种方便的工具库可以优化、生成、调试代码…</li></ul><p>我个人的简单理解就是babel是一个function，一个转化工具，输入原始js，输出你想要的的结构化js，比如输入es6输出es5，输入jsx输出js等等，另外注意一下babel是plugin插件可以作用于webpack的各个阶段（注意和loader的区别）；</p><p>由此又引申出一个polyfill垫片，babel的作用一般是把高级js写法变成低级的，polyfill垫片顾名思义是垫平各个浏览器的差异，是个兼容性处理插件，比如ie或者firefox不支持某个方法，polyfill就增加兼容性处理。</p><p>总结：taro真是个很牛逼的框架，我只搜了几篇文章看看原理就觉得很复杂，可想而知具体转化抹平差异的工作量有多大。taro的优势是可以使用vue或者react和其他前端框架写页面，这样群众基础就扩大了，支持转化的客户端类型也很多，估计大部分使用react的玩家都会选择taro，更何况还支持RN。</p><p>uni-app：star 36.1k  uni，读 you ni，是统一的意思。</p><p><a href="https://uniapp.dcloud.io/history.html">https://uniapp.dcloud.io/history.html</a></p><p>DCloud出品(就是那个Hbuilder工具的开发组织)， 开发者使用 Vue 语法编写代码，uni-app 框架将其编译到 小程序（微信&#x2F;支付宝&#x2F;百度&#x2F;字节跳动&#x2F;QQ&#x2F;快手&#x2F;钉钉）、App（iOS&#x2F;Android）、H5等多个平台；</p><p>DCloud网站有这么一段：“ 很多人以为小程序是微信先推出的，其实，DCloud才是这个行业的开创者。”</p><p>是的，这是真的，当初DCloud刚推出流应用的时候，我还做了一个关于流应用的技术分享会，流应用更像是微信公众号，页面是H5，再加上一点原生API的加持，而微信小程序则是自己制定了一套规则和写法。我个人一直不喜欢小程序，我认为小程序本质上是Hybrid，没有什么新奇的技术，而且自定义语法规则更像是为了打造技术壁垒和生态环境，出发点就不单纯。好了，打住！</p><p>1、uni-app的原理真没找到具体的文章，个人感觉也是ast语法树的转化；</p><p>2、uni-app可以转化为android和ios app，支持两种模式，一种webview加载的hybird，另一种是weex；</p><p>3、uni-app有自己的一套页面组件，可以运行于各个平台，还有vue的组件，但是只能运行在App和H5（这是必然的）；</p><p>总结：uni-app和taro才具有可比性，taro的优势是支持react和vue语法规则，uni-app的优势我认为是webview加载模式，因为RN和Weex毕竟有平台差异，论一致性还是webview有优势，但是webview的性能比较比不上RN和Weex。总体差异倒是不大。两者都很优秀，看个人取舍吧！</p>]]></content>
    
    
    <categories>
      
      <category>技术调研</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>苹果ABM商务应用</title>
    <link href="/2022/02/16/investigation/ABM/"/>
    <url>/2022/02/16/investigation/ABM/</url>
    
    <content type="html"><![CDATA[<h1 id="苹果ABM商务应用"><a href="#苹果ABM商务应用" class="headerlink" title="苹果ABM商务应用"></a>苹果ABM商务应用</h1><p>ios应用的几种安装方式：</p><p>1、App Store：传统方式上架发布，审核严格，账号每年99美元；</p><p>2、企业版 In-house：通过二维码下载，不需要审核，账号每年299美元，目前苹果正在收紧企业版账号的申请，需要验证企业缴纳社保人数大于100人；</p><p>3、内测版 testFlight：和App Store相似，app发布为内测版，通过testFlight下载，app有效期90天。</p><p>4、超级签名：费用比较高，把用户的设备uuid获取到之后重新签名打包，只能有100台设备，所以每台设备安装的费用大概是1美元，</p><p>5、Apple Business Manager：ABM的方式就是为了解决高度相似的定制版本无法通过审核而存在的，应用无法在App Store显示，</p><p>下载方式是在 App Store点击头像使用兑换码下载应用或者扫描二维码通过iTunes Store下载应用。</p><p>App Store和ABM对比：</p><p>一、传统的App Store的开发和下载方式：</p><p>1、企业注册一个Apple Id，然后该id申请一个99美元每年的开发者账号；</p><p>2、开发者账号开发一个应用，发布商店审核，通过后显示在App Store；</p><p>3、任意客户通过 App Store下载。</p><p>二、Apple Business Manager的开发和下载方式：</p><p>1、企业注册一个Apple Id，然后该id申请一个99美元每年的开发者账号；</p><p>2、企业重新申请一个Apple Id，使用该id申请一个Apple Business Manager账号（ABM组织），该账号免费；</p><p>3、开发者账号开发一个应用，发布时选择分发给指定组织，就是第二步注册是ABM组织，商店审核，通过后显示在ABM组织内部（必须是新应用）；</p><p>4、ABM组织批量购买应用，每周最多25000份，兑换码可通过excel的方式下载；</p><p>5、用户可以在 App Store点击头像使用兑换码下载应用或者扫描二维码通过iTunes Store下载应用（第二种方式本质上也是兑换码，只是省略了手动输入，但是需要额外安装iTunes Store）。</p><p>下载地址： <a href="https://buy.itunes.apple.com/WebObjects/MZFinance.woa/wa/freeProductCodeWizard?code=4RFFN69R6L66">https://buy.itunes.apple.com/WebObjects/MZFinance.woa/wa/freeProductCodeWizard?code=4RFFN69R6L66</a> 后面的code是变化的</p><p>ABM方式的优缺点：</p><p>优点：</p><p>1、不用担心应用查重问题，审核比较快；</p><p>缺点：</p><p>1、不显示在App Store；</p><p>2、两种下载方式都不太友好，手动输入太复杂，二维码下载需要额外安装iTunes Store；</p><p>3、在App Store已安装的应用列表里显示应用详情不确定能不能看到开发者信息，但是绝对看不到ABM组织的信息（已电话咨询ABM官方客服：4006033565）；</p><p>其他小知识：</p><p>fir和蒲公英分发平台的原理：</p><p><a href="https://blog.csdn.net/u014600626/article/details/114129947">https://blog.csdn.net/u014600626/article/details/114129947</a></p><p><a href="https://www.jianshu.com/p/60d99fc36084">https://www.jianshu.com/p/60d99fc36084</a></p><p>1、上传的ipa文件必须是已经签名过的；</p><p>2、分发平台会自动生成一个plist文件，这个文件包含ipa文件和icon的下载地址，plist文件地址必须是https的；</p><p>3、必须访问plist，使用safari浏览器的itms-services协议才能触发ios系统的ipa文件安装（itms-services:&#x2F;&#x2F;&#x2F;?action&#x3D;download-manifest&amp;url&#x3D;plist的https地址）；</p><p>4、信任设备。</p><p>参考链接：</p><p><a href="https://www.jianshu.com/p/c8361a83a338">https://www.jianshu.com/p/c8361a83a338</a></p>]]></content>
    
    
    <categories>
      
      <category>技术调研</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ios</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GetX--Flutter开发框架</title>
    <link href="/2022/01/10/flutter/GetX/"/>
    <url>/2022/01/10/flutter/GetX/</url>
    
    <content type="html"><![CDATA[<h1 id="GetX"><a href="#GetX" class="headerlink" title="GetX"></a>GetX</h1><p>GetX是个Flutter开发框架，当你用原生Flutter开发一个APP，受尽折磨之后，你就能体会到这个框架的优雅了，真香！</p><p>1、路由</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">///<span class="language-markdown"> 新开页面ddd</span></span><br>Get.toNamed(<span class="hljs-string">&#x27;/ddd&#x27;</span>);<br><span class="hljs-comment">///<span class="language-markdown"> replace</span></span><br>Get.offNamed(<span class="hljs-string">&#x27;/ddd&#x27;</span>);<br><span class="hljs-comment">///<span class="language-markdown"> 返回</span></span><br>Get.back();<br><span class="hljs-comment">/// <span class="language-markdown">新开bbb，清空aaa之后的路由栈</span></span><br>Get.offNamedUntil(<span class="hljs-string">&#x27;/bbb&#x27;</span>, ModalRoute.withName(<span class="hljs-string">&#x27;/aaa&#x27;</span>));<br><span class="hljs-comment">/// <span class="language-markdown">返回bbb，清空bbb之后的路由栈</span></span><br>Get.until(ModalRoute.withName(<span class="hljs-string">&#x27;/bbb&#x27;</span>));<br><span class="hljs-comment">/// <span class="language-markdown">新开bbb，清空所有路由栈</span></span><br>Get.offAllNamed(<span class="hljs-string">&#x27;/bbb&#x27;</span>);<br></code></pre></td></tr></table></figure><p>2、状态管理</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-number">1</span>、obs配合obx<br><span class="hljs-comment">///<span class="language-markdown"> view</span></span><br>Obx(() &#123;<span class="hljs-keyword">return</span> Text(<span class="hljs-string">&#x27;我是数据<span class="hljs-subst">$&#123;state.ob[<span class="hljs-string">&#x27;a&#x27;</span>]&#125;</span>&#x27;</span>);&#125;),<br><span class="hljs-comment">///<span class="language-markdown"> model数据监听</span></span><br><span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>,<span class="hljs-built_in">dynamic</span>&gt; ob = &#123;<br>  <span class="hljs-string">&#x27;a&#x27;</span>:<span class="hljs-number">55</span>,<br>  <span class="hljs-string">&#x27;b&#x27;</span>:<span class="hljs-number">66</span><br>&#125;.obs;<br><span class="hljs-number">2</span>、update配合getbuilder<br><span class="hljs-comment">/// <span class="language-markdown">view</span></span><br>GetBuilder&lt;PageaaaLogic&gt;(builder: (logic) &#123;<span class="hljs-keyword">return</span> Text(<span class="hljs-string">&#x27;我是数据<span class="hljs-subst">$&#123;state.aNumber&#125;</span>&#x27;</span>);&#125;),<br><span class="hljs-comment">/// <span class="language-markdown">model 关键词 update</span></span><br><span class="hljs-keyword">void</span> setNumber()&#123;<br>  state.aNumber+=<span class="hljs-number">5</span>;<br>  update();<br>&#125;<br></code></pre></td></tr></table></figure><p>3、跨页面通信</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">///<span class="language-markdown"> 页面B正常写，页面C有点不一样</span></span><br><span class="hljs-comment">///<span class="language-markdown"> 取到B的logic</span></span><br><span class="hljs-keyword">final</span> bLogic = Get.find&lt;PagebbbLogic&gt;();<br><span class="hljs-comment">///<span class="language-markdown">操作B的方法</span></span><br>ElevatedButton(<br>  child: <span class="hljs-keyword">new</span> Text(<span class="hljs-string">&#x27;在页面上调用B的方法，更新B页面数据&#x27;</span>),<br>  onPressed: () &#123;<br>    bLogic.setNumber();<br>  &#125;,<br>),<br><span class="hljs-comment">///<span class="language-markdown">真尼玛简单</span></span><br></code></pre></td></tr></table></figure><p>4、全局变量和数据固化</p><p>嗯，还是 SharedPreferences  永远的神</p><p>5、弹框</p><p><a href="https://www.jianshu.com/p/169af33a5994">https://www.jianshu.com/p/169af33a5994</a></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">///<span class="language-markdown"> 类似应用内部的自定义推送，挺好看，可以自定义内容，但是只能在top和bottom，还可以设置点击事件</span></span><br>Get.snackbar(<span class="hljs-string">&quot;Snackbar 标题&quot;</span>, <span class="hljs-string">&quot;欢迎使用Snackbar&quot;</span>,backgroundColor:Colors.cyan,snackPosition: SnackPosition.TOP);<br><span class="hljs-comment">///<span class="language-markdown"> 弹框，不需要context，自定义内容，按钮等等，好用极了，关闭的时候就是Get.back()</span></span><br>Get.defaultDialog();<br><span class="hljs-comment">///<span class="language-markdown"> bottomSheet，是要做actionsheet吗？要自己写全套，这只是个弹出层</span></span><br>Get.bottomSheet();<br></code></pre></td></tr></table></figure><p>6、主题</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">///<span class="language-markdown"> 真尼玛简单啊</span></span><br><span class="hljs-comment">///<span class="language-markdown"> 搞个theme文件，指定背景，状态栏，按钮等等，之前我以为只是一个颜色，肤浅了！！！</span></span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Themes</span> </span>&#123;<br>  <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> green = ThemeData.light().copyWith(<br>    scaffoldBackgroundColor: Colors.green,<br>    appBarTheme: <span class="hljs-keyword">const</span> AppBarTheme(<br>        backgroundColor: Colors.green,<br>        toolbarTextStyle:TextStyle(color: Colors.white, fontSize: <span class="hljs-number">30</span>)),<br>  );<br>  <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> yellow = ThemeData.light().copyWith(<br>      scaffoldBackgroundColor: Colors.yellow,<br>      appBarTheme: <span class="hljs-keyword">const</span> AppBarTheme(<br>          backgroundColor: Colors.yellow,<br>          toolbarTextStyle:TextStyle(color: Colors.white, fontSize: <span class="hljs-number">30</span>)),<br>          elevatedButtonTheme: ElevatedButtonThemeData(style: ButtonStyle(backgroundColor: MaterialStateProperty.all(Colors.deepOrange))));<br>&#125;<br><span class="hljs-comment">///<span class="language-markdown"> 感觉main.dart写不写没啥关系啊</span></span><br><span class="hljs-keyword">return</span> GetMaterialApp(<br>  title: <span class="hljs-string">&#x27;Flutter Demo&#x27;</span>,<br>  theme: ThemeData(<br>    primarySwatch: Colors.blue,<br>  ),<br>)<br><span class="hljs-comment">///<span class="language-markdown"> 关键的就这么一句</span></span><br>Get.changeTheme(Themes.yellow);<br></code></pre></td></tr></table></figure><p>7、网络</p><p>还是用dio，术业有专攻吧，感觉GetConnect的错误处理不如dio</p><p>8、插件介绍</p><p><a href="https://juejin.cn/post/7005003323753365517">https://juejin.cn/post/7005003323753365517</a>—文件生成器介绍篇</p><p>easy模式就够我们用了</p><p>pageview要特殊处理一下</p><p>9、api</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">///<span class="language-markdown"> 我就想知道find和put的区别，其他的还是看文档吧</span></span><br><span class="hljs-comment">///<span class="language-markdown"> https://juejin.cn/post/6910920929199521800  这个就很不错</span></span><br><span class="hljs-comment">/// <span class="language-markdown">依赖注入是什么---本来接受各种参数来构造一个对象，现在只接受一个参数——已经实例化的对象。</span></span><br><span class="hljs-comment">///<span class="language-markdown"> 依赖注入是为了将依赖组件的配置和使用分离开，以降低使用者与依赖之间的耦合度。</span></span><br><span class="hljs-comment">///<span class="language-markdown"> 注入依赖</span></span><br>Get.put&lt;PutController&gt;(PutController());<br><span class="hljs-comment">///<span class="language-markdown"> 获取依赖</span></span><br>Get.find&lt;PutController&gt;();<br></code></pre></td></tr></table></figure><p>10、组件</p><p>没有合适的整套的</p><p><a href="https://github.com/felixblaschke/simple_animations">https://github.com/felixblaschke/simple_animations</a>—这个动画应该有用</p><p>11、生命周期</p><p>参考：<a href="https://zhuanlan.zhihu.com/p/445371503">https://zhuanlan.zhihu.com/p/445371503</a></p><p>常用的就是：</p><p>onInit（初始化，页面加载到内存中触发）；</p><p>onReady（就绪，处理接口，业务逻辑）；</p><p>onClose（销毁，删除监听事件）</p><p>另外的onResume等等，要用 WidgetsBindingObserver，如下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutter/cupertino.dart&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:get/get.dart&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;state.dart&#x27;</span>;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PagebbbLogic</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">GetxController</span> <span class="hljs-title">with</span> <span class="hljs-title">WidgetsBindingObserver</span> </span>&#123;<br>  <span class="hljs-keyword">final</span> PagebbbState state = PagebbbState();<br>  <span class="hljs-keyword">void</span> setNumber()&#123;<br>    state.bNumber+=<span class="hljs-number">5</span>;<br>  &#125;<br>  <span class="hljs-keyword">void</span> setOb()&#123;<br>    state.ob[<span class="hljs-string">&#x27;a&#x27;</span>] += <span class="hljs-number">5</span>;<br>  &#125;<br>  <span class="hljs-meta">@override</span><br>  <span class="hljs-keyword">void</span> onInit() &#123;<br>    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> implement onInit</span><br>    <span class="hljs-keyword">super</span>.onInit();<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;init&#x27;</span>);<br>    WidgetsBinding.instance?.addObserver(<span class="hljs-keyword">this</span>); <span class="hljs-comment">/// <span class="language-markdown">添加监听</span></span><br>  &#125;<br>  <span class="hljs-meta">@override</span><br>  <span class="hljs-keyword">void</span> onReady() &#123;<br>    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> implement onInit</span><br>    <span class="hljs-keyword">super</span>.onReady();<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;onReady&#x27;</span>);<br>    <span class="hljs-keyword">var</span> map = Get.arguments;<br>    <span class="hljs-built_in">print</span>(map);<br>  &#125;<br>  <span class="hljs-meta">@override</span><br>  <span class="hljs-keyword">void</span> onClose() &#123;<br>    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> implement onClose</span><br>    <span class="hljs-keyword">super</span>.onClose();<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;onClose&#x27;</span>);<br>    WidgetsBinding.instance?.removeObserver(<span class="hljs-keyword">this</span>); <span class="hljs-comment">/// <span class="language-markdown">删除监听</span></span><br>  &#125;<br>  <span class="hljs-meta">@override</span><br>  Future didChangeAppLifecycleState(AppLifecycleState state) <span class="hljs-keyword">async</span> &#123;<br>    <span class="hljs-built_in">print</span>(state);<br>    <span class="hljs-keyword">switch</span> (state) &#123;<br>      <span class="hljs-keyword">case</span> AppLifecycleState.inactive: <span class="hljs-comment">// 处于这种状态的应用程序应该假设它们可能在任何时候暂停。</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;inactive&quot;</span>);<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> AppLifecycleState.resumed:<span class="hljs-comment">// 应用程序可见，后台返回至前台</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;进入resumed&quot;</span>);<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> AppLifecycleState.paused: <span class="hljs-comment">// 应用程序不可见，进入后台</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;进入后台paused&quot;</span>);<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> AppLifecycleState.detached: <span class="hljs-comment">// 申请将暂时暂停</span><br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">default</span>:<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>12、小知识</p><p><a href="https://github.com/jonataslaw/getx#dependency-management">https://github.com/jonataslaw/getx#dependency-management</a>—-官方文档</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">// 页面传参</span><br>Get.arguments<br><span class="hljs-comment">// give name of previous route</span><br>Get.previousRoute<br><span class="hljs-comment">// 平台</span><br>GetPlatform.isAndroid<br>GetPlatform.isIOS<br><span class="hljs-comment">// check if snackbar is open</span><br>Get.isSnackbarOpen<br><span class="hljs-comment">// check if dialog is open</span><br>Get.isDialogOpen<br><span class="hljs-comment">// check if bottomsheet is open</span><br>Get.isBottomSheetOpen<br><span class="hljs-comment">// Equivalent to : MediaQuery.of(context).size.height,</span><br><span class="hljs-comment">// but immutable.</span><br>Get.height<br>Get.width<br><span class="hljs-comment">// 获取当前context，插件会用到</span><br>Get.context<br><span class="hljs-comment">// Gives the context of the snackbar/dialog/bottomsheet in the foreground, anywhere in your code.</span><br>Get.contextOverlay<br></code></pre></td></tr></table></figure><p>12、原理</p><p><a href="https://juejin.cn/post/6909445601269088270">https://juejin.cn/post/6909445601269088270</a></p><p><a href="https://juejin.cn/post/6984593635681517582#heading-19">https://juejin.cn/post/6984593635681517582#heading-19</a></p><p>数据刷新的原理：</p><p>    1、GetBuilder加手动update：GetBuilder实际上是个 StatefulWidget，update底层实际上是setState();</p><p>    2、obx加obs：obx继承ObxWidget，ObxWidget实际上也继承了StatefulWidget，obx初始化的时候会**RxNotifier()**订阅包含的obs变量的变化 ，obs值发生变化就会触发setState()；</p><p>    —obs是在原数据的基础上内置callback的数据类型，数据变动触发callback，就是触发obx刷新；</p><p>所以表面上看我们使用get框架写的页面都是StatelessWidget，实际上涉及数据操作的部分，底层还是StatefulWidget，万变不离其宗。</p><p>无context的路由跳转原理：</p><p>源码直接就能看到，用的就是原始的无context跳转：navigatorKey.currentState.pushNamed(‘&#x2F;home’)</p><p>参考链接：</p><p><a href="https://segmentfault.com/a/1190000039139198">https://segmentfault.com/a/1190000039139198</a>—好文章，介绍篇</p><p><a href="https://juejin.cn/post/7005003323753365517">https://juejin.cn/post/7005003323753365517</a>—文件生成器介绍篇</p><p><a href="https://juejin.cn/post/6984593635681517582">https://juejin.cn/post/6984593635681517582</a>—-原理篇</p>]]></content>
    
    
    <categories>
      
      <category>Flutter</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Flutter</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Fusion Design框架的调研</title>
    <link href="/2021/10/14/investigation/Fusion-Design/"/>
    <url>/2021/10/14/investigation/Fusion-Design/</url>
    
    <content type="html"><![CDATA[<h1 id="Fusion-Design框架的调研"><a href="#Fusion-Design框架的调研" class="headerlink" title="Fusion Design框架的调研"></a>Fusion Design框架的调研</h1><h2 id="Fusion框架介绍"><a href="#Fusion框架介绍" class="headerlink" title="Fusion框架介绍"></a>Fusion框架介绍</h2><p>Fusion Design框架主要包含四个部分：</p><p>一、组件库 @alifd&#x2F;next</p><p>仓库：<a href="https://github.com/alibaba-fusion/next">https://github.com/alibaba-fusion/next</a></p><p>文档： <a href="https://fusion.design/pc/doc/component/102?themeid=1">https://fusion.design/pc/doc/component/102?themeid=1</a></p><p>有50多个组件，和Element，Ant Design相比没有太大差别，能够满足业务开发的需要</p><p>二、Fusion 站点</p><p>这是个后台系统，在这里配置组件大小，圆角，颜色等等自定义组件样式的东西，然后点击发布，这一整套主题就会发布到npm仓库(java script包管理工具)，前端React项目就可以安装使用这个主题包</p><p>三、FusionCool Sketch 插件</p><p>引入Sketch插件后，在Fusion站点配置的组件会同步过来，这样设计稿的组件和前端开发时使用的组件就是高度一致的了</p><p>四、Iceworks 客户端</p><p>这个客户端是Fusion Design生态系统的一部分，主要功能有两个，第一是提供模板快速创建项目，第二是可以通过拖拽组件的方式快速生成页面</p><p>通过模板快速创建项目是个很好的尝试，icework不仅创建了项目结构而且创建了很多页面，不过现实情况是大部分项目页面结构各不相同，最好的做法是只创建项目结构，安装好必要的依赖，具体的页面结构自定义开发，如果有一些赶工的临时项目，这倒是个解决方案。</p><p>拖拽组件创建页面我也试了一下，现在还不成熟，不好用，等等看吧。</p><h2 id="关于主题部分的调研"><a href="#关于主题部分的调研" class="headerlink" title="关于主题部分的调研"></a>关于主题部分的调研</h2><p>一、其他组件主题样式是怎么处理的</p><p>1、Element是饿了么团队开发的组件库，处理主题有两种方式：，第一种是在项目中通过覆盖定义样式变量的值直接起作用；第二种是通过一个在线工具，调整各种组件的颜色值，然后下载到本地引入，本质也是覆盖定义。element的主题可以自定义圆角大小，字体大小，颜色等等，这个方式还不错。</p><p><a href="https://element.eleme.cn/#/zh-CN/theme/preview">https://element.eleme.cn/#/zh-CN/theme/preview</a></p><p>2、Ant Design是蚂蚁团队开发的组件库，处理主题和Element第一种方式一样，自定义颜色值，覆盖原始值，这个比较low</p><p>二、Fusion Design框架主题的使用步骤</p><p>1、首先在后台配置组件的主题，颜色，大小等等，然后发布到npm仓库；</p><p>2、其次ui在sketch中安装Fusion插件，使用发布的组件设计页面，</p><p>3、最后前端人员在项目中安装主题库，拼接组件，创建页面。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>前端开发大概是四步：</p><p>1、拼接组件，页面布局</p><p>2、按照ui设计还原组件大小颜色等属性</p><p>3、点击事件页面逻辑等</p><p>4、接口调试</p><p>Fusion Design框架主要解决第二个步骤，另外，统一的组件库和风格会加快开发进度。</p><p>这个框架是基于React做的，目前公司主要的技术栈是Vue，React的项目比较少，所以已经存在的vue项目是不能使用这个框架的，暂时就不用了。</p>]]></content>
    
    
    <categories>
      
      <category>技术调研</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>android的keystore相关命令</title>
    <link href="/2021/09/23/android/android-keystore/"/>
    <url>/2021/09/23/android/android-keystore/</url>
    
    <content type="html"><![CDATA[<h1 id="android的keystore"><a href="#android的keystore" class="headerlink" title="android的keystore"></a>android的keystore</h1><p>1、查看信息（默认的android debug 的key 默认密码是android）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">keytool -list -keystore [keystoreFilePath]<br></code></pre></td></tr></table></figure><p>2、修改keystore 文件密码(storePassword)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">keytool -storepasswd -keystore [keystoreFilePath]<br></code></pre></td></tr></table></figure><p>3、修改alias别名</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">keytool -changealias -keystore [keystoreFilePath] -<span class="hljs-built_in">alias</span> [oldName] -destalias [newName]<br></code></pre></td></tr></table></figure><p>4、修改alias密码（keyPassword）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">keytool -keypasswd -keystore [keystoreFilePath] -<span class="hljs-built_in">alias</span> [<span class="hljs-built_in">alias</span>]<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>可视化看板大屏</title>
    <link href="/2021/08/03/investigation/visualization/"/>
    <url>/2021/08/03/investigation/visualization/</url>
    
    <content type="html"><![CDATA[<h1 id="可视化看板大屏"><a href="#可视化看板大屏" class="headerlink" title="可视化看板大屏"></a>可视化看板大屏</h1><p>大屏可视化看板的应用场景是这样的：</p><p>1、客户对大屏业务操作几乎没有要求（实际上大屏没几个支持操作的，就只能看）；</p><p>2、开发周期短；</p><p>3、期望先出效果再谈后续业务的。</p><p>在这样的情况下，可视化拖拽的大屏就是很合适的，节约成本，皆大欢喜。</p><p>目前可视化大屏还挺多，挑几个写写。</p><p>一、dataV</p><p><a href="https://www.aliyun.com/activity/intelligent/datavedition">https://www.aliyun.com/activity/intelligent/datavedition</a></p><p>阿里出品，我们使用过一段时间企业版5千多一年，20个大屏额度，能满足基本需求，就是有点卡。</p><p>3d的部分看到文档里有说3d地图，但是必须升级到2万4一年的专业版(支持40个大屏 )才能看效果，看不了，告辞。</p><p>二、51word</p><p><a href="https://wdp.51aes.com/">https://wdp.51aes.com/</a></p><p>国内的，云渲染技术的三维模型，大屏的内容有两个，底层模型和上层图层；</p><p>底层模型不支持自定义上传，因为人家就是靠定制化建模赚钱的；</p><p>上层的图层可以加图表啊什么的，这个和datav类似</p><p>也可以通过按钮定义事件，操作图表或者操作下层模型的api，按钮事件的绑定通过拖拽式操作，挺有意思的；</p><p>这些操作都需要在客户端操作，发布之后通过网页链接访问；</p><p>上层图表比较少，主要卖点是下层的模型，不太适合。</p><p>三、rayData</p><p>腾讯旗下的一款可视化数据看板，和datav很类似，价格也类似，可能因为我不是设计师，说不上来啥，就是感觉还不如datav呢；</p><p>四、easyV</p><p>瑞眼目前在用的大屏技术。1980一个月</p><p>五、metabase</p><p><a href="https://github.com/metabase/metabase">https://github.com/metabase/metabase</a></p><p>国外的产品，开源可独立部署，数据源支持挺多：</p><p>Postgres、MySQL、Druid、SQL Server、ClickHouse、MongoDB、BigQuery、Oracle、Vertica、Presto、Snowflake、Spark</p><p>付费版有更多的功能：</p><p>1、一个列表，有行级别的显示权限；</p><p>2、去掉logo,自定义logo，字体，颜色等；</p><p>3、客户分析功能（访问分析，哪些客户下载了哪些数据分析）;</p><p>4、跟踪用户大屏访问数据(怎么感觉还是上面那个)；</p><p>总的来说就是：1、权限更精细；2、UI定制程度更高；3、客户行为分析。</p><p>图表设置界面(17种图表类型)：</p><p><img src="/image/article/investigation/visualization/1.png"></p><p>价格：</p><p><img src="/image/article/investigation/visualization/2.png"></p><p>手动设置sql，不太懂sql的也能操作</p><p>优点：</p><p>1、svg技术，图表会很流畅；</p><p>2、看板支持拖拽调整位置；</p><p>缺点：</p><p>1、开源版本不能去掉logo；</p><p>2、不能设置单个图表的刷新时间，只能设置大屏整体定时刷新；</p><p>3、只能从数据源拿数据，不能是已存在的http接口；</p><p>4、不能在数据源之后处理数据，比如格式化一个数据；</p><p>5、图表只能设置线条颜色，其他自定义颜色字体都是付费功能；</p><p>6、图表类型只有17种；</p><p>六、datagear</p><p><a href="https://gitee.com/datagear/datagear">https://gitee.com/datagear/datagear</a></p><p>国内一款开源的产品，作为开源产品还是很不错的，开源可独立部署；</p><p>数据集是手写原生sql。可以设置项目，把图表和看板加入项目中，可分类(实际上并没有什么卵用，没有权限判断，只能算个分类标签)；数据存储位置：[~&#x2F;.datagear]</p><p>优点：</p><p>1、支持图表73种；</p><p>2、可以设置单个图表的刷新时间；</p><p>3、可以设置csv，http接口作为数据集；</p><p>4、可以设置主题颜色等等，也可以手动修改源码；</p><p>5、有模板，可快速配置；</p><p>6、可以手动选择时机渲染图表；</p><p>7、可以通过其他页面传值动态设置sql或者http数据集的参数；</p><p>8、可以在接口返回值之后修改返回值仔渲染，非常牛逼；</p><p>缺点：</p><p>1、不支持非关系型数据库Mongo等作为数据源（它只支持jdbc连接的数据库，jdbc特指关系型数据库连接方式）；</p><p>七、Datart</p><p><a href="https://running-elephant.gitee.io/datart-docs/">https://running-elephant.gitee.io/datart-docs/</a></p><p>不好用，丑，而且才两三个组件就卡了</p><p>目前的选择是datagear</p>]]></content>
    
    
    <categories>
      
      <category>技术调研</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>http缓存</title>
    <link href="/2021/07/22/concept/cache/"/>
    <url>/2021/07/22/concept/cache/</url>
    
    <content type="html"><![CDATA[<h1 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h1><p>缓存的主要作用是减少没有必要的请求，减少服务器压力的同时也能提升前端页面的性能；</p><p>简易流程：</p><p>    第一次请求的时候浏览器把资源下载下来，这个http的response里面就会包含一些字段(expires，cache-control，pragma等)标识这个资源能不能被缓存，如果能被缓存到浏览器本地，他就是个强缓存，</p><p>在强缓存过期之后(或者直接刷新页面，或者no-cache等情况)，浏览器就会请求服务端获取该资源，服务端判断资源是否过期，未过期就304告诉浏览器去取本地缓存，这个就是协商缓存，</p><p>如果过期了那就相当于重新请求了，http状态码200。</p><p>下面主要介绍强缓存和协商缓存：</p><p>强缓存</p><ol><li>概念</li></ol><p>    直接使用本地的缓存，不用跟服务器进行通信，http状态码是200，显示from  memery  或者 from  disk，这个存在哪里是浏览器控制的。</p><ol start="2"><li>相关header字段</li></ol><p>    2.1 expires</p><p>        这是http1.0中定义的字段，它是一个服务器时间的格林威治时间戳，但是是拿客户端本地的时间和这个时间戳对比判断的，客户端的本地时间可以修改，不靠谱，所以不好用。</p><p>    2.2 cache-control</p><p>        http1.1中的字段，为了解决上面expires的问题而新增的，优先级高于 expires。</p><p>        它是一个相对时间段，请求有效的最大时间段，比如max-age：30，代表请求时间点加30秒之后就无效了，</p><p>        因为它是一个时间段，所以意味着，可以设置一些默认值，</p><p>        常见的默认值设置：</p><p>            pubilc： 客户端和代理服务器cdn等都可以缓存该资源；</p><p>            private： 只让客户端可以缓存该资源；代理服务器不缓存；</p><p>             immutable：如果缓存在有效期内，即使用户刷新了页面也不请求服务器（正常情况下刷新页面是忽略是否有效，请求服务器走协商缓存的）；</p><p>            no-cache：不强缓存，相当于直接走协商缓存（刷新页面的操作就是no-cache）；</p><p>            no-store：没有强缓存和协商缓存了，禁止浏览器和服务器缓存数据，也禁止保存至临时文件中，每次都重新请求。</p><p>    2.3 pragma </p><p>        这是也是http1.0的字段，正在逐步抛弃，但是他也是有效的，而且优先级   pragma &gt; cache-control &gt; expires，他有两个值no-cache和no-store，效果是和cache-control一样的。</p><p> 协商缓存</p><ol><li>概念</li></ol><p>    本地缓存过期或者其他原因(no-cache，刷新等等)，浏览器会请求服务端判断文件是否依然有效，这就是协商缓存。</p><ol start="2"><li>相关header字段</li></ol><p>    2.1 last-modified</p><p>        response会返回这个字段，代表文件最后一次编辑的时间，浏览器再次请求该文件时request会有一个if-modified-since字段，他俩就是一个意思，如果相同说明没修改，http304告诉浏览器还用本地的，如果不同那就返回新文件同时更新文件的last-modified（也更新etag）。</p><p>        但是这玩意有两个不好的地方：</p><p>        1、无论内容是否真的变化，只要编辑就会修改last-modified；</p><p>        2、last-modified只能精确到秒，如果在一秒内文件修改了，last-modified就判断未修改，取缓存会造成错误。</p><p>    2.2 etag</p><p>        etag也是为了解决上面的last-modified问题出现的，etag是基于文件内容生成的一个字符串，我个人简单理解为类似于文件md5，etag对文件变化感知更精确，所以优先级高于last-modified，etag是response里面的字段，在request里面叫if-none-matched</p><p>刷新操作对缓存的影响：</p><p><img src="/image/article/concept/cache/3d4b82f9-73ec-4841-96d7-11e0f85d1cec.png"></p><p>1、刷新页面实际上是把cache-control设置成了max-age：0，相当于不判断本地是否过期，直接走协商缓存；</p><p>2、强制刷新是跳过缓存，相当于第一次请求资源。</p><p>no-cache 和 max-age：0 在一般情况下的表现效果是一致的，区别在于前者是must，后者是should，如果服务器端发生错误，没有返回新的文件，</p><p>那么max-age的文件是勉强可以用的，no-cache的文件是绝对不能使用的</p><p>参考链接：（这几篇文章真的好）</p><p><a href="https://www.jianshu.com/p/9c95db596df5">https://www.jianshu.com/p/9c95db596df5</a></p><p><a href="https://www.jianshu.com/p/fb59c770160c">https://www.jianshu.com/p/fb59c770160c</a></p><p><a href="https://juejin.cn/post/6844903763665240072">https://juejin.cn/post/6844903763665240072</a></p>]]></content>
    
    
    <categories>
      
      <category>概念知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>http</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Object.defineProperty是什么</title>
    <link href="/2021/06/28/concept/Object-defineProperty/"/>
    <url>/2021/06/28/concept/Object-defineProperty/</url>
    
    <content type="html"><![CDATA[<h1 id="Object-defineProperty-是什么鬼"><a href="#Object-defineProperty-是什么鬼" class="headerlink" title="Object.defineProperty 是什么鬼"></a>Object.defineProperty 是什么鬼</h1><p>假设我们有个对象 user ; 我们要给它增加一个属性 name , 我们会这么做</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> user = &#123;&#125;;<br>user.<span class="hljs-property">name</span>=<span class="hljs-string">&quot;狂奔的蜗牛&quot;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(user);<span class="hljs-comment">//&#123;name: &quot;狂奔的蜗牛&quot;&#125;</span><br></code></pre></td></tr></table></figure><p>如果想要增加一个sayHi方法呢？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript">user.<span class="hljs-property">sayHi</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123; <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Hi !&quot;</span>) <br>&#125;;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(user);<span class="hljs-comment">//&#123;name: &quot;狂奔的蜗牛&quot;, sayHi: ƒn&#125;</span><br></code></pre></td></tr></table></figure><p>Object.defineProperty 就是做这个的</p><p><strong>那么Object.defineProperty 怎么用？</strong></p><p>Object.defineProperty 需要三个参数（object , propName , descriptor）</p><ul><li>object 对象 &#x3D;&gt; 给谁加</li><li>propName 属性名 &#x3D;&gt; 要加的属性的名字 【类型：String】</li><li>descriptor 属性描述 &#x3D;&gt; 加的这个属性有什么样的特性【类型：Object】</li></ul><h3 id="那么descriptor这个是个对象-，他有那些属性呢-别着急我们一个一个说；"><a href="#那么descriptor这个是个对象-，他有那些属性呢-别着急我们一个一个说；" class="headerlink" title="那么descriptor这个是个对象 ，他有那些属性呢 ? 别着急我们一个一个说；"></a>那么descriptor这个是个对象 ，他有那些属性呢 ? 别着急我们一个一个说；</h3><h3 id="1、writable"><a href="#1、writable" class="headerlink" title="1、writable"></a>1、writable</h3><p>既然可以给一个对象增加属性，那么我们用它来做一下给 user添加 name属性，代码是这样的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> user = &#123;&#125;;<br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(user,<span class="hljs-string">&quot;name&quot;</span>,&#123; <span class="hljs-attr">value</span>:<span class="hljs-string">&quot;狂奔的蜗牛&quot;</span>&#125;);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(user);<span class="hljs-comment">//&#123;name: &quot;狂奔的蜗牛&quot;&#125;</span><br></code></pre></td></tr></table></figure><p>说明 是的还是那个经典的value属性，他就是设置属性值的。</p><p>等等，属性值只能为字符串吗？我们的 number function Object boolean 等呢？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> user = &#123;&#125;;<br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(user,<span class="hljs-string">&quot;name&quot;</span>,&#123; <span class="hljs-attr">value</span>:<span class="hljs-string">&quot;狂奔的蜗牛&quot;</span>&#125;)<br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(user,<span class="hljs-string">&quot;isSlow&quot;</span>,&#123; <span class="hljs-attr">value</span>:<span class="hljs-literal">true</span>&#125;)<br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(user,<span class="hljs-string">&quot;sayHi&quot;</span>,&#123; <span class="hljs-attr">value</span>:<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Hi !&quot;</span>) &#125;&#125;)<br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(user,<span class="hljs-string">&quot;age&quot;</span>,&#123; <span class="hljs-attr">value</span>:<span class="hljs-number">12</span>&#125;)<br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(user,<span class="hljs-string">&quot;birth&quot;</span>,&#123; <span class="hljs-attr">value</span>:&#123;  <span class="hljs-attr">date</span>:<span class="hljs-string">&quot;2018-06-29&quot;</span>,  <span class="hljs-attr">hour</span>:<span class="hljs-string">&quot;15:30&quot;</span> &#125;&#125;)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(user);<br></code></pre></td></tr></table></figure><p><img src="/image/article/concept/Object-defineProperty/723c0f9b-8cd1-4cd0-b554-2d882cf1d68b.png"></p><p>说明 事实证明任何类型的数据都是可以的哦~</p><p>问题又来了，如果 user对象已经有了name属性，我们可以通过Object.defineProperty改变这个值吗？我们来试试:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> user = &#123;&#125;;<br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(user,<span class="hljs-string">&quot;name&quot;</span>,&#123; <span class="hljs-attr">value</span>:<span class="hljs-string">&quot;狂奔的蜗牛&quot;</span>&#125;)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(user);<br>user.<span class="hljs-property">name</span>=<span class="hljs-string">&quot;新=&gt;狂奔的蜗牛&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(user);<br></code></pre></td></tr></table></figure><p>咦？？为什么我改了没作用勒？？</p><p>原因：上边说了descriptor有很多属性，除了value属性还有个 writable【顾名思义属性是否可以被重新赋值】接受数据类型为 boolean（默认为false） true &#x3D;&gt; 支持被重新赋值 false&#x3D;&gt;只读</p><p>哦哦，原来如果我没设置writable值的时候就默认只读啊，所以才改不掉</p><p>那我们看看，设置为true，是不是就可以改掉了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> user = &#123;&#125;;<br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(user,<span class="hljs-string">&quot;name&quot;</span>,&#123; <span class="hljs-attr">value</span>:<span class="hljs-string">&quot;狂奔的蜗牛&quot;</span>, <span class="hljs-attr">writable</span>:<span class="hljs-literal">true</span>&#125;)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(user);<br>user.<span class="hljs-property">name</span>=<span class="hljs-string">&quot;新=&gt;狂奔的蜗牛&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(user);<br></code></pre></td></tr></table></figure><p><img src="/image/article/concept/Object-defineProperty/e63b0606-fe5e-4af8-b19b-c89341a07984.png"></p><h3 id="2、enumerable"><a href="#2、enumerable" class="headerlink" title="2、enumerable"></a>2、enumerable</h3><p>enumerable【顾名思义属性是否可以被枚举】接受数据类型为 boolean（默认为false） true &#x3D;&gt; 支持被枚举 false&#x3D;&gt;不支持</p><p>额。。。枚举？？什….什么意思？</p><p>假设我们想知道这个 user对象有哪些属性我们一般会这么做</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> user =&#123; <span class="hljs-attr">name</span>:<span class="hljs-string">&quot;狂奔的蜗牛&quot;</span>, <span class="hljs-attr">age</span>:<span class="hljs-number">25</span>&#125; ; <br><span class="hljs-comment">//es6</span><br><span class="hljs-keyword">var</span> keys=<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(user)<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(keys);<span class="hljs-comment">// [&#x27;name&#x27;,&#x27;age&#x27;]</span><br><span class="hljs-comment">//es5</span><br><span class="hljs-keyword">var</span> keys=[];<span class="hljs-keyword">for</span>(key <span class="hljs-keyword">in</span> user)&#123;<br> keys.<span class="hljs-title function_">push</span>(key);<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(keys);<span class="hljs-comment">// [&#x27;name&#x27;,&#x27;age&#x27;]</span><br></code></pre></td></tr></table></figure><p>如果我们使用 Object.的方式定义属性会发生什么呢？我们来看下输出</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> user =&#123; <span class="hljs-attr">name</span>:<span class="hljs-string">&quot;狂奔的蜗牛&quot;</span>, <span class="hljs-attr">age</span>:<span class="hljs-number">25</span>&#125; ;<br><span class="hljs-comment">//定义一个性别 可以被枚举</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(user,<span class="hljs-string">&quot;gender&quot;</span>,&#123; <span class="hljs-attr">value</span>:<span class="hljs-string">&quot;男&quot;</span>, <span class="hljs-attr">enumerable</span>:<span class="hljs-literal">true</span>&#125;) <br><span class="hljs-comment">//定义一个出生日期 不可以被枚举</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(user,<span class="hljs-string">&quot;birth&quot;</span>,&#123; <span class="hljs-attr">value</span>:<span class="hljs-string">&quot;1956-05-03&quot;</span>, <span class="hljs-attr">enumerable</span>:<span class="hljs-literal">false</span>&#125;) <br><span class="hljs-comment">//es6</span><br><span class="hljs-keyword">var</span> keys=<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(user)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(keys);<span class="hljs-comment">// [&quot;name&quot;, &quot;age&quot;, &quot;gender&quot;] </span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(user);<span class="hljs-comment">// &#123;name: &quot;狂奔的蜗牛&quot;, age: 25, gender: &quot;男&quot;, birth: &quot;1956-05-03&quot;&#125;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(user.<span class="hljs-property">birth</span>);<span class="hljs-comment">// 1956-05-03</span><br></code></pre></td></tr></table></figure><p>很明显，我们定义为　enumerable&#x3D;false的birth属性并没有被遍历出来，遍历 &#x3D;&gt; 其实就是枚举（个人理解啦，不喜勿喷哦~）</p><p><strong>总结：</strong>enumerable 属性取值为 布尔类型 true | false 默认值为 false，为真属性可以被枚举；反之则不能。此设置不影响属性的调用和 查看对象的值。</p><h3 id="3、configurable"><a href="#3、configurable" class="headerlink" title="3、configurable"></a>3、configurable</h3><p>configurable 是接下来我们要讲的一个属性，这个属性有两个作用：</p><p>1 属性是否可以被删除</p><p>2 属性的特性在第一次设置之后可否被重新定义特性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> user =&#123; <span class="hljs-attr">name</span>:<span class="hljs-string">&quot;狂奔的蜗牛&quot;</span>, <span class="hljs-attr">age</span>:<span class="hljs-number">25</span>&#125; ;<br><span class="hljs-comment">//定义一个性别 不可以被删除和重新定义特性</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(user,<span class="hljs-string">&quot;gender&quot;</span>,&#123; <span class="hljs-attr">value</span>:<span class="hljs-string">&quot;男&quot;</span>, <span class="hljs-attr">enumerable</span>:<span class="hljs-literal">true</span>, <span class="hljs-attr">configurable</span>:<span class="hljs-literal">false</span>&#125;) <br><span class="hljs-comment">//删除一下</span><br><span class="hljs-keyword">delete</span> user.<span class="hljs-property">gender</span>;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(user);<span class="hljs-comment">//&#123;name: &quot;狂奔的蜗牛&quot;, age: 25, gender: &quot;男&quot;&#125; </span><br><span class="hljs-comment">//重新定义特性</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(user,<span class="hljs-string">&quot;gender&quot;</span>,&#123; <span class="hljs-attr">value</span>:<span class="hljs-string">&quot;男&quot;</span>, <span class="hljs-attr">enumerable</span>:<span class="hljs-literal">true</span>, <span class="hljs-attr">configurable</span>:<span class="hljs-literal">true</span>&#125;)<br><span class="hljs-comment">// Uncaught TypeError: Cannot redefine property: gender//会报错，如下图</span><br></code></pre></td></tr></table></figure><p><img src="/image/article/concept/Object-defineProperty/b28f4855-4ace-4a3d-a454-518a17a23a73.png"></p><p>设置为 true</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> user =&#123; <span class="hljs-attr">name</span>:<span class="hljs-string">&quot;狂奔的蜗牛&quot;</span>, <span class="hljs-attr">age</span>:<span class="hljs-number">25</span>&#125;;<br><span class="hljs-comment">//定义一个性别 可以被删除和重新定义特性</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(user,<span class="hljs-string">&quot;gender&quot;</span>,&#123; <span class="hljs-attr">value</span>:<span class="hljs-string">&quot;男&quot;</span>, <span class="hljs-attr">enumerable</span>:<span class="hljs-literal">true</span>, <span class="hljs-attr">configurable</span>:<span class="hljs-literal">true</span>&#125;) <br><span class="hljs-comment">//删除前</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(user);<span class="hljs-comment">// &#123;name: &quot;狂奔的蜗牛&quot;, age: 25, gender: &quot;男&quot;&#125; </span><br><span class="hljs-comment">//删除一下</span><br><span class="hljs-keyword">delete</span> user.<span class="hljs-property">gender</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(user);<span class="hljs-comment">// &#123;name: &quot;狂奔的蜗牛&quot;, age: 25&#125; </span><br><span class="hljs-comment">//重新定义特性</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(user,<span class="hljs-string">&quot;gender&quot;</span>,&#123; <span class="hljs-attr">value</span>:<span class="hljs-string">&quot;男&quot;</span>, <span class="hljs-attr">enumerable</span>:<span class="hljs-literal">true</span>, <span class="hljs-attr">configurable</span>:<span class="hljs-literal">false</span>&#125;) <br><span class="hljs-comment">//删除前</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(user);<span class="hljs-comment">// &#123;name: &quot;狂奔的蜗牛&quot;, age: 25, gender: &quot;男&quot;&#125;</span><br><span class="hljs-comment">//删除一下 删除失败</span><br><span class="hljs-keyword">delete</span> user.<span class="hljs-property">gender</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(user);<span class="hljs-comment">// &#123;name: &quot;狂奔的蜗牛&quot;, age: 25, gender: &quot;男&quot;&#125;</span><br></code></pre></td></tr></table></figure><h3 id="4、Set和Get"><a href="#4、Set和Get" class="headerlink" title="4、Set和Get"></a>4、Set和Get</h3><p>最后我们来说说，最重要的两个属性 set和get（即存取器描述：定义属性如何被存取），这两个属性是做什么用的呢？我们通过代码来看看</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> user =&#123; <span class="hljs-attr">name</span>:<span class="hljs-string">&quot;狂奔的蜗牛&quot;</span>&#125; ;<br><span class="hljs-keyword">var</span> count = <span class="hljs-number">12</span>;<br><span class="hljs-comment">//定义一个age 获取值时返回定义好的变量count</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(user,<span class="hljs-string">&quot;age&quot;</span>,&#123; <span class="hljs-attr">get</span>:<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;  <span class="hljs-keyword">return</span> count; &#125;&#125;)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(user.<span class="hljs-property">age</span>);<span class="hljs-comment">//12 </span><br><span class="hljs-comment">//如果我每次获取的时候返回count+1呢</span><br><span class="hljs-keyword">var</span> user =&#123; <span class="hljs-attr">name</span>:<span class="hljs-string">&quot;狂奔的蜗牛&quot;</span>&#125; ;<br><span class="hljs-keyword">var</span> count = <span class="hljs-number">12</span>;<br><span class="hljs-comment">//定义一个age 获取值时返回定义好的变量count</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(user,<span class="hljs-string">&quot;age&quot;</span>,&#123; <span class="hljs-attr">get</span>:<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;  <span class="hljs-keyword">return</span> count+<span class="hljs-number">1</span>; &#125;&#125;)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(user.<span class="hljs-property">age</span>);<span class="hljs-comment">//13</span><br></code></pre></td></tr></table></figure><p>接下来我不用解释了吧，你想在获取该属性的时候对值做什么随你咯~</p><p>来来来，我们看看 set，不多说上代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> user =&#123; <span class="hljs-attr">name</span>:<span class="hljs-string">&quot;狂奔的蜗牛&quot;</span>&#125; ;<br><span class="hljs-keyword">var</span> count = <span class="hljs-number">12</span>;<br><span class="hljs-comment">//定义一个age 获取值时返回定义好的变量count</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(user,<span class="hljs-string">&quot;age&quot;</span>,&#123; <span class="hljs-attr">get</span>:<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;  <span class="hljs-keyword">return</span> count; &#125;, <span class="hljs-attr">set</span>:<span class="hljs-keyword">function</span>(<span class="hljs-params">newVal</span>)&#123;  count=newVal; &#125;&#125;)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(user.<span class="hljs-property">age</span>);<span class="hljs-comment">//12</span><br>user.<span class="hljs-property">age</span>=<span class="hljs-number">145</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(user.<span class="hljs-property">age</span>);<span class="hljs-comment">//145</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(count);<span class="hljs-comment">//145 </span><br><span class="hljs-comment">//等等，如果我想设置的时候是 自动加1呢？我设置145 实际上设置是146 </span><br><span class="hljs-keyword">var</span> user =&#123; <span class="hljs-attr">name</span>:<span class="hljs-string">&quot;狂奔的蜗牛&quot;</span>&#125; ;<br><span class="hljs-keyword">var</span> count = <span class="hljs-number">12</span>;<br><span class="hljs-comment">//定义一个age 获取值时返回定义好的变量count</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(user,<span class="hljs-string">&quot;age&quot;</span>,&#123; <br><span class="hljs-attr">get</span>:<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;  <span class="hljs-keyword">return</span> count; &#125;, <br><span class="hljs-attr">set</span>:<span class="hljs-keyword">function</span>(<span class="hljs-params">newVal</span>)&#123;  count=newVal+<span class="hljs-number">1</span>; &#125;<br>&#125;)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(user.<span class="hljs-property">age</span>);<span class="hljs-comment">//12</span><br>user.<span class="hljs-property">age</span>=<span class="hljs-number">145</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(user.<span class="hljs-property">age</span>);<span class="hljs-comment">//146</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(count);<span class="hljs-comment">//146</span><br></code></pre></td></tr></table></figure><p><strong>说明：</strong>注意：当使用了getter或setter方法，不允许使用writable和value这两个属性(如果使用，会直接报错滴)</p><p>get 是获取值的时候的方法，类型为 function ，获取值的时候会被调用，不设置时为 undefined</p><p>set 是设置值的时候的方法，类型为 function ，设置值的时候会被调用，undefined</p><p>get或set不是必须成对出现，任写其一就可以</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> user =&#123; <span class="hljs-attr">name</span>:<span class="hljs-string">&quot;狂奔的蜗牛&quot;</span>&#125; ;<br><span class="hljs-keyword">var</span> count = <span class="hljs-number">12</span>;<br><span class="hljs-comment">//定义一个age 获取值时返回定义好的变量count</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(user,<span class="hljs-string">&quot;age&quot;</span>,&#123; <br><span class="hljs-attr">get</span>:<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;这个人来获取值了！！&quot;</span>);  <span class="hljs-keyword">return</span> count; &#125;, <br><span class="hljs-attr">set</span>:<span class="hljs-keyword">function</span>(<span class="hljs-params">newVal</span>)&#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;这个人来设置值了！！&quot;</span>);  count=newVal+<span class="hljs-number">1</span>; &#125;<br>&#125;)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(user.<span class="hljs-property">age</span>);<span class="hljs-comment">//12user.age=145;console.log(user.age);//146</span><br></code></pre></td></tr></table></figure><p><img src="/image/article/concept/Object-defineProperty/1e0d44ad-8633-48a8-a6c9-253bcec3c1f8.jpg"></p><p><strong>【完结】</strong></p><p>Object.defineProperty方法直接在一个对象上定义一个新属性，或者修改一个已经存在的属性， 并返回这个对象</p><ul><li>value: 设置属性的值</li><li>writable: 值是否可以重写。true | false</li><li>enumerable: 目标属性是否可以被枚举。true | false</li><li>configurable: 目标属性是否可以被删除或是否可以再次修改特性 true | false</li><li>set: 目标属性设置值的方法</li><li>get：目标属性获取值的方法</li></ul><p>原文链接：<br><a href="https://www.jianshu.com/p/6519575e05">https://www.jianshu.com/p/6519575e05</a></p>]]></content>
    
    
    <categories>
      
      <category>概念知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>javascript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Flutter友盟统计插件</title>
    <link href="/2021/05/18/flutter/flutter-umeng/"/>
    <url>/2021/05/18/flutter/flutter-umeng/</url>
    
    <content type="html"><![CDATA[<h1 id="flutter友盟插件"><a href="#flutter友盟插件" class="headerlink" title="flutter友盟插件"></a>flutter友盟插件</h1><p>用的是这个：<a href="https://github.com/flmn/umeng_analytics_plugin">https://github.com/flmn/umeng_analytics_plugin</a></p><p>友盟官网文档 ：<a href="https://developer.umeng.com/docs/119267/detail/118588">https://developer.umeng.com/docs/119267/detail/118588</a></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">var</span> result = <span class="hljs-keyword">await</span> UmengAnalyticsPlugin.*init*(<br>androidKey: IotConfig.*ReleaseConfig*[<span class="hljs-string">&#x27;androidKey&#x27;</span>],<br>iosKey: IotConfig.*ReleaseConfig*[<span class="hljs-string">&#x27;iosKey&#x27;</span>],<br>logEnabled:<span class="hljs-keyword">true</span>,<br>channel:<span class="hljs-string">&#x27;debugInstall&#x27;</span><br>);<br></code></pre></td></tr></table></figure><p>1、友盟初始化的这个channel，渠道参数，如果不设置，android默认是Unknown，ios默认是app store，可以自定义</p><p>它的主要作用是统计推广下载渠道，所以如果想正确的使用这个参数，上架商店的时候，比如小米，华为，应用宝，浏览器推广下载这些apk里面的参数都要不一样，</p><p>就是不同渠道的apk，channel参数不一样，这样在友盟上就能看到推广数据了。这里有个坑，设备只会统计到第一次安装app的channel值，比如我先从小米商店安装，</p><p>卸载之后再从华为安装，这个设备的channel只会统计为小米，不会再改变。</p><p>channel是sdk自动上传的，无需手动维护。</p><p>参考链接：</p><p>    打包不同的渠道包     <a href="https://zhuanlan.zhihu.com/p/365347452">https://zhuanlan.zhihu.com/p/365347452</a></p><p>    channel的官网文档   <a href="https://developer.umeng.com/docs/119267/detail/118588">https://developer.umeng.com/docs/119267/detail/118588</a></p><p>2、友盟有个sessionContinueMillis参数，这个参数默认30秒</p><p>MobclickAgent.setSessionContinueMillis(sessionContinueMillis);</p><p>如果用户把app切到后台，打开其他应用（不打开也行），30s之后再打开app，那么就会新开一个session，</p><p>这个会影响统计的启动次数，所以我之前频繁的打开app是统计不到启动次数的</p><p>3、有个pageMode参数，默认AUTO</p><p>MobclickAgent.setPageCollectionMode(MobclickAgent.PageMode.AUTO);</p><p><img src="/image/article/flutter/flutter-umeng/c9d633a0-a5de-457d-93ed-9d3039e3fec1.png"></p><p>这个参数的意思是统计模式，如果是自动统计，那么所有的activity页面转场都会自动上传，否则需要手动上传，不过只有activity页面会上传，</p><p>我们的应用是flutter的，所以需要使用 onPageStart 和 onPageEnd 手动统计。</p><p>注意的地方：</p><p>    1、必须成对调用 onPageStart 和 onPageEnd ，</p><p>    2、上一个页面必须先onPageEnd，下一个页面再onPageStart </p><p>    3、必须在友盟后台设置–版本  中手动开启采集，这一点我不是特别确定</p><p>4、自定义事件</p><p>友盟的官方文档是这样的</p><p>UMConfigure. onEventObject(Context context, String eventID, Map map)</p><p>但是插件不完善，只能上传事件，不支持带参数</p><p>MobclickAgent.onEvent(context, eventId, label);</p><p>自定义事件必须先在友盟的平台上手动添加，获取到 eventID之后，sdk才能用</p><p>5、IOS和android不同的地方</p><p>    1、android版本取得是version 4.0.8  ios取得是buildId  16</p><p>    2、ios启动次数统计不准，我发现有些时候启动一次统计为2-3次，不知道是不是插件的问题</p><p>调研完了，就目前来说，是真的不好用，Flutter的生态还有待完善啊。</p>]]></content>
    
    
    <categories>
      
      <category>Flutter</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Flutter</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>可拖拽小程序</title>
    <link href="/2020/12/25/investigation/mini-program/"/>
    <url>/2020/12/25/investigation/mini-program/</url>
    
    <content type="html"><![CDATA[<h1 id="可拖拽小程序"><a href="#可拖拽小程序" class="headerlink" title="可拖拽小程序"></a>可拖拽小程序</h1><p>一、有赞和微盟这样的saas平台解决了什么问题：</p><p>1、没有研发资源，软件外包的价格又太贵，维护升级也很麻烦</p><p>2、没有推广经验，无法引流，获客成本高，运营成本高</p><p>3、客户管理，统计分析，解决方案</p><p>4、当然还有其他的，不列举了</p><p>二、实践</p><p>本次调研两个平台，微盟和有赞，基本可以代表托管式小程序的业界水平了，我主要尝试了拖拽组件生成H5，和小程序步骤是一样的，小程序还要申请和授权，上线还需要审核，太麻烦了</p><p>1、微盟</p><p>1.1、15天免费试用，年费模式，每年大概1万左右，免费使用店铺模板，不提供源代码，可额外付费推广，运营，接入第三方外送等服务，直接通过微信商户平台，微盟不参与商户的订单费用结算问题</p><p>1.2、建立自己的店铺，基本是都是需要店铺模板，比如电商，外卖，服饰，生鲜等等品类，如果你选择了某一类别，基本上只需要对这些模板的图片，价格，描述等属性进行维护就行了，因为包括商品展示页，详情页，购物车页，个人中心都是一整套，能提供的修改很少，也就改改一行几个的布局，颜色值等等</p><p><img src="/image/article/investigation/mini-program/27cb7283-4d8d-46f2-9ba1-60c8c28fdf28.png"></p><p><img src="/image/article/investigation/mini-program/997a59b0-3a6d-4417-b419-ab0f99585a4e.png"></p><p>1.3、如果不满意这些模板，需要自己定制化页面，我看了提供拖拽的组件库，那真是少得可怜，只有图片类型才能添加跳转链接，关键的button也没有啊，可以联系微盟定制化开发，具体价格看需求情况</p><p><img src="/image/article/investigation/mini-program/09cd7b91-8b61-4e7d-8dab-90da81bcdaea.png"></p><p>1.4、其实，如果没有定制化的需求，不考虑千篇一律的风格问题，这些默认的模板还挺好用的，改改基本属性就能上线了，</p><p>2、有赞</p><p>1、7天试用期，模板是收费的，30-90不等，年费6800.12800.26800不等，高价格的年费主要提供热力图分析，商品订单分析，推广分析等等BI的玩意儿</p><p>2、模式和微盟是一样的，基本不存在自定义页面的情况，要么购买模板，要么定制开发</p><p>三、总结</p><p>有赞和微盟基本上是一样的，如果不考虑定制化的需求，不考虑拓展，或者定制化成本可以接受，这些商城类的模板就能满足基本需求，因为面向的是普通小商户小企业，所以即使技术允许，也不太可能出现事件绑定，自定义事件这样的组件提供给用户，小商户只要配置页面，接入微信支付商户号就行了。</p>]]></content>
    
    
    <categories>
      
      <category>技术调研</category>
      
    </categories>
    
    
    <tags>
      
      <tag>weChat</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo博客系统搭建简易教程</title>
    <link href="/2020/08/08/other/start/"/>
    <url>/2020/08/08/other/start/</url>
    
    <content type="html"><![CDATA[<h3 id="博客系统搭建"><a href="#博客系统搭建" class="headerlink" title="博客系统搭建"></a>博客系统搭建</h3><p><a href="https://hexo.io/zh-cn/docs/">Hexo传送门</a></p><p>hexo博客系统可以部署在github上，写的md文件部署后全部转化为静态html文件，不需要服务器，实乃懒人穷鬼之首选</p><h4 id="安装node"><a href="#安装node" class="headerlink" title="安装node"></a>安装node</h4><p><del>过程略</del></p><h4 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h4><p><del>过程略</del></p><h4 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install -g hexo-cli<br></code></pre></td></tr></table></figure><p>用 hexo -v 查看一下版本</p><h4 id="初始化Hexo项目"><a href="#初始化Hexo项目" class="headerlink" title="初始化Hexo项目"></a>初始化Hexo项目</h4><p>找个合适的地方初始化项目  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo init [name] <br><span class="hljs-built_in">cd</span> [name] <br>yarn<br>hexo s <span class="hljs-comment">#本地运行</span><br></code></pre></td></tr></table></figure><p>至此，你的博客系统本地版本就完成了,你可以在source&#x2F;_posts下写文章，hexo s本地运行。<br>这时候你也可以选择生成静态文件，然后部署到自己的服务器上，生成静态文件命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo g<br></code></pre></td></tr></table></figure><h4 id="部署到github-可选"><a href="#部署到github-可选" class="headerlink" title="部署到github(可选)"></a>部署到github(可选)</h4><ul><li>注册github账号</li><li>添加ssh key</li><li>在github上新建项目 </li><li><em>注意你的项目名为 [username].github.io</em> 其中[username]是你github的账户名</li><li>配置本地项目发布地址,修改配置文件：项目根目录&#x2F;_config.yml<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">type</span>: git<br>repository: [gitUrl]   <span class="hljs-comment">#发布到github</span><br>branch: master<br></code></pre></td></tr></table></figure></li><li>推送文章上去<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo g  //生成静态部署文件<br>hexo d  //发布<br></code></pre></td></tr></table></figure>现在你可以用[username].github.io访问你的博客了</li></ul><h4 id="配置私有域名-可选"><a href="#配置私有域名-可选" class="headerlink" title="配置私有域名(可选)"></a>配置私有域名(可选)</h4><ul><li>首先你要买个域名</li><li>域名指向你github域名的ip</li><li>source文件夹下新建 CNAME 文件，没有后缀，里面写上你的域名(不需要带http:&#x2F;&#x2F;,示例: bestkele.com)</li><li>发布项目后，过一会你就可以通过自己的域名访问了(实际上就是通过域名访问了github静态项目的ip)</li></ul><h3 id="主题系统"><a href="#主题系统" class="headerlink" title="主题系统"></a>主题系统</h3><p>默认的hexo长得太丑了，我们需要一个好看的主题，这里我选择了next主题，还有很多其他的主题，可以自己去找找看，这里不做介绍了<br><a href="https://github.com/theme-next/hexo-theme-next.git">NEXT传送门</a><br>有一点注意的地方是，使用了next主题，项目的language配置要和theme&#x2F;next里面一致，没有用主题前中文是 zh-Hans ，next主题下是 zh-CN</p><h3 id="底部动漫插件"><a href="#底部动漫插件" class="headerlink" title="底部动漫插件"></a>底部动漫插件</h3><p><a href="https://github.com/EYHN/hexo-helper-live2d#readme">博客系统的灵魂</a></p><p>参考链接：<br><a href="https://www.cnblogs.com/liuxianan/p/build-blog-website-by-hexo-github.html">https://www.cnblogs.com/liuxianan/p/build-blog-website-by-hexo-github.html</a></p>]]></content>
    
    
    <categories>
      
      <category>随手记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Flutter mac安装笔记</title>
    <link href="/2020/08/05/flutter/flutter-mac/"/>
    <url>/2020/08/05/flutter/flutter-mac/</url>
    
    <content type="html"><![CDATA[<h1 id="flutter-mac安装笔记"><a href="#flutter-mac安装笔记" class="headerlink" title="flutter mac安装笔记"></a>flutter mac安装笔记</h1><p>1、设置环境变量</p><p>vim ~&#x2F;.bash_profile      进入编辑模式 i</p><p>由于在国内访问Flutter有时可能会受到限制，Flutter官方为中国开发者搭建了临时镜像，大家可以将如下环境变量加入到用户环境变量中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> PUB_HOSTED_URL=[https://pub](https://pub/).[flutter-io.cn](http://flutter-io.cn/)<br><br><span class="hljs-built_in">export</span> FLUTTER_STORAGE_BASE_URL=[https://storage](https://storage/).[flutter-io.cn](http://flutter-io.cn/)<br></code></pre></td></tr></table></figure><p>2、安装flutter</p><p>下载地址：<a href="https://flutter.dev/docs/development/tools/sdk/releases#macos">https://flutter.dev/docs/development/tools/sdk/releases#macos</a>   要翻墙</p><p>解压sdk到一个位置</p><p>添加flutter环境变量到path中,然后就报错了：</p><p>Error: The Flutter directory is not a clone of the GitHub project.</p><p>       The flutter tool requires Git in order to operate properly;</p><p>       to set up Flutter, run the following command:</p><p>       git clone -b beta <a href="https://github.com/flutter/flutter.git">https://github.com/flutter/flutter.git</a></p><p>尝试提示的解决方案：不过我下载了stable分支</p><p>git clone -b stable   <a href="https://github.com/flutter/flutter.git">https://github.com/flutter/flutter.git</a></p><p>配置环境变量：  export PATH&#x3D;&#x2F;Users&#x2F;kele&#x2F;Desktop&#x2F;workspace&#x2F;flutterSDK&#x2F;bin:$PATH</p><p>刷新当前窗口：source ~&#x2F;.bash_profile</p><p><strong>注意:</strong> 如果你使用的是zsh，终端启动时 ~&#x2F;.bash_profile 将不会被加载，解决办法就是修改 ~&#x2F;.zshrc ，在其中添加：source ~&#x2F;.bash_profile</p><p>SDK搞定</p><p>3、配置开发环境</p><p>flutter doctor</p><p>按照提示安装即可</p><p>安装AndroidStudio不用设置代理，也不用安装jdk，as是自带jdk的</p><p>参考链接：</p><p><a href="https://book.flutterchina.club/chapter1/install_flutter.html">https://book.flutterchina.club/chapter1/install_flutter.html</a></p>]]></content>
    
    
    <categories>
      
      <category>Flutter</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Flutter</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>eventLoop</title>
    <link href="/2020/07/19/concept/eventloop/"/>
    <url>/2020/07/19/concept/eventloop/</url>
    
    <content type="html"><![CDATA[<h1 id="宏任务和微任务"><a href="#宏任务和微任务" class="headerlink" title="宏任务和微任务"></a><strong>宏任务和微任务</strong></h1><p>在 JS 的异步代码中又区分 <strong>“宏任务(MacroTask)”</strong> 和 <strong>“微任务(MicroTask)”</strong></p><ul><li>宏任务：宏&#x2F;大的意思，可以理解为比较 <strong>费时</strong> 比较 <strong>慢</strong> 的任务</li><li>微任务：微&#x2F;小的意思，可以理解为相对没那么费时没那么慢的任务</li></ul><h1 id="常见的宏任务和微任务"><a href="#常见的宏任务和微任务" class="headerlink" title="常见的宏任务和微任务"></a><strong>常见的宏任务和微任务</strong></h1><ul><li>MacroTask：setTimeout、setInterval、setImmediate(IE独有) …</li><li>MicroTask：Promise、MutationObserver、process、nextTick(node独有) …</li></ul><p>注意点：所有的宏任务和微任务都会放到自己的执行队列中，也就是有一个 <strong>宏任务队列</strong> 和一个 <strong>微任务队列</strong>，所有放到队列中的任务都采用 **”先进先出原则”**，也就是多个任务同时满足条件，那么会先执行先放进去的</p><h1 id="完整执行顺序"><a href="#完整执行顺序" class="headerlink" title="完整执行顺序"></a><strong>完整执行顺序</strong></h1><ol><li>从上至下执行所有同步代码</li><li>执行微任务队列中所有任务</li><li>执行宏任务队列中的第一个</li><li>然后执行2,3,2,3如此往复直至结束</li></ol><p>注意点：</p><ul><li>每次执行宏任务都是去一个出来</li><li>每次执行微任务都是立刻清空</li><li>在执行过程中遇到宏任务就放到宏任务队列中，遇到微任务就放到微任务队列中，这个操作在每一步都可能遇到</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">a</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;a&#x27;</span>);        <br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;          <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;e&#x27;</span>);        <br>&#125;);        <br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;          <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;ee&#x27;</span>);        <br>&#125;);    <br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">b</span>(<span class="hljs-params"></span>) &#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;b&#x27;</span>);&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">c</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;c&#x27;</span>);      <br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;        <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;cc&#x27;</span>);      <br>&#125;);    <br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">d</span>(<span class="hljs-params"></span>) &#123;        <br><span class="hljs-title function_">setImmediate</span>(a);        <br><span class="hljs-keyword">var</span> temp = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>().<span class="hljs-title function_">then</span>(b);        <br><span class="hljs-built_in">setTimeout</span>(c, <span class="hljs-number">0</span>);        <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;d&#x27;</span>);    <br>&#125;    <br><span class="hljs-title function_">d</span>();<span class="hljs-comment">// d b a e ee c cc</span><br></code></pre></td></tr></table></figure><p>执行解析：</p><p>    1、遇到第一个setImmediate放入宏任务队列 【a】</p><p>    2、遇到promise 放入 微任务队列 【b】</p><p>    3、遇到第二个setTimeout放入宏任务队列 【a，c】</p><p>    4、输出：d，主js代码执行完毕</p><p>    5、读取微任务队列所有任务，输出 ：b</p><p>    6、读取宏任务队列，取出第一个【a】，输出：a，同时放入微任务队列：【e,  ee】</p><p>    7、读取微任务队列所有任务，输出 ：e    ee</p><p>    8、读取宏任务队列，取出第一个【c】，输出：c，同时放入微任务队列：【cc】</p><p>    9、读取微任务队列所有任务，输出 ： cc</p><p>    10、执行完毕</p><p>参考：</p><p><a href="https://www.jianshu.com/p/92f4506a28d0">https://www.jianshu.com/p/92f4506a28d0</a></p><p><a href="https://www.jianshu.com/p/1486afd81594">https://www.jianshu.com/p/1486afd81594</a></p><p><a href="https://www.cnblogs.com/BNTang/articles/15171676.html">https://www.cnblogs.com/BNTang/articles/15171676.html</a></p>]]></content>
    
    
    <categories>
      
      <category>概念知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>http</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>爬虫相关工具</title>
    <link href="/2020/06/05/concept/crawler/"/>
    <url>/2020/06/05/concept/crawler/</url>
    
    <content type="html"><![CDATA[<h1 id="爬虫相关工具"><a href="#爬虫相关工具" class="headerlink" title="爬虫相关工具"></a>爬虫相关工具</h1><p>1、最早的时候，我是用基本的 urllib.request 这种库请求网页，然后截取页面内容实现简单的爬虫</p><p>如果遇到需要填写输入框的页面就没用了</p><p>2、<strong>selenium 配合 无头浏览器</strong>  Phantomjs</p><p>Selenium是一个自动化测试的web应用程序，能做到用代码控制浏览器，比如表单填写，鼠标单击</p><p>拖拽，执行js脚本，截图等等，但是它需要借助WebDriver工具来实现</p><p>Phantomjs是一个无头浏览器，所谓无头就是代码控制浏览器访问数据，不需要显示出来，这样爬虫效率也高，内存消耗也低，Selenium+Phantomjs 配合就能实现自动化测试或者爬虫的完整步骤</p><p>3、 ChromeDriver新的无头浏览器</p><p>Phantomjs慢慢的不更新了，后来新版本的Selenium干脆抛弃了Phantomjs，不支持了，新的ChromeDriver</p><p>就成了替代品，区别是ChromeDriver提供了一个窗口，用来监控代码运行的事件，是完全模仿浏览器行为的</p><p>4、 Pyppeteer新的爬虫工具</p><p>Selenium+ChromeDriver模式运行起来，配置比较麻烦，运行效率也低，再则就是，这个模式运行了很多年，不少系统已经针对Selenium执行了反爬虫，新的替代品出现了，Pyppeteer，它配置起来相对简单，执行效率也高，虽然只支持 Chromium，但是也够用了。</p><p>Pyppeteer 其实是 Puppeteer 的 Python 版本，是个日本工程师维护的，而且更新的也慢，所以bug不少</p><p>5、 Puppeteer</p><p>Puppeteer是一个Node库，它提供了一个高级 API 来通过 DevTools 协议控制 Chromium 或 Chrome。Puppeteer 默认以 headless 模式运行，但是可以通过修改配置文件运行“有头”模式。</p><p>我们可以使用Puppeteer完成以下工作:</p><ul><li>访问页面，进行截图</li><li>找到页面元素，比如输入框，模拟键盘输入，提交表单</li><li>模拟点击等用户操作</li><li>等等等等。。</li></ul>]]></content>
    
    
    <categories>
      
      <category>概念知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>node</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTTP2.0的多路复用和HTTP1.X中的长连接复用区别</title>
    <link href="/2020/06/03/concept/http2-multip/"/>
    <url>/2020/06/03/concept/http2-multip/</url>
    
    <content type="html"><![CDATA[<h1 id="HTTP2-0的多路复用和HTTP1-X中的长连接复用区别"><a href="#HTTP2-0的多路复用和HTTP1-X中的长连接复用区别" class="headerlink" title="HTTP2.0的多路复用和HTTP1.X中的长连接复用区别"></a>HTTP2.0的多路复用和HTTP1.X中的长连接复用区别</h1><p>HTTP&#x2F;2</p><ul><li><strong>多路复用 (Multiplexing)</strong></li></ul><p>　　   <strong>多路复用允许同时通过单一的 HTTP&#x2F;2 连接发起多重的请求-响应消息</strong></p><p>HTTP1.1</p><p>在HTTP&#x2F;1.1协议中，浏览器客户端在同一时间，针对同一域名下的请求有一定数量限制，超过限制数目的请求会被阻塞。</p><p><strong>HTTP2.0的多路复用和HTTP1.X中的长连接复用有什么区别？</strong></p><p><strong>也可以参考这个：<a href="https://blog.csdn.net/ywlmsm1224811/article/details/96436768">https://blog.csdn.net/ywlmsm1224811/article/details/96436768</a></strong></p><ul><li>HTTP&#x2F;1.* 一次请求-响应，建立一个tcp连接，用完关闭；每一个请求都要建立一个tcp连接；</li><li>HTTP&#x2F;1.1 Pipeling解决方式为，若干个请求排队串行化单线程处理，后面的请求等待前面请求的返回才能获得执行机会，一旦有某请求超时等，后续请求只能被阻塞，毫无办法，也就是人们常说的线头阻塞；</li><li>HTTP&#x2F;2多个请求可同时在一个连接上并行执行。某个请求任务耗时严重，不会影响到其它连接的正常执行；具体如图：</li></ul><p><img src="/image/article/concept/http2-multip/1493082-20190303211213148-428756405.png"></p><p>服务器推送到底是什么？服务端推送能把客户端所需要的资源伴随着index.html一起发送到客户端，省去了客户端重复请求的步骤。正因为没有发起请求，建立连接等操作，所以静态资源通过服务端推送的方式可以极大地提升速度。具体如下：</p><ul><li>普通的客户端请求过程：</li></ul><p><img src="/image/article/concept/http2-multip/1493082-20190303211355113-178632955.png"></p><p>服务端推送的过程：</p><p><img src="/image/article/concept/http2-multip/1493082-20190303211414420-646862516.png"></p><p><strong>为什么需要头部压缩？</strong>假定一个页面有100个资源需要加载（这个数量对于今天的Web而言还是挺保守的）, 而每一次请求都有1kb的消息头（这同样也并不少见，因为Cookie和引用等东西的存在）, 则至少需要多消耗100kb来获取这些消息头。HTTP2.0可以维护一个字典，差量更新HTTP头部，大大降低因头部传输产生的流量。具体参考：HTTP&#x2F;2 头部压缩技术介绍</p><p><strong>HTTP2.0多路复用有多好？</strong>HTTP 性能优化的关键并不在于高带宽，而是低延迟。TCP 连接会随着时间进行自我「调谐」，起初会限制连接的最大速度，如果数据成功传输，会随着时间的推移提高传输的速度。这种调谐则被称为 TCP 慢启动。由于这种原因，让原本就具有突发性和短时性的 HTTP 连接变的十分低效。HTTP&#x2F;2 通过让所有数据流共用同一个连接，可以更有效地使用 TCP 连接，让高带宽也能真正的服务于 HTTP 的性能提升。</p><p>参考链接：</p><p><a href="https://www.cnblogs.com/Paul-watermelon/p/10467662.html">https://www.cnblogs.com/Paul-watermelon/p/10467662.html</a></p>]]></content>
    
    
    <categories>
      
      <category>概念知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>http</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTTP2.0和HTTP1.0的区别</title>
    <link href="/2020/06/02/concept/http2/"/>
    <url>/2020/06/02/concept/http2/</url>
    
    <content type="html"><![CDATA[<h1 id="http2"><a href="#http2" class="headerlink" title="http2"></a>http2</h1><h3 id="http1存在的问题："><a href="#http1存在的问题：" class="headerlink" title="http1存在的问题："></a>http1存在的问题：</h3><p> 1、TCP连接数限制</p><p>对于同一个域名，浏览器最多只能同时创建 6~8 个 TCP 连接 (不同浏览器不一样)。为了解决数量限制，出现了 域名分片 技术，其实就是资源分域，将资源放在不同域名下 (比如二级子域名下)，这样就可以针对不同域名创建连接并请求，以一种讨巧的方式突破限制，但是滥用此技术也会造成很多问题，比如每个 TCP 连接本身需要经过 DNS 查询、三步握手、慢启动等，还占用额外的 CPU 和内存，对于服务器来说过多连接也容易造成网络拥挤、交通阻塞等，对于移动端来说问题更明显，可以参考这篇文章: <a href="http://dev.mobify.com/blog/domain-sharding-bad-news-mobile-performance/">Why Domain Sharding is Bad News for Mobile Performance and Users</a></p><p>2、线头阻塞 (Head Of Line Blocking) <strong>问题</strong></p><p>每个 TCP 连接同时只能处理一个请求 - 响应，浏览器按 FIFO 原则处理请求，如果上一个响应没返回，后续请求 - 响应都会受阻。为了解决此问题，出现了管线化-pipelining技术，但是管线化存在诸多问题，比如第一个响应慢还是会阻塞后续响应、服务器为了按序返回相应需要缓存多个响应占用更多资源、浏览器中途断连重试服务器可能得重新处理多个请求、还有必须客户端 - 代理 - 服务器都支持管线化</p><p>3、Header 内容多，而且每次请求 Header 不会变化太多，没有相应的压缩传输优化方案</p><p>4、为了尽可能减少请求数，需要做合并文件、雪碧图、资源内联等优化工作，但是这无疑造成了单个请求内容变大延迟变高的问题，且内嵌的资源不能有效地使用缓存机制</p><h3 id="HTTP2-的优势"><a href="#HTTP2-的优势" class="headerlink" title="HTTP2 的优势:"></a><strong>HTTP2 的优势:</strong></h3><p><strong>1、二进制分帧层 (Binary Framing Layer)</strong></p><p>帧是数据传输的最小单位，以二进制传输代替原本的明文传输，原本的报文消息被划分为更小的数据帧:</p><p><strong>2、多路复用 (MultiPlexing)</strong></p><p>在一个 TCP 连接上，我们可以向对方不断发送帧，每帧的 stream identifier 的标明这一帧属于哪个流，然后在对方接收时，根据 stream identifier 拼接每个流的所有帧组成一整块数据。</p><p>把 HTTP&#x2F;1.1 每个请求都当作一个流，那么多个请求变成多个流，请求响应数据分成多个帧，不同流中的帧交错地发送给对方，这就是 HTTP&#x2F;2 中的多路复用。</p><p>流的概念实现了单连接上多请求 - 响应并行，解决了线头阻塞的问题，减少了 TCP 连接数量和 TCP 连接慢启动造成的问题</p><p>所以 http2 对于同一域名只需要创建一个连接，而不是像 http&#x2F;1.1 那样创建 6~8 个连接:</p><p><strong>3、服务端推送 (Server Push)</strong></p><p>浏览器发送一个请求，服务器主动向浏览器推送与这个请求相关的资源，这样浏览器就不用发起后续请求。</p><p>4、Header 压缩 (HPACK)</p><p>使用 HPACK 算法来压缩首部内容</p><p>5、应用层的重置连接</p><p>对于 HTTP&#x2F;1 来说，是通过设置 tcp segment 里的 reset flag 来通知对端关闭连接的。这种方式会直接断开连接，下次再发请求就必须重新建立连接。HTTP&#x2F;2 引入 RST_STREAM 类型的 frame，可以在不断开连接的前提下取消某个 request 的 stream，表现更好。</p><p>6、请求优先级设置</p><p>HTTP&#x2F;2 里的每个 stream 都可以设置依赖 (Dependency) 和权重，可以按依赖树分配优先级，解决了关键请求被阻塞的问题</p><p>7、流量控制</p><p>每个 http2 流都拥有自己的公示的流量窗口，它可以限制另一端发送数据。对于每个流来说，两端都必须告诉对方自己还有足够的空间来处理新的数据，而在该窗口被扩大前，另一端只被允许发送这么多数据。</p><p>8、HTTP&#x2F;1 的几种优化可以弃用</p><p>合并文件、内联资源、雪碧图、域名分片对于 HTTP&#x2F;2 来说是不必要的，使用 h2 尽可能将资源细粒化，文件分解地尽可能散，不用担心请求数多</p><p>参考链接：</p><p><a href="https://www.jianshu.com/p/e57ca4fec26f">https://www.jianshu.com/p/e57ca4fec26f</a></p>]]></content>
    
    
    <categories>
      
      <category>概念知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>http</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Https原理及流程</title>
    <link href="/2020/06/02/concept/Https-principle/"/>
    <url>/2020/06/02/concept/Https-principle/</url>
    
    <content type="html"><![CDATA[<h1 id="Https原理及流程"><a href="#Https原理及流程" class="headerlink" title="Https原理及流程"></a><strong>Https原理及流程</strong></h1><p>我们知道，HTTP请求都是明文传输的，所谓的明文指的是没有经过加密的信息，如果HTTP请求被黑客拦截，并且里面含有银行卡密码等敏感数据的话，会非常危险。为了解决这个问题，Netscape 公司制定了HTTPS协议，HTTPS可以将数据加密传输，也就是传输的是密文，即便黑客在传输过程中拦截到数据也无法破译，这就保证了网络通信的安全。</p><h2 id="密码学基础"><a href="#密码学基础" class="headerlink" title="密码学基础"></a><strong>密码学基础</strong></h2><p>在正式讲解HTTPS协议之前，我们首先要知道一些密码学的知识。</p><p><strong>明文</strong>： 明文指的是未被加密过的原始数据。</p><p><strong>密文</strong>：明文被某种加密算法加密之后，会变成密文，从而确保原始数据的安全。密文也可以被解密，得到原始的明文。</p><p><strong>密钥</strong>：密钥是一种参数，它是在明文转换为密文或将密文转换为明文的算法中输入的参数。密钥分为对称密钥与非对称密钥，分别应用在对称加密和非对称加密上。</p><p><strong>对称加密</strong>：对称加密又叫做私钥加密，即信息的发送方和接收方使用同一个密钥去加密和解密数据。对称加密的特点是算法公开、加密和解密速度快，适合于对大数据量进行加密，常见的对称加密算法有DES、3DES、TDEA、Blowfish、RC5和IDEA。</p><p>其加密过程如下：<strong>明文 + 加密算法 + 私钥 &#x3D;&gt; 密文</strong></p><p>解密过程如下： <strong>密文 + 解密算法 + 私钥 &#x3D;&gt; 明文</strong></p><p>对称加密中用到的密钥叫做私钥，私钥表示个人私有的密钥，即该密钥不能被泄露。</p><p>其加密过程中的私钥与解密过程中用到的私钥是同一个密钥，这也是称加密之所以称之为“对称”的原因。由于对称加密的算法是公开的，所以一旦私钥被泄露，那么密文就很容易被破解，所以对称加密的缺点是密钥安全管理困难。</p><p><strong>非对称加密</strong>：非对称加密也叫做公钥加密。非对称加密与对称加密相比，其安全性更好。对称加密的通信双方使用相同的密钥，如果一方的密钥遭泄露，那么整个通信就会被破解。而非对称加密使用一对密钥，即公钥和私钥，且二者成对出现。私钥被自己保存，不能对外泄露。公钥指的是公共的密钥，任何人都可以获得该密钥。用公钥或私钥中的任何一个进行加密，用另一个进行解密。</p><p>被公钥加密过的密文只能被私钥解密，过程如下：</p><p><strong>明文 + 加密算法 + 公钥 &#x3D;&gt; 密文， 密文 + 解密算法 + 私钥 &#x3D;&gt; 明文</strong></p><p>被私钥加密过的密文只能被公钥解密，过程如下：</p><p><strong>明文 + 加密算法 + 私钥 &#x3D;&gt; 密文， 密文 + 解密算法 + 公钥 &#x3D;&gt; 明文</strong></p><p>由于加密和解密使用了两个不同的密钥，这就是非对称加密“非对称”的原因。</p><p>非对称加密的缺点是加密和解密花费时间长、速度慢，只适合对少量数据进行加密。</p><p>在非对称加密中使用的主要算法有：RSA、Elgamal、Rabin、D-H、ECC（椭圆曲线加密算法）等。</p><h2 id="HTTPS通信过程"><a href="#HTTPS通信过程" class="headerlink" title="HTTPS通信过程"></a><strong>HTTPS通信过程</strong></h2><p><strong>HTTPS协议 &#x3D; HTTP协议 + SSL&#x2F;TLS协议</strong>，在HTTPS数据传输的过程中，需要用SSL&#x2F;TLS对数据进行加密和解密，需要用HTTP对加密后的数据进行传输，由此可以看出HTTPS是由HTTP和SSL&#x2F;TLS一起合作完成的。</p><p>SSL的全称是Secure Sockets Layer，即安全套接层协议，是为网络通信提供安全及数据完整性的一种安全协议。SSL协议在1994年被Netscape发明，后来各个浏览器均支持SSL，其最新的版本是3.0</p><p>TLS的全称是Transport Layer Security，即安全传输层协议，最新版本的TLS（Transport Layer Security，传输层安全协议）是IETF（Internet Engineering Task Force，Internet工程任务组）制定的一种新的协议，它建立在SSL 3.0协议规范之上，是SSL 3.0的后续版本。在TLS与SSL3.0之间存在着显著的差别，主要是它们所支持的加密算法不同，所以TLS与SSL3.0不能互操作。虽然TLS与SSL3.0在加密算法上不同，但是在我们理解HTTPS的过程中，我们可以把SSL和TLS看做是同一个协议。</p><p>HTTPS为了兼顾安全与效率，同时使用了对称加密和非对称加密。数据是被对称加密传输的，对称加密过程需要客户端的一个密钥，为了确保能把该密钥安全传输到服务器端，采用非对称加密对该密钥进行加密传输，总的来说，对数据进行对称加密，对称加密所要使用的密钥通过非对称加密传输。</p><p><strong>HTTPS在传输的过程中会涉及到三个密钥：</strong></p><p>服务器端的公钥和私钥，用来进行非对称加密</p><p>客户端生成的随机密钥，用来进行对称加密</p><p>一个HTTPS请求实际上包含了两次HTTP传输，可以细分为8步。</p><p>1.客户端向服务器发起HTTPS请求，连接到服务器的443端口</p><p>2.服务器端有一个密钥对，即公钥和私钥，是用来进行非对称加密使用的，服务器端保存着私钥，不能将其泄露，公钥可以发送给任何人。</p><p>3.服务器将自己的公钥发送给客户端。</p><p>4.客户端收到服务器端的证书之后，会对证书进行检查，验证其合法性，如果发现发现证书有问题，那么HTTPS传输就无法继续。严格的说，这里应该是验证服务器发送的数字证书的合法性，关于客户端如何验证数字证书的合法性，下文会进行说明。如果公钥合格，那么客户端会生成一个随机值，这个随机值就是用于进行对称加密的密钥，我们将该密钥称之为client key，即客户端密钥，这样在概念上和服务器端的密钥容易进行区分。然后用服务器的公钥对客户端密钥进行非对称加密，这样客户端密钥就变成密文了，至此，HTTPS中的第一次HTTP请求结束。</p><p>5.客户端会发起HTTPS中的第二个HTTP请求，将加密之后的客户端密钥发送给服务器。</p><p>6.服务器接收到客户端发来的密文之后，会用自己的私钥对其进行非对称解密，解密之后的明文就是客户端密钥，然后用客户端密钥对数据进行对称加密，这样数据就变成了密文。</p><p>7.然后服务器将加密后的密文发送给客户端。</p><p>8.客户端收到服务器发送来的密文，用客户端密钥对其进行对称解密，得到服务器发送的数据。这样HTTPS中的第二个HTTP请求结束，整个HTTPS传输完成。</p><p>参考链接：</p><p><a href="https://www.jianshu.com/p/14cd2c9d2cd2">https://www.jianshu.com/p/14cd2c9d2cd2</a></p>]]></content>
    
    
    <categories>
      
      <category>概念知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>https</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Flutter android打包自定义jks</title>
    <link href="/2019/12/20/flutter/flutter-android-jks/"/>
    <url>/2019/12/20/flutter/flutter-android-jks/</url>
    
    <content type="html"><![CDATA[<h1 id="flutter-android-打包自定义jks"><a href="#flutter-android-打包自定义jks" class="headerlink" title="flutter android 打包自定义jks"></a>flutter android 打包自定义jks</h1><p>flutter android 打包直接生成了apk，我需要一个自己的jks</p><p>1、把keytool放在环境变量中</p><p>执行 flutter doctor -v</p><p><img src="/image/article/flutter/flutter-android-jks/6054f5ed-252d-4888-8f8e-1f86e7143e84.png"></p><p>这个路径里面的jre&#x2F;bin里面就是keytool.exe</p><p>2、生成key</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">keytool -genkey -v -keystore crpm-release-key.jks -<span class="hljs-built_in">alias</span> crpm -keyalg RSA -keysize 2048 -validity 10000<br></code></pre></td></tr></table></figure><p><img src="/image/article/flutter/flutter-android-jks/130526be-df53-4182-af26-2fa8c8272b27.png"></p><p>导出的路径就是运行的路径，现在是在 C:\Users\kele</p><p>3、把jks放在android&#x2F;app文件夹下</p><p>4、在android文件夹下新建文件key.properties    配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">storePassword=123456<br>keyPassword=123456<br>keyAlias=crpm<br>storeFile=crpm-release-key.jks<br></code></pre></td></tr></table></figure><p>5、配置jks引用</p><p>&#x2F;android&#x2F;app&#x2F;build.gradle文件，在android {  这一行前面,加入如下代码： </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">def keystorePropertiesFile = rootProject.file(<span class="hljs-string">&quot;key.properties&quot;</span>)<br>def keystoreProperties = new Properties()<br>keystoreProperties.load(new FileInputStream(keystorePropertiesFile))<br></code></pre></td></tr></table></figure><p>将下面的代码</p><p>buildTypes{</p><p>    ……..</p><p>}</p><p>这一段换成：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash">signingConfigs &#123;<br>    release &#123;<br>        keyAlias keystoreProperties[<span class="hljs-string">&#x27;keyAlias&#x27;</span>]<br>        keyPassword keystoreProperties[<span class="hljs-string">&#x27;keyPassword&#x27;</span>]<br>        storeFile file(keystoreProperties[<span class="hljs-string">&#x27;storeFile&#x27;</span>])<br>        storePassword keystoreProperties[<span class="hljs-string">&#x27;storePassword&#x27;</span>]<br>    &#125;<br>&#125;<br>buildTypes &#123;<br>    release &#123;<br>        signingConfig signingConfigs.release<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>6、打包</p><p>flutter  build  apk</p><p>7、获取签名md5</p><p>keytool -list -v -keystore  &lt;jks路径&gt;</p><p>参考链接：</p><p><a href="https://blog.csdn.net/weixin_44567104/article/details/90377912">https://blog.csdn.net/weixin_44567104&#x2F;article&#x2F;details&#x2F;90377912</a></p><p><a href="https://www.cnblogs.com/details-666/p/signature.html">https://www.cnblogs.com/details-666/p/signature.html</a></p>]]></content>
    
    
    <categories>
      
      <category>Flutter</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>Flutter</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Flutter所需依赖包下载不了</title>
    <link href="/2019/11/13/flutter/flutter-dependent/"/>
    <url>/2019/11/13/flutter/flutter-dependent/</url>
    
    <content type="html"><![CDATA[<h1 id="Flutter所需依赖包安装不上"><a href="#Flutter所需依赖包安装不上" class="headerlink" title="Flutter所需依赖包安装不上"></a>Flutter所需依赖包安装不上</h1><p>我只在android项目遇到了问题</p><p>flutter安装需要的依赖包怎么也安装不上，连接超时</p><p>1、在  android–》build.gradle 文件中 把google()和maven()源改掉，有两处</p><p>maven{ url ‘<a href="http://maven.aliyun.com/nexus/content/groups/public/">http://maven.aliyun.com/nexus/content/groups/public/</a>‘ }</p><p>maven{ url ‘<a href="https://maven.aliyun.com/repository/google">https://maven.aliyun.com/repository/google</a>‘ }</p><p>maven{ url ‘<a href="https://maven.aliyun.com/repository/jcenter">https://maven.aliyun.com/repository/jcenter</a>‘ }</p><p>mavenCentral()</p><p>google()</p><p>2、多下载几次，最后，实在不行就</p><p>手动下载依赖包放在cache的对应包版本中（前一段是你电脑的gradle目录）</p><p>目录：C:\Users\kele.gradle\caches\modules-2\files-2.1</p><p>tips:<br>最好使用flutter稳定版：</p><p>flutter channel</p><p>flutter channel stable</p>]]></content>
    
    
    <categories>
      
      <category>Flutter</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Flutter</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Flutter的两种编译模式</title>
    <link href="/2019/10/23/flutter/flutter-compiler/"/>
    <url>/2019/10/23/flutter/flutter-compiler/</url>
    
    <content type="html"><![CDATA[<h1 id="Flutter-的两种编译模式"><a href="#Flutter-的两种编译模式" class="headerlink" title="Flutter 的两种编译模式"></a>Flutter 的两种编译模式</h1><p>使用 Flutter 构建过 App 的人一定有一个困惑，就是 Flutter 编译出的产物到底是什么玩意。有时候分为几个文件，有时候是一个动态库，真的叫人摸不着头脑。</p><p>本文详细解释一下 Flutter 的编译模式。</p><hr><h3 id="编译模式的分类"><a href="#编译模式的分类" class="headerlink" title="编译模式的分类"></a><strong>编译模式的分类</strong></h3><p>编程语言要达到可运行的目的需要经过编译，一般地来说，编译模式分为两类：JIT 和 AOT。</p><p><strong>JIT</strong></p><p>JIT 全称 Just In Time (即时编译），典型的例子就是 v8，它可以即时编译并运行 JavaScript。所以你只需要输入源代码字符串，v8 就可以帮你编译并运行代码。通常来说，支持 JIT 的语言一般能够支持自省函数（eval），在运行时动态地执行代码。</p><p>JIT 模式的优势是显而易见的，可以动态下发和执行代码，而不用管用户的机器是什么架构，为应用的用户提供丰富而动态地内容。</p><p>但 JIT 的劣势也是显而易见的，大量字符串的代码很容易让 JIT 编译器花费很多时间和内存进行编译，给用户带来的直接感受就是应用启动慢。</p><p><strong>AOT</strong></p><p>AOT 全称 Ahead Of Time（事前编译），典型的例子就是 C&#x2F;C++，LLVM 或 GCC 通过编译并生成 C&#x2F;C++ 的二进制代码，然后这些二进制通过用户安装并取得执行权限后才可以通过进程加载执行。</p><p>AOT 的优势也是显而易见的，事先编译好的二进制代码，加载和执行的速度都会非常快。（所以编程语言速度排行榜上前列都是 AOT 编译类语言）这样的速度可以在密集计算场景下给用户带来非常好的体验，比如大型游戏的引擎渲染和逻辑执行。</p><p>但是 AOT 的劣势也是显而易见的，编译需要区分用户机器的架构，生成不同架构的二进制代码。除了架构，二进制代码本身也会让用户下载的安装包比较大。二进制代码一般需要取得执行权限才可以执行，所以无法在权限比较严格的系统中进行动态更新（如 iOS）。</p><hr><h3 id="Dart的编译模式"><a href="#Dart的编译模式" class="headerlink" title="Dart的编译模式"></a><strong>Dart的编译模式</strong></h3><p>Flutter 使用 Dart 作为编程语言，自然其编译模式也脱离不了 Dart 的干系。首先我们需要了解一下 Dart 所支持的编译模式。</p><p>Script：最普通的 JIT 模式，在 PC 命令行调用 Dart VM 执行 Dart 源代码文件即是这种模式；</p><p>Script Snapshot：JIT 模式，和上一个不同的是，这里载入的是已经 token 化的 Dart 源代码，提前执行了上一步的</p><p>lexer 步骤；</p><p>Application Snapshot：JIT 模式，这种模式来源于 Dart VM 直接载入源码后 dump 出数据。Dart VM</p><p>通过这种数据启动会更快。不过值得一提的是这种模式是区分架构的，在 x64 上生成的数据不可以给 arm 使用;</p><p>AOT：AOT模式，直接将 Dart 源码编译出 .S 文件，然后通过汇编器生成对应架构的代码。</p><p>总结一下刚才的列表，可以发现：</p><p><img src="/image/article/flutter/flutter-compiler/1.jpeg"></p><hr><h3 id="Flutter的编译模式"><a href="#Flutter的编译模式" class="headerlink" title="Flutter的编译模式"></a><strong>Flutter的编译模式</strong></h3><p>Flutter 完全采用了 Dart，按道理来说编译模式一致才是，但是事实并不是这样。由于 Android 和 iOS平台的生态差异，Flutter 也衍生出了非常丰富的编译模式。</p><p>Script：同 Dart Script 模式一致，虽然 Flutter 支持，但暂未看到使用，毕竟影响启动速度；</p><p>Script Snapshot：同 Dart Script Snapshot 一致，同样支持但未使用，Flutter</p><p>有大量的视图渲染逻辑，纯 JIT 模式影响执行速度；</p><p>Kernel Snapshot：Dart 的 bytecode模式，与 Application Snapshot 不同，bytecode</p><p>模式是不区分架构的。Kernel Snapshot 在 Flutter 项目内也叫 Core Snapshot。bytecode模式可以归类为 AOT 编译；</p><p>Core JIT：Dart 的一种二进制模式，将指令代码和 heap 数据打包成文件，然后在 VM 和 isolate</p><p>启动时载入，直接标记内存可执行，可以说这是一种 AOT 模式。Core JIT 也被叫做 AOTBlob；</p><p>AOT Assembly: 即 Dart 的 AOT 模式。直接生成汇编源代码文件，由各平台自行汇编。</p><p>可以看出来，Flutter 将 Dart 的编译模式复杂化了，多了不少概念，要一下叙述清楚是比较困难的，所以我们着重从 Flutter 应用开发的各个阶段来解读。</p><hr><h3 id="开发阶段的编译模式"><a href="#开发阶段的编译模式" class="headerlink" title="开发阶段的编译模式"></a><strong>开发阶段的编译模式</strong></h3><p>在开发阶段，我们需要 Flutter 的 Hot Reload 和 Hot Restart 功能，方便 UI 快速成型。同时，框架层也需要比较高的性能来进行视图渲染展现。因此开发模式下，Flutter 使用了 Kernel Snapshot 模式编译。</p><p>在打包产物中，你将发现几样东西：</p><p>isolate_snapshot_data：用于加速 isolate 启动，业务无关代码，固定，仅和 flutter engine</p><p>版本有关；</p><p>platform.dill：和 Dart VM 相关的 kernel 代码，仅和 Dart 版本以及 engine</p><p>编译版本有关。固定，业务无关代码；</p><p>vm_snapshot_data: 用于加速 Dart VM 启动的产物，业务无关代码，仅和 flutter engine 版本有关；</p><p>kernel_blob.bin：业务代码产物</p><p><img src="/image/article/flutter/flutter-compiler/2.jpeg"></p><hr><h3 id="生产阶段的编译模式"><a href="#生产阶段的编译模式" class="headerlink" title="生产阶段的编译模式"></a><strong>生产阶段的编译模式</strong></h3><p>在生产阶段，应用需要的是非常快的速度，所以 Android 和 iOS target 毫无意外地都选择了 AOT 打包。不过由于平台特性不同，打包模式也是天壤之别。</p><p><img src="/image/article/flutter/flutter-compiler/3.jpeg"></p><p>首先我们很容易认识到 iOS 平台上做法的原因：App Store 审核条例不允许动态下发可执行二进制代码。</p><p>所以在 iOS 上，除了 JavaScript，其他语言运行时的实现都选择了 AOT（比如 OpenJDK 在 iOS 实现就是 AOT）。</p><p>在 Android 上，Flutter 的做法有点意思：支持了两种不同的路子。</p><p>Core JIT 的打包产物有 4 个：isolate_snapshot_data、vm_snapshot_data、isolate_snapshot_instr、vm_snapshot_instr。我们不认识的产物只有 2 个：isolate_snapshot_instr 和 vm_snapshot_instr，其实它俩代表着 VM 和 isolate 启动后所承载的指令等数据。在载入后，直接将该块内存执行即可。</p><p>Android 的 AOT Assembly 打包方式很容易让人想到需要支持多架构，无疑增大了代码包，并且该处代码需要从 JNI 调用，远不如 Core JIT 的 Java API 方便。所以 Android 上默认使用 Core JIT 打包，而不是 AOT Assembly。</p><hr><h3 id="Flutter-Engine-对编译模式的支持"><a href="#Flutter-Engine-对编译模式的支持" class="headerlink" title="Flutter Engine 对编译模式的支持"></a><strong>Flutter Engine 对编译模式的支持</strong></h3><p>在我的上篇文章：Flutter原理简解 中提到，Engine 承载了 Dart 运行时，毫无疑问 Engine 需要和打包出来的代码对的上号才行。</p><p>在 Engine 的编译模式中，Flutter 是这样选择的：</p><p><img src="/image/article/flutter/flutter-compiler/4.jpeg"></p><p>所以我们可以看到，Flutter 的编译模式是完全根据 Engine 的支持度来设计的。</p><hr><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a><strong>结论</strong></h3><p>Flutter 是一种高性能的、可跨平台的、动态化应用开发方案。</p><p>在 iOS 和 Android 平台上，动态化完全可由 Kernel Snapshot 打包实现，并且产物是一致通用的。不过目前通过打包工具进行了阉割，只能生成 debug 产物。</p><p>并且如果不需要动态化，同样可以打包出拥有更高执行性能的二进制库文件使用。这个特性目前就已经支持，有了理论的支持，我们就可以着手做改造的事了。</p><p>原文链接：</p><p><a href="https://blog.csdn.net/u010960265/article/details/81361711">https://blog.csdn.net/u010960265/article/details/81361711</a></p>]]></content>
    
    
    <categories>
      
      <category>Flutter</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Flutter</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>为什么说Flutter是革命性的</title>
    <link href="/2019/10/22/flutter/flutter-revolution/"/>
    <url>/2019/10/22/flutter/flutter-revolution/</url>
    
    <content type="html"><![CDATA[<h1 id="为什么说Flutter是革命性的？"><a href="#为什么说Flutter是革命性的？" class="headerlink" title="为什么说Flutter是革命性的？"></a>为什么说Flutter是革命性的？</h1><p><strong>Flutter 是什么？</strong></p><p>Flutter 移动应用程序 SDK 是为开发人员提供一种创建快捷、美观的应用程序的新方式，从而摆脱过去那种千篇一律的 app，尝试过 Flutter 的人都会真的爱上它。</p><p>与任何新系统一样，用户想知道 Flutter 有什么与众不同之处，“Flutter 有什么新的或者令人兴奋的东西吗？”，这是一个合理的问题，本文将从技术的角度回答 Flutter 有什么东西让人兴奋，而且给出它为什么让人兴奋的原因。</p><p>但首先，先讲一小段历史。</p><p><strong>移动开发的简史</strong></p><p>移动开发是一个较新的领域，开发者们开始涉足移动开发时间尚不足十年，所以移动开发的工具仍然在发展当中，这并不奇怪。</p><p>OEM SDKs</p><p>苹果的 iOS SDKs 发布于 2008 年，谷歌的 Android 软件开发工具包发布于 2009 年，这两种工具包基于不同的编程语言，分别是 Objective-C 和 Java。</p><p><a href="https://upload-images.jianshu.io/upload_images/5676002-a2198197cce08f8d?imageMogr2/auto-orient/strip%7CimageView2/2/w/524/format/webp">https://upload-images.jianshu.io/upload_images&#x2F;5676002-a2198197cce08f8d?imageMogr2&#x2F;auto-orient&#x2F;strip|imageView2&#x2F;2&#x2F;w&#x2F;524&#x2F;format&#x2F;webp</a></p><p>通过这些 SDK，你的应用可以与系统通信，以创建 UI 组件或访问系统相机。这些组件被渲染到手机屏幕，而相应的事件则被传回给组件。这个架构足够简单，但你仍然不得不为每个平台开发单独的 App，因为这些系统组件都是不一样的，更不用提开发语言的不同了。</p><p>WebView</p><p>第一个跨平台的框架基于 JavaScript 和 WebView，例如 Titanium 和 一系列相关的框架：PhoneGap, Apache Cordova, Ionic 等，在苹果发布 iOS 之前，他们鼓励第三方开发者为 iPhone 构建网页应用程序，因此使用 Web 技术构建跨平台应用程序是顺理成章的一步。</p><p><a href="https://upload-images.jianshu.io/upload_images/5676002-14e487d96768657a?imageMogr2/auto-orient/strip%7CimageView2/2/w/631/format/webp">https://upload-images.jianshu.io/upload_images&#x2F;5676002-14e487d96768657a?imageMogr2&#x2F;auto-orient&#x2F;strip|imageView2&#x2F;2&#x2F;w&#x2F;631&#x2F;format&#x2F;webp</a></p><p>你的应用程序可以创建 HTML 并将其显示在平台的 WebViews 上，请注意像 JavaScript 这样的语言很难直接与本地代码（例如服务）进行通信，因此他们会通过一个在 JavaScript 代码和原生代码的“桥梁”进行上下文切换，因为平台服务通常不会经常被调用，所以这并不会导致太大的性能问题。</p><p>响应式视图</p><p>像 ReactJS 或 其他 的响应式编程框架已经变得很流行了，主要是因为他们通过使用从响应式编程中借用的编程模式来简化 Web 视图的创建过程。2015 年， React Native 将响应式视图的许多优势带给了移动应用程序。</p><p><a href="https://upload-images.jianshu.io/upload_images/5676002-ec3f3cef6b1932b1?imageMogr2/auto-orient/strip%7CimageView2/2/w/630/format/webp">https://upload-images.jianshu.io/upload_images&#x2F;5676002-ec3f3cef6b1932b1?imageMogr2&#x2F;auto-orient&#x2F;strip|imageView2&#x2F;2&#x2F;w&#x2F;630&#x2F;format&#x2F;webp</a></p><p>React Native 是非常受欢迎的（这是它应得的），但是因为 JavaScript 访问了原生 UI 组件，所以它也必须经过这些“桥接器”，界面上的 UI 控件通常被频繁地访问（在动画、转化或者用户用手指“滑动”屏幕上的某些东西时，每秒被访问高达 60 次），因此这很可能会导致性能问题。正如 关于 React Native 的一篇文章 所说：</p><p>这是理解 React Native 性能的其中一个关键，JS 代码和原生代码本身都是很快的，瓶颈经常发生在当我们视图从一边转向另一边时。未来构建高质量的应用程序时，我们必须将使用桥接的次数控制到最小。</p><p>Flutter</p><p>和 React Native 一样，Flutter 也提供响应式的视图，Flutter 采用不同的方法避免由 JavaScript 桥接器引起的性能问题，即用名为 Dart 的程序语言来编译。Dart 是用预编译的方式编译多个平台的原生代码，这允许 Flutter 直接与平台通信，而不需要通过执行上下文切换的 JavaScript 桥接器。编译为原生代码也可以加快应用程序的启动时间。</p><p>实际上，Flutter 是唯一提供响应式视图而不需要 JavaScript 桥接器的移动 SDK，这就足以让 Fluttter 变得有趣而值得一试，但 Flutter 还有一些革命性的东西，即它是如何实现 UI 组件的？</p><p>组件（Widgets）</p><p>Widgets 是影响和控制应用程序的视图和界面的元素，说这些组件是移动应用中最重要的部分之一，这并不夸张，事实上，UI 表现如何，可以成就或毁掉一款 App。</p><p><a href="https://upload-images.jianshu.io/upload_images/5676002-fec98d333436e5da?imageMogr2/auto-orient/strip%7CimageView2/2/w/211/format/webp">https://upload-images.jianshu.io/upload_images&#x2F;5676002-fec98d333436e5da?imageMogr2&#x2F;auto-orient&#x2F;strip|imageView2&#x2F;2&#x2F;w&#x2F;211&#x2F;format&#x2F;webp</a></p><p>Widgets 的外观和给人的感觉是至关重要的，Widgets 需要看起来不错，包 括各种屏幕的尺寸，也需要有自然的感觉。Widgets 必须快速执行：创建或扩展 UI 控件（实例化他们的 Widgets），将其放在屏幕上，渲染他们，或者（尤其是）将其动画化。对现代的应用程序来说，Widgets 应该是可扩展和可定制的，开发人员希望能够添加讨人喜欢的新的 UI 组件，并自定义所有 Widgets 以匹配各种品牌的应有程序。</p><p>Flutter 的系统架构包含大量赏心悦目、快速、可定制、可扩展的 Widgets。没错，Flutter 不需要使用系统 UI 组件（或 DOM WebViews），它自带了 Widgets。</p><p><a href="https://upload-images.jianshu.io/upload_images/5676002-bbc0eee967535d84?imageMogr2/auto-orient/strip%7CimageView2/2/w/628/format/webp">https://upload-images.jianshu.io/upload_images&#x2F;5676002-bbc0eee967535d84?imageMogr2&#x2F;auto-orient&#x2F;strip|imageView2&#x2F;2&#x2F;w&#x2F;628&#x2F;format&#x2F;webp</a></p><p>Flutter 将 UI 组件和渲染器从平台移动到应用程序中，这使得它们可以自定义和可扩展。Flutter 唯一要求系统提供的是 canvas，以便定制的 UI 组件可以出现在设备的屏幕上，以及访问事件（触摸，定时器等）和服务（位置、相机等）。</p><p>Dart 程序（绿色）和执行数据编码和解码的原生平台代码（蓝色，适用于 iOS 或 Android）之间仍然有一个接口，但这能比 JavaScript 桥接器快几个数量级。</p><p>将 UI 组件和渲染器移动到应用程序中确实会影响应用程序的大小。Android 上的 Flutter 应用程序的的初始大小约为 6.7M，这与类似的工具构建的最小应用程序的大小相似，您可以决定 Flutter 的优势是否值得权衡，因此本文的余下部分将讨论这些优势。</p><p><strong>布局</strong></p><p>Flutter 最大的改进之一就是它的布局，布局是基于一组规则（也称约束）来决定 UI 组件的大小和位置。</p><p>传统上，布局使用大量可以应用于任何 UI 组件的规则。这些规则实现多种布局方法，我们就以众所周知的 CSS 布局为例（尽管 Android 和 iOS 中的布局基本相似）。CSS 具有适用于 HTML 元素（UI 组件）的属性（规则）， CSS3 定义了 375 个属性。</p><p>CSS 包含大量的布局模型，如多种箱模型、浮动元素、表、多列文本、分页媒介等。还有像 flexbox 和 grid 的布局模型在之后也被添加进去，因为开发人员和设计人员需要对布局进行更多地控制，而不得不使用表格和透明图像来获取他们想要的布局。在传统布局中，开发人员无法添加新的布局模型，因此必须将 flexbox 和 grid 添加到 CSS 中并在所有浏览器上实现。</p><p>传统布局的另一个问题是规则可以相互影响甚至发生冲突，通常有几十种规则元素的规则应用于他们，这使得布局变慢。更糟糕的是，布局性能通常为指数性下降，因此，随着元件数量的增加，布局变慢得更快。</p><p>Flutter 最开始是 Google Chrome 浏览器小组成员进行的实验项目，我们想看看如果我们忽略了传统的布局模式，是否可以构建更快的渲染器。几周后，我们在性能上取得了显著增长，我们发现：</p><p>大多数的布局是相对简单的，例如：滚动页面上的文本，其大小和位置只取决于显示大小的固定矩形，还有一些表格，浮动元素等。大部分布局只作用于 UI 组件树的一部分，并且这子树通常使用一个布局模型，因此这些 UI 组件只需要少量的规则。</p><p>我们意识到如果完全改变以前的布局模式，布局就可以大大被简化：</p><p>每个 UI 组件都将指定自己简单的布局模型，而不是拥有可以应用于任何 UI 组件的一整套布局规则。因为每个 UI 组件都有一个更小的一套布局需要考虑，所以布局可以大量优化。为了进一步简化布局，我们几乎将所有内容都转换为 UI 组件。</p><p>这里是用 Flutter 代码来创建的一个带有布局的简单 UI 组件。</p><p>new Center ( child: new Column( children:[ new Text (‘Hello, World!’)), new Icon (Icons.star, color: Colors.green) ] )</p><p>这段代码在语义上足够清晰。您可以轻松地想象它将会生成什么。运行这段代码的显示结果如下：</p><p>Hello, World!</p><p>在这段代码中，所有的组成部分都是一个 UI 组件，包括布局。 Center UI 组件将其子组件集中在其母组件内（如屏幕）。ColumnUI 组件垂直排列其子组件（UI 组件列表）。该列表包含一个 Text 和一个 Icon 控件（具有一个颜色属性）。</p><p>在 Flutter 中，居中显示和 padding 都是 widgets，主题是适用于它们子组件的 UI 控件，甚至应用程序和导航也是 widgets。</p><p>Flutter 包括很多用于布局的 widgets，不仅仅含有列，还包括行、网格、列表等。 此外，Flutter 还有一个独特的布局模型，我们称之为用于滚动的“长条布局模型 (sliver layout model)”。Flutter 中的布局非常快，可用于滚动。试想一下，滚动必须如此快速平滑，以至于让用户感觉当他们在物理屏幕上拖动时，屏幕图像就像和他们的手指相连一样。</p><p>通过使用布局进行滚动，Flutter 可以实现高级滚动，如下所示。请注意，这些是 GIF 动画，真正的 Flutter 应用程序更加平滑。您可以（并且应该）自己运行这些应用程序，请参阅本文末尾的参考资料部分。</p><p><a href="https://upload-images.jianshu.io/upload_images/5676002-cc62789093722bb5?imageMogr2/auto-orient/strip%7CimageView2/2/w/360/format/webp">https://upload-images.jianshu.io/upload_images&#x2F;5676002-cc62789093722bb5?imageMogr2&#x2F;auto-orient&#x2F;strip|imageView2&#x2F;2&#x2F;w&#x2F;360&#x2F;format&#x2F;webp</a></p><p><a href="https://upload-images.jianshu.io/upload_images/5676002-860c115d76246b61?imageMogr2/auto-orient/strip%7CimageView2/2/w/274/format/webp">https://upload-images.jianshu.io/upload_images&#x2F;5676002-860c115d76246b61?imageMogr2&#x2F;auto-orient&#x2F;strip|imageView2&#x2F;2&#x2F;w&#x2F;274&#x2F;format&#x2F;webp</a></p><p>在大多数情况下，Flutter 仅需一次传递即可完成布局，这意味着布局所花的时间是线性增长的，所以它可以处理大量的 widgets。Flutter 也可以利用缓存或其他功能来避免重复的布局。</p><p><strong>定制设计</strong></p><p>因为 UI 组件现在是应用程序的一部分，你可以添加新的 UI 组件，并且可以自定义现有的 UI 组件，以使其具有不同的外观或感觉，或匹配公司的品牌，移动设计的趋势正在与几年前普遍使用的千篇一律的应用程序背离，开始走向让用户愉悦的定制设计。</p><p>Flutter 配有丰富的可定制的 Android、iOS 和 Material Design 组件（实际上，我们已经被告知 Flutter 是 Material Design 中具有最高保真度之一的实现），我们使用 Flutter 的可定制特点来构建这些组件库，以匹配多个平台上的原生组件的外观和感觉。程序开发人员可以使用相似的可定制性功能进一步调整小组件以满足他们的需求。</p><p><strong>更多关于响应式视图</strong></p><p>现有的响应式 web 视图库都引入了 虚拟 DOM，DOM 代表 HTML 的文档对象模型。JavaScript 用 DOM 提供的 API 来操纵表现为一个元素树的 HTML 文档。虚拟 DOM 是使用编程语言中的对象（在这种情况下为 JavaScript）创建的 DOM 的抽象版本。</p><p>在响应式 Web 视图（由 ReactJS 和其他系统实现）中，虚拟 DOM 是不可变的，每次更改，所有的东西都得重建。系统将虚拟 DOM 与真正的 DOM 进行比较，生成一组最小的更改，然后执行这些更改，以更新真正的 DOM。最后，平台重新绘制真实的 DOM 到画布中。 </p><p><a href="https://upload-images.jianshu.io/upload_images/5676002-a2f71649f7b0090f?imageMogr2/auto-orient/strip%7CimageView2/2/w/640/format/webp">https://upload-images.jianshu.io/upload_images&#x2F;5676002-a2f71649f7b0090f?imageMogr2&#x2F;auto-orient&#x2F;strip|imageView2&#x2F;2&#x2F;w&#x2F;640&#x2F;format&#x2F;webp</a></p><p>这听起来增加了很多额外的工作，但它是值得的，因为 操纵 HTML DOM 是非常耗费系统资源的。</p><p>React Native 也做类似的工作，但是是在移动应用程序当中进行的。它会操控移动平台上的原生组件而不是 DOM。它构建一个 UI 组件的虚拟树，与原生组件进行比较，并只更新已更改的部件。</p><p><a href="https://upload-images.jianshu.io/upload_images/5676002-4c51cbee8af5ed24?imageMogr2/auto-orient/strip%7CimageView2/2/w/640/format/webp">https://upload-images.jianshu.io/upload_images&#x2F;5676002-4c51cbee8af5ed24?imageMogr2&#x2F;auto-orient&#x2F;strip|imageView2&#x2F;2&#x2F;w&#x2F;640&#x2F;format&#x2F;webp</a></p><p>请记住，React Native 必须通过桥接器与原生部件进行通信，因此，UI 组件的虚拟树可以帮助保持传递桥的最小值，同时还允许使用原生部件。最后，一旦更新了本机部件，平台就会将它们渲染到画布上。</p><p>React Native 是移动开发的一大进步，并且是 Flutter 的灵感来源，但 Flutter 更进一步。</p><p><a href="https://upload-images.jianshu.io/upload_images/5676002-b92a0618b2495efb?imageMogr2/auto-orient/strip%7CimageView2/2/w/342/format/webp">https://upload-images.jianshu.io/upload_images&#x2F;5676002-b92a0618b2495efb?imageMogr2&#x2F;auto-orient&#x2F;strip|imageView2&#x2F;2&#x2F;w&#x2F;342&#x2F;format&#x2F;webp</a></p><p>回想一下，在 Flutter 中，UI 组件和渲染器已经从平台中集成到用户的应用程序中。没有系统 UI 组件可以操作，所以原来虚拟控件树的地方现在是真实的控件树。Flutter 渲染 UI 控件树并将其绘制到平台画布上。这很好，既简单又快。 此外，动画发生在用户空间中，因此应用程序（因此开发人员）可以对其进行更多的控制。</p><p>Flutter 渲染器本身很有趣：它使用几个内部树结构来渲染只需要在屏幕上更新的 UI 组件。例如，渲染器使用“ 使用 合成的结构重绘”(这意味着比使用屏幕上的矩形区域更有效）。不变的 UI 控件，即使是那些已经移动的 UI 控件，仅需在内存中做极其细微的改动，速度当然超级快。这就是为什么 Flutter 的滚动性能如此之高，即使在很复杂的滚动场景中。</p><p>要进一步了解 Flutter 渲染器，我 推荐这个视频。你也可以看看代码，因为 Flutter 是开源 的。当然，您可以自定义或甚至替换整个堆栈，包括渲染器，合成器，动画，手势识别器，当然还有 widgets。</p><p>Dart 编程语言</p><p>因为 Flutter 像使用响应式视图的其他系统一样，刷新每个新框架的视图树，它会创建许多只能在一帧（六十分之一秒）内存在的对象。幸运的是，Dart 使用“generational garbage collection ”对于这样的系统来说是非常有效的，因为对象（特别是寿命短的）消耗资源相对较少。此外，可以使用单个 pointer bump 来完成对象的分配。这是一个快速且不需要锁定的 pointer bump。这有助于避免 UI 卡顿。</p><p>Dart 还有一个“tree shaking ”编译器，它只包含你在应用程序中需要的代码。 即使您只需要一个或两个，您也可以随意使用大型的 UI 控件库。</p><p>热重载</p><p>Flutter 最受欢迎的功能之一是其快速，保留程序状态的热重载 （hot reload）。 您可以在 Flutter 应用程序运行时对其进行更改，重新加载应用程序的代码，将其从之前的操作位置继续下去。一次热重载通常用不到一秒钟。 如果您的应用遇到错误，您通常可以修复错误，然后继续，就像错误从未发生过。 即使你必须完全重新加载，它也是很快速的。</p><p><a href="https://upload-images.jianshu.io/upload_images/5676002-9a6296412bd3a7b9?imageMogr2/auto-orient/strip%7CimageView2/2/w/640/format/webp">https://upload-images.jianshu.io/upload_images&#x2F;5676002-9a6296412bd3a7b9?imageMogr2&#x2F;auto-orient&#x2F;strip|imageView2&#x2F;2&#x2F;w&#x2F;640&#x2F;format&#x2F;webp</a></p><p>开发人员告诉我们，这可以让他们“绘制”他们的应用程序，一次更改，然后几乎立即可以看到结果，而无需重新启动应用程序。</p><p>兼容性</p><p>因为 UI 组件（和这些 UI 组件的渲染器）是您的应用程序的一部分，而不是平台的一部分，不需要“兼容库 ”。 您的应用程序不仅可以正常工作，而且在最近的操作系统版本 Jelly Bean 以后的安卓系统和 8.0 以后的 iOS 系统上也是一样的 。 这显著降低了在旧版本操作系统上测试应用程序的需求。 此外，你的 App 有很大可能与未来的操作系统版本兼容。</p><p>我们曾被问到一个潜在的问题。 由于 Flutter 不使用原生 UI 组件，因此，当新的 iOS 或 Android 版本出现时，Flutter UI 组件是否需要更新才能支持新的部件，或更改现有部件的外观或行为吗？</p><p>首先，Google 是 Flutter 的内部的一个大用户，所以我们有很大的动机来更新 UI 组件，使其保持最新状态并尽可能接近当前的原生 UI 组件。</p><p>如果有一段时间我们在更新一个 UI 组件时太慢，Google 并不是 Flutter 唯一一个保持 UI 组件最新的用户。Flutter 的 UI 组件是可扩展和可定制的，任何人都可以更新它们，包括你自己， 甚至不需要提交一个请求。 你永远不必等待 Flutter 自己更新。</p><p>只有当您想要在应用中反映出新的更改时，上述要点才适用。 如果您不想要更改影响您的应用程序的外观或工作方式，那么就没有必要使用上面所说的。 UI 组件是您的应用程序的一部分，所以 UI 永远不会在你不知情的情况下擅自改变，并使您的应用程序看起来不好（或更糟的是，破坏您的应用程序）。</p><p>还有一个额外的好处，您可以编写您的应用程序，以便即使在较旧的操作系统版本上也能使用新的 UI 组件。</p><p>其他优势</p><p>Flutter 的简单性使其运行很快，但它的可定制性和可扩展性，保持简单的同时拥有强大功能。</p><p>Dart 拥有一个 软件包仓库。您可以用这些软件包扩展应用程序的功能。 例如，有许多软件包可以轻松访问 Firebase，以便您可以构建“无服务器”应用程序。 外部贡献者创建了一个可让您访问 Redux data store 的软件包。 还有一些称为“ plugins ”的软件包，可以以独立于操作系统的方式轻松访问平台服务和硬件，例如加速度计或相机。</p><p>当然，Flutter 也是一个 开放源码 的项目 ，加上 Flutter 渲染堆栈是您应用程序的一部分，这意味着您可以自定义几乎任何您想要的应用程序。 该图中绿色的部分您都可以定制：</p><p><a href="https://upload-images.jianshu.io/upload_images/5676002-d56ee9334c8a4c62?imageMogr2/auto-orient/strip%7CimageView2/2/w/640/format/webp">https://upload-images.jianshu.io/upload_images&#x2F;5676002-d56ee9334c8a4c62?imageMogr2&#x2F;auto-orient&#x2F;strip|imageView2&#x2F;2&#x2F;w&#x2F;640&#x2F;format&#x2F;webp</a></p><p>那么，“Flutter 有什么新鲜又令人兴奋的”呢？</p><p>如果有人问你 Flutter，现在你知道如何回答他们了：</p><p>响应式视图的优点，不需要 JavaScript 的桥接器</p><p>快速，流畅，可预测 ; 代码将 AOT 编译为本机（ARM）代码</p><p>开发人员完全控制 UI 组件和布局</p><p>配有美观，可定制的 UI 组件</p><p>强大的开发者工具，惊人的热重新加载</p><p>性能更好，兼容性更好，开发起来更有乐趣</p><p>你注意到我把什么移出这个名单吗？ 这是通常人们在谈论 Flutter 时提到的第一件事，但对我来说，这是 Flutter 中最不重要的事情之一。</p><p>这就是，Flutter 可以从单个代码库为多个平台构建漂亮而快速的应用程序。 当然这应该列出来的！ 它的可定制性和可扩展性可以轻松将 Flutter 定位到多个平台，而不会牺牲性能或功耗。</p><p><strong>Flutter 的革命性</strong></p><p>我还没有完全解释为什么 Flutter 是“革命性”的。 这其实是一个很合适的评价，因为外部开发人员用 Flutter 构建的 第一个主要应用程序 之一是描述美国独立战争时期的《 汉密尔顿：美国音乐剧 》的官方应用程序。 《汉密尔顿》是百老汇最受欢迎的音乐剧之一。</p><p><a href="https://upload-images.jianshu.io/upload_images/5676002-c27a7aa0d8de86c7?imageMogr2/auto-orient/strip%7CimageView2/2/w/562/format/webp">https://upload-images.jianshu.io/upload_images&#x2F;5676002-c27a7aa0d8de86c7?imageMogr2&#x2F;auto-orient&#x2F;strip|imageView2&#x2F;2&#x2F;w&#x2F;562&#x2F;format&#x2F;webp</a></p><p>该应用的开发团队 Posse 表示，他们选择了 Flutter 是因为他们需要在 短短的三个月内 构建应用程序。 他们称之为“一个革命性表演的革命性应用程序”，并说“Flutter 是美观，高性能，品牌驱动的移动体验的绝佳选择”。该应用程序在 Android 和 iOS 的应用商店上都可下载，并且得到了越来越多的好评。</p><p>加入革命！</p><p>Flutter 目前是 Alpha 版本。 我们还在增加更多的功能，并且我们有更多的优化计划。 然而，Google 内部和外部的群组已经在使用它来构建任务关键型应用程序。</p><p>如果您对 Flutter 感兴趣， 您可以 安装它，并体验 随附安装 的一些示例应用程序 ， 注意一定要试一下热重载。</p><p>如果您不是开发人员或只想看到某些应用程序，则可以安装使用 Flutter 构建的应用程序，并查看它们的外观和性能。 我推荐 汉密尔顿应用程序 ，但还有其他应用程序 。 您还应该观看来自 Google I &#x2F; O 的视频 ，他们在那里直播 Flutter 应用程序的编译过程。</p><p>原文链接：</p><p><a href="https://www.jianshu.com/p/31fda5322f53">https://www.jianshu.com/p/31fda5322f53</a></p>]]></content>
    
    
    <categories>
      
      <category>Flutter</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Flutter</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>code-push私有部署</title>
    <link href="/2019/09/06/investigation/code-push-deploy/"/>
    <url>/2019/09/06/investigation/code-push-deploy/</url>
    
    <content type="html"><![CDATA[<h1 id="code-push私有部署"><a href="#code-push私有部署" class="headerlink" title="code-push私有部署"></a>code-push私有部署</h1><p>由于code-push服务器是在国外，微软这货又不开源服务器代码，国内有些用户更新的时候卡到生活不能自理</p><p>万能的git上有个大神搭建了code-push的私服：</p><p><a href="https://github.com/lisong/code-push-server/">https://github.com/lisong/code-push-server/</a></p><p>一开始我在windows上搭建好了，不过真的很麻烦，很多命令windows是不支持的，而且还要开ngrok域名，最好还是在linux上弄吧</p><p>按照文档安装还是比较顺利的</p><p>1、安装新版的node</p><p>     linux上的node版本可能是老的，我们去官网<a href="https://nodejs.org/en/download/">https://nodejs.org/en/download/</a>下载linux二进制的对应版本</p><p>     wget <a href="https://nodejs.org/dist/v6.11.3/node-v6.11.3-linux-x64.tar.xz">https://nodejs.org/dist/v6.11.3/node-v6.11.3-linux-x64.tar.xz</a></p><p>     解压命令</p><p>        xz -d ****        xz文件先解压成tar文件</p><p>        tar -xvf ****    解压tar文件</p><p>     然后把node的主文件夹加到环境变量里</p><p>     echo $PATH</p><p>     vim ~&#x2F;.bashrc  </p><p>     在文件末尾加这句：export PATH&#x3D;&#x2F;usr&#x2F;local&#x2F;node&#x2F;bin:$PATH</p><p>     source ~&#x2F;.bashrc #刷新环境变量</p><p>     网上有人说只需建立快捷方式在&#x2F;usr&#x2F;local&#x2F;bin文件夹即可，</p><p>     ln -s &#x2F;usr&#x2F;local&#x2F;node&#x2F;bin&#x2F;node  &#x2F;usr&#x2F;local&#x2F;bin</p><p>     因为这个文件夹在path中，亲测可行，但是后面安装nrm，code-push等等全部要快捷方式一遍</p><p>     TIPS:后面安装cnpm和nrm时需要设置node文件夹的权限，不是很懂这个1，2，4的权限，大力出奇迹 sudo chmod 777 node </p><p>2、按照readme文档安装code-push-server</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ npm install code-push-server -g <span class="hljs-comment">#安装</span><br>$ code-push-server-db init --dbhost localhost --dbuser root --dbpassword ****** --dbport 33308 <span class="hljs-comment">#初始化mysql数据库</span><br></code></pre></td></tr></table></figure><p>     </p><p>3、配置</p><p>     vim config&#x2F;config.js</p><p>     配置数据库的连接参数</p><p>     配置热更新压缩包存储方式，common中storageType，默认local，支持七牛云，亚马逊s3,阿里云oss，local</p><p>     配置local存储的文件夹和下载地址（文件夹需要手动新建 ）</p><p>     common的dataDir好像是增量更新用的，cordova目前还不支持，RN的热更新支持</p><p>     sudo chmod 777 codepushworkspace</p><p><img src="/image/article/investigation/code-push-deploy/bdc3b186-9816-47cc-b688-6309b9763fea.png"></p><p>4、插件安装</p><p>     我这里只能说说cordova的相关内容，等啥时候玩RN再来补充（像我这么懒得，这句话还是当没看见好了）</p><p>     插件地址：<a href="https://github.com/Microsoft/cordova-plugin-code-push">https://github.com/Microsoft/cordova-plugin-code-push</a></p><p>     原始的是这样子的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">&lt;platform name=<span class="hljs-string">&quot;android&quot;</span>&gt;<br>    &lt;preference name=<span class="hljs-string">&quot;CodePushDeploymentKey&quot;</span> value=<span class="hljs-string">&quot;YOUR-ANDROID-DEPLOYMENT-KEY&quot;</span> /&gt;<br>&lt;/platform&gt;<br>&lt;platform name=<span class="hljs-string">&quot;ios&quot;</span>&gt;<br>    &lt;preference name=<span class="hljs-string">&quot;CodePushDeploymentKey&quot;</span> value=<span class="hljs-string">&quot;YOUR-IOS-DEPLOYMENT-KEY&quot;</span> /&gt;<br>&lt;/platform&gt;<br></code></pre></td></tr></table></figure><p>     使用自己服务器的是这样子的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">&lt;platform name=<span class="hljs-string">&quot;android&quot;</span>&gt;<br>    &lt;preference name=<span class="hljs-string">&quot;CodePushDeploymentKey&quot;</span> value=<span class="hljs-string">&quot;nVHPr6asLSusnWoLBNCSktk9FWbiqLF160UDg&quot;</span> /&gt;<br>    &lt;preference name=<span class="hljs-string">&quot;CodePushServerUrl&quot;</span> value=<span class="hljs-string">&quot;http://115.29.200.95:9000/&quot;</span> /&gt;<br>&lt;/platform&gt;<br>&lt;platform name=<span class="hljs-string">&quot;ios&quot;</span>&gt;<br>    &lt;preference name=<span class="hljs-string">&quot;CodePushDeploymentKey&quot;</span> value=<span class="hljs-string">&quot;Iw5DMZSIrCOS7hbLsY5tHAHNITFQqLF160UDg&quot;</span> /&gt;<br>    &lt;preference name=<span class="hljs-string">&quot;CodePushServerUrl&quot;</span> value=<span class="hljs-string">&quot;http://115.29.200.95:9000/&quot;</span> /&gt;<br>&lt;/platform&gt;<br></code></pre></td></tr></table></figure><p>5、命令行提交版本</p><p>     基本上和code-push的命令一直，也有不一样的地方</p><p>     1、登录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">code-push login <span class="hljs-comment">#默认是这样，登录是微软的地址</span><br><span class="hljs-comment">#我们这样写</span><br>code-push login http://ip:port<br></code></pre></td></tr></table></figure><p>     2、app的名字</p><p>          code-push app add ioetest  #正常命令</p><p>          code-push-server的app名字必须包含android或者ios字段（不知道为什么这么玩）</p><p>            后面还要加上平台和cordova</p><p>          例如：code-push app add ioeandroid android cordova</p><p>            code-push app add ioeios ios cordova</p><p>6、其他问题</p><p>     1、用户和密码问题</p><p>          安装好的code-push-server里面只有一个用户 admin     123456</p><p>          如果希望新增或者更换用户的话可以使用web版本操作，我没装这个，因为用处不是很大，也有bug，后台返回了更新包的信息，页面却没有显示</p><p>          由于跨域，web无法正常使用，需要更改server版本的app.js，app.all那里的环境判断注释掉就行了</p><p>          所以这个web也就操作用户信息还比较有用</p><p>          也可以直接用命令行改密码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -X PATCH -H <span class="hljs-string">&quot;Authorization: Bearer mytoken&quot;</span> -H <span class="hljs-string">&quot;Accept: application/json&quot;</span> -H <span class="hljs-string">&quot;Content-Type:application/json&quot;</span> -d <span class="hljs-string">&#x27;&#123;&quot;oldPassword&quot;:&quot;123456&quot;,&quot;newPassword&quot;:&quot;654321&quot;&#125;&#x27;</span> http://127.0.0.1:3000/users/password<br></code></pre></td></tr></table></figure><p>     2、端口和启动问题</p><p>          默认的server端口是3000，也可以改，在bin&#x2F;www里面</p><p>          不过一般我们使用pm2来管理，文件在docs&#x2F;process.json，只需执行pm2 start process.json即可</p><p>          里面的命令实际上我并不懂</p><p>               “instances”：”max”好像是根据cpu核心数量来启动相应多个实例</p><p>          这里面可以直接改端口号</p><p>            env里面的config指的是config&#x2F;config.js</p><p>            最好是用全路径，这样就可以在根目录建快捷方式了</p><p>            ln -s  &#x2F;etc&#x2F;node&#x2F;lib&#x2F;node_modules&#x2F;code-push-server&#x2F;docs&#x2F;process.json  &#x2F;process.json</p><p>            release的时候会报无法解析response的错，但是是成功的，等待code-push-server更新吧</p><p>          TIPS：pm2 stop是挂起程序，pm2 delete是kill程序</p><p>模拟请求</p><p><a href="http://ip:port/updateCheck?gldeploymentKey=mbmYKM8kQkAYkhJMQEe358XgfuY74ksvOXqog&appVersion=3.6.26">http://ip:port/updateCheck?gldeploymentKey=mbmYKM8kQkAYkhJMQEe358XgfuY74ksvOXqog&amp;appVersion=3.6.26</a></p><p>一段时间遇到一个新问题：</p><p>之前搭建的私服停了，然后竟然logout出不来，删除access-key也不行，只能卸载了</p><p>目录：&#x2F;usr&#x2F;local&#x2F;lib&#x2F;node_modules    全名叫code-push-cli</p><p>我太天真了，卸载完重装依旧不行</p><p>我去lisong大神的code-push-server那里提了个issuse，回复说用户目录下有个隐藏文件</p><p>.code-push.config用来保存登录信息的，删除之，done！！！</p><p>结论：和wkwebview插件冲突</p><p>一年之后我又回来了，捣鼓了好久还是没找到和wkwebview冲突的解决办法，查看了我之前提的issue，竟然有人回答解决了，在code-push-server根目录下app.js中增加了一些http头就好了</p><p>x-codepush-plugin-name,x-codepush-plugin-version,x-codepush-sdk-version</p><p><img src="/image/article/investigation/code-push-deploy/1940538f-5506-4061-baf2-8ec83896649e.png"></p><p>我懒得再配置nginx转发了，就注释掉了env的环境判断</p><p>学到一个小知识 ：pm2查看错误日志 pm2 log servername</p>]]></content>
    
    
    <categories>
      
      <category>技术调研</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Cordova</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>sinopia私有仓库</title>
    <link href="/2019/09/06/investigation/sinopia/"/>
    <url>/2019/09/06/investigation/sinopia/</url>
    
    <content type="html"><![CDATA[<h1 id="sinopia私有仓库"><a href="#sinopia私有仓库" class="headerlink" title="sinopia私有仓库"></a>sinopia私有仓库</h1><h3 id="sinopia-是一个零配置的私有的带缓存功能的npm包管理工具"><a href="#sinopia-是一个零配置的私有的带缓存功能的npm包管理工具" class="headerlink" title="sinopia 是一个零配置的私有的带缓存功能的npm包管理工具"></a>sinopia 是一个零配置的私有的带缓存功能的npm包管理工具</h3><p>一般我们开发的前端依赖包是要发到npm的，但是有些是私有的，就需要sinopia这样的仓库来存储，如果不使用仓库，也不希望发布到npm，那么就只能每次手动粘贴了</p><p>使用sinopia，你不用安装CouchDB或MYSQL之类的数据库，Sinopia有自己的迷你数据库，如果要下载的包不存在，它将自动去你配置的npm地址上去下载，而且硬盘中只缓存你下载过的包，以节省空间。</p><p><strong>为什么选择sinopia</strong></p><p>sinopia有以下几个优势值得关注：</p><ol><li>不同步拉取npm库，占据大量硬盘，没有硬盘被撑爆的问题；</li><li>安装配置极其简单,不需要数据库；</li><li>支持配置上游registry配置，一次拉取即缓存；</li><li>支持forever及pm2守护进程管理；</li></ol><p>安装配置：</p><p>       1、安装node，npm（略 ，嘿嘿）</p><p>       2、安装sinopia      npm i -g sinopia</p><p>       3、安装位置自己找一下  which sinopia</p><p>       4、配置文件在   .&#x2F;sinopia&#x2F;config.yaml</p><p>添加源地址：</p><ol><li>安装nrm  npm i nrm </li><li>添加源地址 nrm add [name]  [<a href="http://ip:port]">http://ip:port]</a>  &#x2F;&#x2F;这个是部署sinopia的地址</li><li>使用该地址 nrm use [name]</li></ol><p>推送package:</p><ol><li>npm adduser  &#x2F;&#x2F;(填写用户名密码邮箱，如果已经有用户了，npm login，一样填写用户名密码邮箱)</li><li>npm publish</li></ol>]]></content>
    
    
    <categories>
      
      <category>技术调研</category>
      
    </categories>
    
    
    <tags>
      
      <tag>node</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Cordova加载远程网页调用原生api</title>
    <link href="/2019/03/20/cordova/cordova-webview/"/>
    <url>/2019/03/20/cordova/cordova-webview/</url>
    
    <content type="html"><![CDATA[<h1 id="Cordova加载远程网页调用原生api"><a href="#Cordova加载远程网页调用原生api" class="headerlink" title="Cordova加载远程网页调用原生api"></a>Cordova加载远程网页调用原生api</h1><p>截止目前为止，普遍的做法都是使用静态资源h5做好功能之后放在本地cordova项目里运行，那么既然是h5，是不是也可以放在服务器上，这样就实现了动态更新app,而不必使用codepush了。</p><p>调研了一番，有三个问题需要解决：</p><ol><li><p>ios上架审核问题</p><p> 每次都是加载远程网页，这可不一定能过审啊，如何审核人员测试你断网情况下的报错情况，页面出不来，那大概率是过不了，解决办法吗，可能是必须有个静态的首页还是放在cordova的安装包里面，后面再加其他策略跳转到你网页的地址，好多不可描述的app不都是这么做的吗。这里引申出另一个问题，远程加载的网页遇到网络波动肯定没有本地的效果好，调优是另一个问题了。</p></li><li><p>新开一个webview窗口</p><p> 在主体webview中加一个iframe加载远程地址不就行了？但是需要使用postmessage这样的跨页面通讯，费劲的一笔，而且iframe的页面事件穿透比如手指滑动事件就会有很多奇奇怪怪的问题，我吃过亏也不想再用这种方式，还不如新开一个webview呢，使用 cordova-plugin-inappbrowser就可以了</p></li><li><p>调用原生api</p><p> 这个需求不容易搞定,因为inappbrowser的实现默认是不允许使用cordova的任何资源,只是提供用新webview实例来加载一个纯的网页,所以需要对inAPPbrowser进行改造，简单来说就是注入cordova.js，这段我没试验，懒得弄了，应该是可以的，看下面的链接吧</p></li></ol><p>        </p><p>参考文章： </p><p><a href="https://www.jianshu.com/p/31b28b8661c5">https://www.jianshu.com/p/31b28b8661c5</a></p><p><a href="https://www.jianshu.com/p/0fd4e99acef3">https://www.jianshu.com/p/0fd4e99acef3</a></p>]]></content>
    
    
    <categories>
      
      <category>Cordova</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Cordova</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>cordova获取设备唯一标识</title>
    <link href="/2018/12/26/cordova/cordova-Identifier/"/>
    <url>/2018/12/26/cordova/cordova-Identifier/</url>
    
    <content type="html"><![CDATA[<h1 id="cordova获取设备唯一标识"><a href="#cordova获取设备唯一标识" class="headerlink" title="cordova获取设备唯一标识"></a>cordova获取设备唯一标识</h1><p>最近有个需求，获取到用户设备的唯一标识，唯一标识的概念知识：</p><ul><li>Device ID：设备ID。</li><li>IMEI：International Mobile Equipment Identity，国际移动设备身份码的缩写。是由15位数字组成的“电子串号”，它与每台手机一一对应，每个IMEI在世界上都是唯一的。</li><li>IDFA：Identifier For Advertising，iOS独有的广告标识符。</li><li>UDID：Unique Device Identifier，唯一设备标识码。</li><li>UUID：Universally Unique Identifier，通用唯一识别码。目前最广泛应用的UUID，是微软公司的全局唯一标识符GUID。其目的是让分布式系统中的所有元素，都能有唯一的辨识信息，而不需要通过中央控制端来做辨识信息的指定。</li></ul><p><img src="/image/article/cordova/cordova-Identifier/device.png"></p><p>自己做cordova的插件肯定不现实了，结合目前已有的插件(只找到一个获取IMEI的)，最终是想要使用IMEI或者UDID，安卓可以获取IMEI但是需要用户授权而且需要修改那个插件，ios在ios5以后iOS设备不能获取IMEI号，没啥好办法</p><p>本身我们是已经集成了jpush,最后我们用了jpush的registrationid做标识，registrationid也是基于这几个id加上包名组合而成了，但是这玩意仍然是可变的，不能保证设备唯一性，矮子里面拔高个了属于是</p><p>参考文章：</p><p><a href="https://www.jianshu.com/p/38f4d1a4763b">https://www.jianshu.com/p/38f4d1a4763b</a></p><p><a href="https://community.jiguang.cn/article/38100">https://community.jiguang.cn/article/38100</a></p>]]></content>
    
    
    <categories>
      
      <category>Cordova</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Cordova</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Cordova和PhoneGap的关系</title>
    <link href="/2018/10/09/cordova/Cordova-PhoneGap/"/>
    <url>/2018/10/09/cordova/Cordova-PhoneGap/</url>
    
    <content type="html"><![CDATA[<h1 id="Cordova和PhoneGap的关系"><a href="#Cordova和PhoneGap的关系" class="headerlink" title="Cordova和PhoneGap的关系"></a>Cordova和PhoneGap的关系</h1><p>1、<strong>PhoneGap</strong> 最早由 <strong>Nitobi</strong> 软件公司于 2009 年在旧金山召开的 iPhoneDevCamp 大会上发布。它是一个基于 HTML，CSS 和 JavaScript 技术创建跨平台移动应用程序的快速开发框架。它使开发者能够通过 JavaScript 调用 iOS、Android、Palm、Symbian、WP7、WP8、Bada 和 Blackberry 智能手机的核心功能，如地理定位，加速器，联系人，声音和振动等等，此外 PhoneGap 还包含丰富的插件用于简单而快速的开发。</p><p>2011年10月4日，<strong>Adobe</strong> 正式宣布收购 Nitobi 软件公司，并将 PhoneGap 的核心代码贡献给了 <strong>Apache</strong> 软件基金会，但保留了 PhoneGap 的商标所有权。Apache 将 PhoneGap 核心代码</p><p>命名为 <strong>Apache Callback</strong> 项目，后又更名为 <strong>Apache Cordova。</strong></p><p>就是说：Cordova是PhoneGap的核心代码开源出去的产品。</p><p>PhoneGap 的 faq[3] 里有个对比 —— Think about Cordova’s relationship to PhoneGap like WebKit’s relationship to Safari or Chrome.</p><p>在Adobe PhoneGap 的 faq 中有说明：如果你要贡献代码，请贡献到 Cordova.</p><p>参考链接：</p><p><a href="http://www.biliyu.com/article/1361.html">http://www.biliyu.com/article/1361.html</a></p>]]></content>
    
    
    <categories>
      
      <category>Cordova</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Cordova</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>详解Chrome和Webkit的渊源</title>
    <link href="/2018/10/08/concept/Chrome-Webkit/"/>
    <url>/2018/10/08/concept/Chrome-Webkit/</url>
    
    <content type="html"><![CDATA[<h1 id="详解-Chrome-和-Webkit-的渊源"><a href="#详解-Chrome-和-Webkit-的渊源" class="headerlink" title="详解 Chrome 和 Webkit 的渊源"></a>详解 Chrome 和 Webkit 的渊源</h1><p>互联网的浪潮从未停息，而用以网上冲浪的冲浪板也一直在变得愈加精良。自人们进入互联网时代以来，即已经发生了三次浏览器大战。第一次浏览器大战的主角是IE和Netscape，最终IE凭借着Windows的庞大身躯推倒了Netscape；第二次浏览器大战Netscape浴火重生化身为火狐狸Firefox，一口咬了IE身上一大块肥肉；正在Firefox和IE正缠绵不息之时，突然凭空杀出个Chrome——这名出身豪门Google的小伙子一下子成长得额外精壮，上串势头凶猛，追得两位前辈娇喘吁吁。</p><p><img src="/image/article/concept/Chrome-Webkit/56fb7751-0e9d-44f9-88da-61c052fade98.jpg" alt="Chrome正在猛击两位前辈"></p><p>　　这位Chrome究竟是何方人物，能练就如此神功，在短短几年内就成为互联网浏览的一大主流，市场份额赶超了Firefox不说，甚至还曾在短时间内压过了微软帝国的IE，形成天下三分的第三次浏览器大战的格局？</p><p><img src="/image/article/concept/Chrome-Webkit/b3296c35-fb55-49cd-a9d3-a0f3b68b7411.jpg" alt="Chrome已在市场份额上击败了Firefox"></p><p>　　<strong>Chrome的血统</strong></p><p>　　出于好奇，不少人都八卦了一下Chrome的来历，然后发现Chrome的背后深藏着Webkit这个名字。对浏览器有所研究的朋友，应该也会或多或少地闻过Webkit的大名。Webkit源于KDE开源项目，兴盛于苹果公司的Safari项目，它身上有诸多创新，近年来风行的HTML5以及CSS3潮流都和Webkit脱不开关系。Webkit小巧、灵活但又十分强大，而且源代码开放，深得业界喜爱。从诺基亚S60上的浏览器，到价比肾贵的iPhone上的Safari，我们都能看到Webkit的身影。</p><p><img src="/image/article/concept/Chrome-Webkit/752275d0-0a4d-4e5b-83ce-17519ed6b0b1.jpg" alt="Webkit（左）和Safari的logo，一看就孽缘深"></p><p>Google从来都不是嗅觉迟钝的公司，Webkit的优秀自然也吸引了这位互联网枭雄的眼光。2008年9月，Google发布了Chrome的测试版，Chrome面世了。Chrome使用了Webkit的代码，继承了Webkit的优良排版引擎，渲染页面速度惊人。</p><p><img src="/image/article/concept/Chrome-Webkit/dc79baa3-6a52-4036-bfef-a46b4ad69163.png" alt="Chrome首个测试版"></p><p>　　既然Chrome使用了Webkit的源代码，也使用了Webkit的排版引擎，那么我们是否就可以认为，Google只是在Webkit上面加了一层壳就做出了Chrome呢？</p><p>　　<strong>Chrome的基因突变</strong></p><p>Chrome是Webkit的马甲，这种说法并不准确。实际上Webkit由两部分组成，一部分是WebCore排版引擎，用以解析HTML语言和CSS框架；另一部分为JSCoreJavaScript执行引擎，用以执行网页JS脚本。Chrome只是继承了Webkit的WebCore部分，在JS引擎上使用了Google引以为豪的“V8”引擎，大大地提高了脚本执行速度，这也是为什么Chrome会如此快的重要原因。</p><p><img src="/image/article/concept/Chrome-Webkit/565e196b-4af4-4ee5-af4a-cb48f6d0f403.jpg" alt="Webkit包括WebCore和JSCore"></p><p>不仅如此，Chrome还在Webkit上封装了一层Webkit Glue，Chrome中只调用WebkitGlue层的接口使用Webkit组件。与此同时，Chrome的源代码和Webkit也有了很大区别，Google对Webkit的源代码重新进行了梳理，使代码的可读性更好，编译效率更高，并拥有自己的开源项目——Chromium。</p><p>大受国内群众欢迎的Chromium</p><p>　　<strong>Chromium和Chrome：试制品和成品</strong></p><p>　　既然提到了Chromium，这里就顺带谈一下Chromium和Chrome的区别。不知道从什么时候开始，流行着这样一种说法——Chrome开源。这是错误的。Chrome并非一款自由软件，也没有开放源代码。甚至和Firefox比起来，Chrome还很封闭——因为它无法提供像Firefox一样繁多而高权限的应用接口，这使得Chrome在扩展以及界面定制方面都不如Firefox自由。那Chrome是开源软件一说何来之有？</p><p><img src="/image/article/concept/Chrome-Webkit/6beb7278-f63e-467f-89ee-27a6615d6bd6.jpg" alt="Firefox十分开放"></p><p>之所以这种说法，多是因为人们把Chrome和Chromium搞混了。虽然名字很像，图标界面功能什么的都差不多，也同样隶属于Google，但事实上这两者真的不同。Chromium是一款自由软件，遵循BSD许可证开源，开发者可以使用Chromium的源代码进行开发。我们可以认为Chromium是Google为了发展Chrome而开启的开源计划，Chromium相当于Chrome的实验开源版。两者功能也有微妙的差异，Chrome比Chromium多了PDF阅读器、Flash Player及Google Update等一些小部件。</p><p><img src="/image/article/concept/Chrome-Webkit/805c4803-8dcf-4d83-8b5f-d3f034ba403e.jpg" alt="Chromium（左）和Chrome"></p><p>简单来说，Chromium是一个实验项目，Chrome则是一件商品。开发者所能使用的代码只能是开源的Chromium，而不会是闭源的Chrome。若听到有人说，某某浏览器基于Chrome内核，速度快得很！这时候我们应该知道，这款浏览器实际上使用的是Chromium内核。</p><p>　　<strong>广受欢迎的Chromium</strong></p><p>　　目前使用Chromium内核的著名国产浏览器有360极速浏览器、搜狗浏览器、世界之窗浏览器极速版等等，为数不少。但我们发现，在国内虽然Chromium内核很受浏览器厂商欢迎，但是更原始的Webkit却几近无人问津。这又是为何？</p><p><img src="/image/article/concept/Chrome-Webkit/1218b913-99e9-4a9b-b31e-dc85841368c3.jpg" alt="人们更热衷于Chromium"></p><p>当然这也是有原因的。前面提到，Google对Webkit的代码重新梳理，Chromium代码的可读性和编译效率远比Webkit高。对比Chromium的代码，Webkit的代码堪比天书，开发难度高得多。Webkit这货不是你想弄，想弄就能弄的啊。更何况Chromium的V8JS引擎比Webkit的JSCore效率更高，好用又强大的东西干嘛不用呢。</p><p>　　鉴于Chromium和Webkit拥有较大的区别，我们不应该单纯地认为Chrome&#x2F;Chromium只是在Webkit上面套一个马甲。给Google的工程师们一些掌声吧，因为他们的优秀和努力，世界上多了一个优异的浏览器内核。</p><p>我是一整个粘贴复制的，担心哪天这个好文章不在了，果然，原文他打不开了。<br>原文链接：<br><a href="http://www.freair.com/bbs/simple/?t795.html">http://www.freair.com/bbs/simple/?t795.html</a></p>]]></content>
    
    
    <categories>
      
      <category>概念知识</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>v8引擎详解</title>
    <link href="/2018/10/08/concept/v8-engine/"/>
    <url>/2018/10/08/concept/v8-engine/</url>
    
    <content type="html"><![CDATA[<h1 id="v8引擎详解"><a href="#v8引擎详解" class="headerlink" title="v8引擎详解"></a>v8引擎详解</h1><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>　　JavaScript绝对是最火的编程语言之一，一直具有很大的用户群，随着在服务端的使用（NodeJs），更是爆发了极强的生命力。编程语言分为编译型语言和解释型语言两类，编译型语言在执行之前要先进行完全编译，而解释型语言一边编译一边执行，很明显解释型语言的执行速度是慢于编译型语言的，而JavaScript就是一种解释型脚本语言，支持动态类型、弱类型、基于原型的语言，内置支持类型。鉴于JavaScript都是在前端执行，而且需要及时响应用户，这就要求JavaScript可以快速的解析及执行。</p><p>　　随着Web相关技术的发展，JavaScript所要承担的工作也越来越多，早就超越了“表单验证”的范畴，这就更需要快速的解析和执行JavaScript脚本。V8引擎就是为解决这一问题而生，在node中也是采用该引擎来解析JavaScript。</p><p>　　V8是如何使得JavaScript性能有大幅提升的呢？通过对一些书籍和文章的学习，梳理了V8的相关内容，本文将带你认识 V8。(该文在 17 年初发布于公司内网，反响不错，近来闲暇再次整理作为知乎的第一篇分享，希望帮助更多的人了解 V8 引擎。转载需经过本人同意)</p><h3 id="1-渲染引擎及网页渲染"><a href="#1-渲染引擎及网页渲染" class="headerlink" title="1.渲染引擎及网页渲染"></a>1.渲染引擎及网页渲染</h3><p>　　浏览器自从上世纪80年代后期90年代初期诞生以来，已经得到了长足的发展，其功能也越来越丰富，包括网络、资源管理、网页浏览、多页面管理、插件和扩展、书签管理、历史记录管理、设置管理、下载管理、账户和同步、安全机制、隐私管理、外观主题、开发者工具等。在这些功能中，为用户提供网页浏览服务无疑是最重要的功能，下面将对相关内容进行介绍。</p><h3 id="1-1-渲染引擎"><a href="#1-1-渲染引擎" class="headerlink" title="1.1.渲染引擎"></a>1.1.渲染引擎</h3><p>　　渲染引擎：能够将HTML&#x2F;CSS&#x2F;JavaScript文本及相应的资源文件转换成图像结果。渲染引擎的主要作用是将资源文件转化为用户可见的结果。在浏览器的发展过程中，不同的厂商开发了不同的渲染引擎，如Tridend(IE)、Gecko(FF)、WebKit(Safari,Chrome,Andriod浏览器)等。WebKit是由苹果2005年发起的一个开源项目，引起了众多公司的重视，几年间被很多公司所采用，在移动端更占据了垄断地位。更有甚者，开发出了基于WebKit的支持HTML5的web操作系统(如：Chrome OS、Web OS)。</p><p>　　下面是WebKit的大致结构：</p><p><img src="/image/article/concept/v8-engine/1-20171101142146185-894488689.png" alt="WebKit的大致结构"></p><p>　　上图中实线框内模块是所有移植的共有部分，虚线框内不同的厂商可以自己实现。下面进行介绍：</p><p>操作系统：是管理和控制计算机硬件与软件资源的计算机程序，是直接运行在“裸机”上的最基本的系统软件，任何其他软件都必须在操作系统的支持下才能运行。WebKit也是在操作系统上工作的。</p><p>第三方库，为了WebKit提供支持，如图形库、网络库、视频库等。</p><p>WebCore 是各个浏览器使用的共享部分，包括HTML解析器、CSS解析器、DOM和SVG等。JavaScriptCore是WebKit的默认引擎，在谷歌系列产品中被替换为V8引擎。WebKit Ports是WebKit中的非共享部分，由于平台差异、第三方库和需求的不同等原因，不同的移植导致了WebKit不同版本行为不一致，它是不同浏览器性能和功能差异的关键部分。</p><p>WebKit嵌入式编程接口，供浏览器调用，与移植密切相关，不同的移植有不同的接口规范。</p><p>测试用例，包括布局测试用例和性能测试用例，用来验证渲染结果的正确性。</p><h3 id="1-2-网页渲染流程"><a href="#1-2-网页渲染流程" class="headerlink" title="1.2.网页渲染流程"></a>1.2.网页渲染流程</h3><p>　　上面介绍了渲染引擎的各个模块，那么一张网页，要经历怎样的过程，才能抵达用户面前？</p><p><img src="/image/article/concept/v8-engine/1-20171101142146185-1166730809.png" alt="网页渲染流程"></p><p>　　首先是网页内容，输入到HTML解析器，HTML解析器解析，然后构建DOM树，在这期间如果遇到JavaScript代码则交给JavaScript引擎处理；如果来自CSS解析器的样式信息，构建一个内部绘图模型。该模型由布局模块计算模型内部各个元素的位置和大小信息，最后由绘图模块完成从该模型到图像的绘制。在网页渲染的过程中，大致可分为下面3个阶段。</p><h2 id="1-2-1-从输入URL到生成DOM树"><a href="#1-2-1-从输入URL到生成DOM树" class="headerlink" title="1.2.1.从输入URL到生成DOM树"></a>1.2.1.从输入URL到生成DOM树</h2><ol><li>地址栏输入URL，WebKit调用资源加载器加载相应资源；</li><li>加载器依赖网络模块建立连接，发送请求并接收答复；</li><li>WebKit接收各种网页或者资源数据，其中某些资源可能同步或异步获取；</li><li>网页交给HTML解析器转变为词语；</li><li>解释器根据词语构建节点，形成DOM树；</li><li>如果节点是JavaScript代码，调用JavaScript引擎解释并执行；</li><li>JavaScript代码可能会修改DOM树结构；</li><li>如果节点依赖其他资源，如图片\css、视频等，调用资源加载器加载它们，但这些是异步加载的，不会阻碍当前DOM树继续创建；如果是JavaScript资源URL（没有标记异步方式），则需要停止当前DOM树创建，直到JavaScript加载并被JavaScript引擎执行后才继续DOM树的创建。</li></ol><h2 id="1-2-2-从DOM树到构建WebKit绘图上下文"><a href="#1-2-2-从DOM树到构建WebKit绘图上下文" class="headerlink" title="1.2.2.从DOM树到构建WebKit绘图上下文"></a>1.2.2.从DOM树到构建WebKit绘图上下文</h2><ol><li>CSS文件被CSS解释器解释成内部表示；</li><li>CSS解释器完成工作后，在DOM树上附加样式信息，生成RenderObject树；</li><li>RenderObject节点在创建的同时，WebKit会根据网页层次结构构建RenderLayer树，同时构建一个虚拟绘图上下文。</li></ol><h2 id="1-2-3-绘图上下文到最终图像呈现"><a href="#1-2-3-绘图上下文到最终图像呈现" class="headerlink" title="1.2.3.绘图上下文到最终图像呈现"></a>1.2.3.绘图上下文到最终图像呈现</h2><ol><li>绘图上下文是一个与平台无关的抽象类，它将每个绘图操作桥接到不同的具体实现类，也就是绘图具体实现类；</li><li>绘图实现类也可能有简单的实现，也可能有复杂的实现，软件渲染、硬件渲染、合成渲染等；</li><li>绘图实现类将2D图形库或者3D图形库绘制结果保存，交给浏览器界面进行展示。</li></ol><p>　　上述是一个完整的渲染过程，现代网页很多都是动态的，随着网页与用户的交互，浏览器需要不断的重复渲染过程。</p><h3 id="1-3-JavaScript引擎"><a href="#1-3-JavaScript引擎" class="headerlink" title="1.3.JavaScript引擎"></a>1.3.JavaScript引擎</h3><p><img src="/image/article/concept/v8-engine/1-20171101142146185-1957262607.png" alt="JavaScript引擎"></p><p>　　JavaScript本质上是一种解释型语言，与编译型语言不同的是它需要一遍执行一边解析，而编译型语言在执行时已经完成编译，可直接执行，有更快的执行速度(如上图所示)。JavaScript代码是在浏览器端解析和执行的，如果需要时间太长，会影响用户体验。那么提高JavaScript的解析速度就是当务之急。JavaScript引擎和渲染引擎的关系如下图所示：</p><p><img src="/image/article/concept/v8-engine/1-20171101142146170-860101485.png" alt="JavaScript引擎和渲染引擎的关系"></p><p>　　JavaScript语言是解释型语言，为了提高性能，引入了Java虚拟机和C++编译器中的众多技术。现在JavaScript引擎的执行过程大致是：</p><p>　　源代码-→抽象语法树-→字节码-→JIT-→本地代码(V8引擎没有中间字节码)。一段代码的抽象语法树示例如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">function</span> demo(name) &#123;<br>    console.log(name);<br>&#125;<br></code></pre></td></tr></table></figure><p>　　抽象语法树如下：</p><p><img src="/image/article/concept/v8-engine/1-20171101142146201-2127916928.png" alt="抽象语法树"></p><p>　　V8更加直接的将抽象语法树通过JIT技术转换成本地代码，放弃了在字节码阶段可以进行的一些性能优化，但保证了执行速度。在V8生成本地代码后，也会通过Profiler采集一些信息，来优化本地代码。虽然，少了生成字节码这一阶段的性能优化，但极大减少了转换时间。</p><p>　　但是在2017年4月底，v8 的 5.9 版本发布了，新增了一个 Ignition 字节码解释器，将默认启动，从此之后将与JSCore有大致相同的流程。做出这一改变的原因为：（主要动机）减轻机器码占用的内存空间，即牺牲时间换空间；提高代码的启动速度；对 v8 的代码进行重构，降低 v8 的代码复杂度(<a href="http://cnodejs.org/topic/59084a9cbbaf2f3f569be482">V8 Ignition：JS 引擎与字节码的不解之缘 - CNode技术社区</a>)。</p><p>　　JavaScript的性能和C相比还有不小的距离，可预见的未来估计也只能接近它，而不是与它相比，这从语言类型上已经决定。下面将对V8引擎进行更为细致的介绍。</p><h3 id="2-V8引擎"><a href="#2-V8引擎" class="headerlink" title="2.V8引擎"></a>2.V8引擎</h3><p>　　V8引擎是一个JavaScript引擎实现，最初由一些语言方面专家设计，后被谷歌收购，随后谷歌对其进行了开源。V8使用C++开发，，在运行JavaScript之前，相比其它的JavaScript的引擎转换成字节码或解释执行，V8将其编译成原生机器码（IA-32, x86-64, ARM, or MIPS CPUs），并且使用了如内联缓存（inline caching）等方法来提高性能。有了这些功能，JavaScript程序在V8引擎下的运行速度媲美二进制程序。V8支持众多操作系统，如windows、linux、android等，也支持其他硬件架构，如IA32,X64,ARM等，具有很好的可移植和跨平台特性。</p><p>　　V8项目代码结构如下：</p><p><img src="/image/article/concept/v8-engine/1-20171101142146185-1069584147.png" alt="V8项目代码结构"></p><h3 id="2-1-数据表示"><a href="#2-1-数据表示" class="headerlink" title="2.1.数据表示"></a>2.1.数据表示</h3><p>　　JavaScript是一种无类型语言，在编译时并不能准确知道变量的类型，只可以在运行时确定，这就不像c++或者java等静态类型语言，在编译时候就可以确切知道变量的类型。然而，在运行时计算和决定类型，会严重影响语言性能，这也就是JavaScript运行效率比C++或者JAVA低很多的原因之一。</p><p>　　在C++中，源代码需要经过编译才能执行，在生成本地代码的过程中，变量的地址和类型已经确定，运行本地代码时利用数组和位移就可以存取变量和方法的地址，不需要再进行额外的查找，几个机器指令即可完成，节省了确定类型和地址的时间。由于JavaScript是无类型语言，那就不能像c++那样在执行时已经知道变量的类型和地址，需要临时确定。JavaScript 和C++有以下几个区别：</p><p>编译确定位置，C++编译阶段确定位置偏移信息，在执行时直接存取，JavaScript在执行阶段确定，而且执行期间可以修改对象属性；</p><p>偏移信息共享，C++有类型定义，执行时不能动态改变，可共享偏移信息，JavaScript每个对象都是自描述，属性和位置偏移信息都包含在自身的结构中；</p><p>偏移信息查找，C++查找偏移地址很简单，在编译代码阶段，对使用的某类型成员变量直接设置偏移位置，JavaScript中使用一个对象，需要通过属性名匹配才能找到相应的值，需要更多的操作。</p><p>　　在代码执行过程中，变量的存取是非常普遍和频繁的，通过偏移量来存取，使用少数两个汇编指令就能完成，如果通过属性名匹配则需要更多的汇编指令，也需要更多的内存空间。示例如下：</p><p><img src="/image/article/concept/v8-engine/1-20171101142146279-1942851017.jpg"></p><p>　　在JavaScript中，除boolean，number，string，null，undefined这个五个简单变量外，其他的数据都是对象，V8使用一种特殊的方式来表示它们，进而优化JavaScript的内部表示问题。</p><p>　　在V8中，数据的内部表示由数据的实际内容和数据的句柄构成。数据的实际内容是变长的，类型也是不同的；句柄固定大小，包含指向数据的指针。这种设计可以方便V8进行垃圾回收和移动数据内容，如果直接使用指针的话就会出问题或者需要更大的开销，使用句柄的话，只需修改句柄中的指针即可，使用者使用的还是句柄，指针改动是对使用者透明的。</p><p>　　除少数数据(如整型数据)由handle本身存储外，其他内容限于句柄大小和变长等原因，都存储在堆中。整数直接从value中取值，然后使用一个指针指向它，可以减少内存的占用并提高访问速度。一个句柄对象的大小是4字节(32位设备)或者8字节(64位设备)，而在JavaScriptCore中，使用的8个字节表示句柄。在堆中存放的对象都是4字节对齐的，所以它们指针的后两位是不需要的，V8用这两位表示数据的类型，00为整数，01为其他。</p><p>　　JavaScript对象在V8中的实现包含三个部分：隐藏类指针，这是v8为JavaScript对象创建的隐藏类；属性值表指针，指向该对象包含的属性值；元素表指针，指向该对象包含的属性。</p><h3 id="2-2-工作过程"><a href="#2-2-工作过程" class="headerlink" title="2.2.工作过程"></a>2.2.工作过程</h3><p>　　前面有过介绍，V8引擎在执行JavaScript的过程中，主要有两个阶段：编译和运行，与C++的执行前完全编译不同的是，JavaScript需要在用户使用时完成编译和执行。在V8中，JavaScript相关代码并非一下完成编译的，而是在某些代码需要执行时，才会进行编译，这就提高了响应时间，减少了时间开销。在V8引擎中，源代码先被解析器转变为抽象语法树(AST)，然后使用JIT编译器的全代码生成器从AST直接生成本地可执行代码。这个过程不同于JAVA先生成字节码或中间表示，减少了AST到字节码的转换时间，提高了代码的执行速度。但由于缺少了转换为字节码这一中间过程，也就减少了优化代码的机会。</p><p>　　V8引擎编译本地代码时使用的主要类如下所示：</p><p>Script：表示JavaScript代码，即包含源代码，又包含编译之后生成的本地代码，即是编译入口，又是运行入口；</p><p>Compiler：编译器类，辅组Script类来编译生成代码，调用解释器(Parser)来生成AST和全代码生成器，将AST转变为本地代码；</p><p>AstNode：抽象语法树节点类，是其他所有节点的基类，包含非常多的子类，后面会针对不同的子类生成不同的本地代码；</p><p>AstVisitor：抽象语法树的访问者类，主要用来遍历异构的抽象语法树；</p><p>FullCodeGenerator：AstVisitor类的子类，通过遍历AST来为JavaScript生成本地可执行代码。</p><p><img src="/image/article/concept/v8-engine/1-20171101142146216-2041661025.png"></p><p>　　JavaScript代码编译的过程大致为：Script类调用Compiler类的Compile函数为其生成本地代码。Compile函数先使用Parser类生成AST，再使用FullCodeGenerator类来生成本地代码。本地代码与具体的硬件平台密切相关，FullCodeGenerator使用多个后端来生成与平台相匹配的本地汇编代码。由于FullCodeGenerator通过遍历AST来为每个节点生成相应的汇编代码，缺失了全局视图，节点之间的优化也就无从谈起。</p><p>　　在执行编译之前，V8会构建众多全局对象并加载一些内置的库（如math库），来构建一个运行环境。而且在JavaScript源代码中，并非所有的函数都被编译生成本地代码，而是延迟编译，在调用时才会编译。</p><p>　　由于V8缺少了生成中间代码这一环节，缺少了必要的优化，为了提升性能，V8会在生成本地代码后，使用数据分析器(profiler)采集一些信息，然后根据这些数据将本地代码进行优化，生成更高效的本地代码，这是一个逐步改进的过程。同时，当发现优化后代码的性能还不如未优化的代码，V8将退回原来的代码，也就是优化回滚。下面介绍一下运行阶段，该阶段使用的主要类如下所示：</p><p>Script：表示JavaScript代码，即包含源代码，又包含编译之后生成的本地代码，即是编译入口，又是运行入口；</p><p>Execution：运行代码的辅组类，包含一些重要函数，如Call函数，它辅组进入和执行Script代码；</p><p>JSFunction：需要执行的JavaScript函数表示类；</p><p>Runtime：运行这些本地代码的辅组类，主要提供运行时所需的辅组函数，如：属性访问、类型转换、编译、算术、位操作、比较、正则表达式等；</p><p>Heap：运行本地代码需要使用的内存堆类；</p><p>MarkCompactCollector：垃圾回收机制的主要实现类，用来标记、清除和整理等基本的垃圾回收过程；</p><p>SweeperThread：负责垃圾回收的线程。</p><p><img src="/image/article/concept/v8-engine/1-20171101142146248-491172996.png"></p><p>　　先根据需要编译和生成这些本地代码，也就是使用编译阶段那些类和操作。在V8中，函数是一个基本单位，当某个JavaScript函数被调用时，V8会查找该函数是否已经生成本地代码，如果已经生成，则直接调用该函数。否则，V8引擎会生成属于该函数的本地代码。这就节约了时间，减少了处理那些使用不到的代码的时间。其次，执行编译后的代码为JavaScript构建JS对象，这需要Runtime类来辅组创建对象，并需要从Heap类分配内存。再次，借助Runtime类中的辅组函数来完成一些功能，如属性访问等。最后，将不用的空间进行标记清除和垃圾回收。</p><h3 id="2-3-优化回滚"><a href="#2-3-优化回滚" class="headerlink" title="2.3.优化回滚"></a>2.3.优化回滚</h3><p>　　因为V8是基于AST直接生成本地代码，没有经过中间表示层的优化，所以本地代码尚未经过很好的优化。于是，在2010年，V8引入了新的编译器-Crankshaft，它主要针对热点函数进行优化，基于JavaScript源代码开始分析而非本地代码，同时构建Hydroger图并基于此来进行优化分析。</p><p>　　Crankshaft编译器为了性能考虑，通常会做出比较乐观和大胆的预测—代码稳定且变量类型不变，所以可以生成高效的本地代码。但是，鉴于JavaScript的一个弱类型的语言，变量类型也可能在执行的过程中进行改变，鉴于这种情况，V8会将该编译器做的想当然的优化进行回滚，称为优化回滚。</p><p>　　示例如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> counter = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">test</span>(<span class="hljs-params">x, y</span>) &#123;<br>    counter++;<br>    <span class="hljs-keyword">if</span> (counter &lt; <span class="hljs-number">1000000</span>) &#123;<br>        <span class="hljs-comment">// do something</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;jeri&#x27;</span>;<br>    &#125;<br>    <span class="hljs-keyword">var</span> unknown = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(unknown);<br>&#125;<br></code></pre></td></tr></table></figure><p>　　该函数被调用多次之后，V8引擎可能会触发Crankshaft编译器对其进行优化，而优化代码认为示例代码的类型信息都已经被确定。但，由于尚未真正执行到new Date()这个地方，并未获取unknown这个变量的类型，V8只得将该部分代码进行回滚。优化回滚是一个很耗时的操作，在写代码过程中，尽量不要触发优化该操作。</p><p>　　在最近发布的 V8 5.9 版本中，新增了一个 Ignition 字节码解释器，TurboFan 和 Ignition 结合起来共同完成JavaScript的编译。这个版本中消除 Cranshaft 这个旧的编译器，并让新的 Turbofan 直接从字节码来优化代码，并当需要进行反优化的时候直接反优化到字节码，而不需要再考虑 JS 源代码。</p><h3 id="2-4-隐藏类与内嵌缓存"><a href="#2-4-隐藏类与内嵌缓存" class="headerlink" title="2.4.隐藏类与内嵌缓存"></a>2.4.隐藏类与内嵌缓存</h3><h2 id="2-4-1-隐藏类"><a href="#2-4-1-隐藏类" class="headerlink" title="2.4.1.隐藏类"></a>2.4.1.隐藏类</h2><p>　　在执行C++代码时，仅凭几个指令即可根据偏移信息获取变量信息，而JavaScript里需要通过字符串匹配来查找属性值的，这就需要更多的操作才能访问到变量信息，而代码量变量存取是十分频繁的，这也就制约了JavaScript的性能。V8借用了类和偏移位置的思想，将本来通过属性名匹配来访问属性值的方法进行了改进，使用类似C++编译器的偏移位置机制来实现，这就是隐藏类。</p><p>　　隐藏类将对象划分成不同的组，对于组内对象拥有相同的属性名和属性值的情况，将这些组的属性名和对应的偏移位置保存在一个隐藏类中，组内所有对象共享该信息。同时，也可以识别属性不同的对象。示例如下：</p><p><img src="/image/article/concept/v8-engine/1-20171101142146513-822213973.png"></p><p>　　使用Point构造了两个对象p和q，这两个对象具有相同的属性名，V8将它们归为同一个组，也就是隐藏类，这些属性在隐藏类中有相同的偏移值，p和q共享这一信息，进行属性访问时，只需根据隐藏类的偏移值即可。由于JavaScript是动态类型语言，在执行时可以更改变量的类型，如果上述代码执行之后，执行q.z&#x3D;2，那么p和q将不再被认为是一个组，q将是一个新的隐藏类。</p><h2 id="2-4-2-内嵌缓存"><a href="#2-4-2-内嵌缓存" class="headerlink" title="2.4.2.内嵌缓存"></a>2.4.2.内嵌缓存</h2><p>　　正常访问对象属性的过程是：首先获取隐藏类的地址，然后根据属性名查找偏移值，然后计算该属性的地址。虽然相比以往在整个执行环境中查找减小了很大的工作量，但依然比较耗时。能不能将之前查询的结果缓存起来，供再次访问呢？当然是可行的，这就是内嵌缓存。</p><p>　　内嵌缓存的大致思路就是将初次查找的隐藏类和偏移值保存起来，当下次查找的时候，先比较当前对象是否是之前的隐藏类，如果是的话，直接使用之前的缓存结果，减少再次查找表的时间。当然，如果一个对象有多个属性，那么缓存失误的概率就会提高，因为某个属性的类型变化之后，对象的隐藏类也会变化，就与之前的缓存不一致，需要重新使用以前的方式查找哈希表。</p><h3 id="2-5-内存管理"><a href="#2-5-内存管理" class="headerlink" title="2.5.内存管理"></a>2.5.内存管理</h3><p>　　Node中通过JavaScript使用内存时就会发现只能使用部分内存（64位系统下约为1.4 GB，32位系统下约为0.7 GB），其深层原因是 V8 垃圾回收机制的限制所致（如果可使用内存太大，V8在进行垃圾回收时需耗费更多的资源和时间，严重影响JS的执行效率）。下面对内存管理进行介绍。</p><p>　　内存的管理组要由分配和回收两个部分构成。V8的内存划分如下：</p><p>Zone：管理小块内存。其先自己申请一块内存，然后管理和分配一些小内存，当一块小内存被分配之后，不能被Zone回收，只能一次性回收Zone分配的所有小内存。当一个过程需要很多内存，Zone将需要分配大量的内存，却又不能及时回收，会导致内存不足情况。</p><p>堆：管理JavaScript使用的数据、生成的代码、哈希表等。为方便实现垃圾回收，堆被分为三个部分：</p><p>年轻分代：为新创建的对象分配内存空间，经常需要进行垃圾回收。为方便年轻分代中的内容回收，可再将年轻分代分为两半，一半用来分配，另一半在回收时负责将之前还需要保留的对象复制过来。</p><p>年老分代：根据需要将年老的对象、指针、代码等数据保存起来，较少地进行垃圾回收。</p><p>大对象：为那些需要使用较多内存对象分配内存，当然同样可能包含数据和代码等分配的内存，一个页面只分配一个对象。</p><p><img src="/image/article/concept/v8-engine/1-20171101142146279-319700043.png"></p><h3 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h3><p>　　V8 使用了分代和大数据的内存分配，在回收内存时使用精简整理的算法标记未引用的对象，然后消除没有标记的对象，最后整理和压缩那些还未保存的对象，即可完成垃圾回收。</p><p>　　在V8中，使用较多的是年轻分代和年老分代。年轻分代中的对象垃圾回收主要通过Scavenge算法进行垃圾回收。在Scavenge的具体实现中，主要采用了Cheney算法：通过复制的方式实现的垃圾回收算法。它将堆内存分为两个 semispace，一个处于使用中（From空间），另一个处于闲置状态（To空间）。当分配对象时，先是在From空间中进行分配。当开始进行垃圾回收时，会检查From空间中的存活对象，这些存活对象将被复制到To空间中，而非存活对象占用的空间将会被释放。完成复制后，From空间和To空间的角色发生对换。在垃圾回收的过程中，就是通过将存活对象在两个 semispace 空间之间进行复制。年轻分代中的对象有机会晋升为年老分代，条件主要有两个：一个是对象是否经历过Scavenge回收，一个是To空间的内存占用比超过限制。</p><p>　　对于年老分代中的对象，由于存活对象占较大比重，再采用上面的方式会有两个问题：一个是存活对象较多，复制存活对象的效率将会很低；另一个问题依然是浪费一半空间的问题。为此，V8在年老分代中主要采用了Mark-Sweep（标记清除）标记清除和Mark-Compact（标记整理）相结合的方式进行垃圾回收。</p><h3 id="2-6-快照"><a href="#2-6-快照" class="headerlink" title="2.6.快照"></a>2.6.快照</h3><p>　　在V8引擎启动时，需要构建JavaScript运行环境，需要加载很多内置对象，同时也需要建立内置的函数，如Array，String，Math等。为了使V8更加整洁，加载对象和建立函数等任务都是使用JavaScript文件来实现的，V8引擎负责提供机制来支持，就是在编译和执行JavaScript前先加载这些文件。</p><p>　　V8引擎需要编译和执行这些内置的JavaScript代码，同时使用堆等来保存执行过程中创建的对象、代码等，这些都需要时间。为此，V8引入了快照机制。将这些内置的对象和函数加载之后的内存保存并序列化。序列化之后的结果很容易反序列化，经过快照机制的启动时间可以缩减几毫秒。快照机制也可以将一些开发者认为需要的JavaScript文件序列化，以减少处理时间。不过快照机制的加载的代码不能被CrankShaft这样的编译器优化，可能会存在性能问题。</p><h3 id="3-V8-VS-JavaScriptCore"><a href="#3-V8-VS-JavaScriptCore" class="headerlink" title="3.V8 VS JavaScriptCore"></a>3.V8 VS JavaScriptCore</h3><p>　　JavaScriptCore引擎是WebKit中默认的JavaScript引擎，也是苹果开源的一个项目，应用较为广泛。最初，性能不是很好，从2008年开始了一系列的优化，重新实现了编译器和字节码解释器，使得引擎的性能有较大的提升。随后内嵌缓存、基于正则表达式的JIT、简单的JIT及字节码解释器等技术引入进来，JavaScriptCore引擎也在不断的迭代和发展。</p><p>　　V8引擎自诞生之日起就以性能优化作为目标，引入了众多新技术，极大了带动了整个业界JavaScript引擎性能的快速发展。总的来说，V8引擎较为激进，青睐可以提高性能的新技术，而JavaScriptCore引擎较为稳健，渐进式的改变着自己的性能。总的来说JavaScript引擎工作流程（包含v8和JavaScriptCore）如下所示：</p><p><img src="/image/article/concept/v8-engine/1-20171101142146295-1586794938.png"></p><p>　　JavaScriptCore 的大致流程为：源代码-→抽象语法树-→字节码-→JIT-→本地代码。JavaScriptCore与V8有一些不同之处，其中最大的不同就是新增了字节码的中间表示，并加入了多层JIT编译器（如：简单JIT编译器、DFG JIT编译器、LLVM等）优化性能，不停的对本地代码进行优化。(在 V8 的 5.9 版本中，新增了一个 Ignition 字节码解释器，TurboFan 和 Ignition 结合起来共同完成JavaScript的编译，此后 V8 将与 JavaScriptCore 有大致相同的流程，Node 8.0中 V8 版本为 5.8)</p><p>　　还有就是在数据表示方面，V8在不同的机器上使用与机器位数相匹配的数据表示，而在JavaScriptCore中句柄都是使用64位表示，其可以表示更大范围的数字，所以即使在32位机器上，浮点类型同样可以保存在句柄中，不再需要访问堆中的数据，当也会占用更多的空间。</p><h3 id="4-功能扩展"><a href="#4-功能扩展" class="headerlink" title="4.功能扩展"></a>4.功能扩展</h3><p>　　JavaScript引擎的主要功能是解析和执行JavaScript代码，往往不能满足使用者多样化的需要，那么就可以增加扩展以提升它的能力。V8引擎有两种扩展机制：绑定和扩展。</p><h3 id="4-1-绑定机制"><a href="#4-1-绑定机制" class="headerlink" title="4.1.绑定机制"></a>4.1.绑定机制</h3><p>　　使用IDL文件或接口文件生成绑定文件，将这些文件同V8引擎一起编译。WebKit中使用IDL来定义JavaScript，但又与IDL有所不同，有一些改变。定义一个新的接口的步骤大致如下：</p><p>1.定义新的接口文件，可以在JavaScript代码进行调用，如mymodule.MyObj.myAttr；</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">module mymodule &#123;<br>    interface [<br>        InterfaceName = MyObject<br>    ] <br>    MyObj &#123;<br>        <span class="hljs-built_in">readonly</span> attribute long myAttr;<br>        DOMString myMethod (DOMString myArg);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>2.按照引擎定义的标准接口为基础实现接口类，生成JavaScript引擎所需的绑定文件。WebKit提供了工具帮助生成所需的绑定类，根据引擎不同和引擎开发语言的不同而有所差异。V8引擎会为上述示例代码生成 v8MyObj.h (MyObj类具体的实现代码)和 V8MyObj.cpp (桥接代码，辅组注册桥接的函数到V8引擎)两个绑定文件。</p><p>　　JavaScript引擎绑定机制需要将扩展代码和JavaScript引擎一块编译和打包，不能根据需要在引擎启动后再动态注入这些本地代码。在实际WEB开发中，开发者都是基于现有浏览器的，根本不可能介入到JavaScript引擎的编译中，绑定机制有很大的局限性，但其非常高效，适用于对性能要求较高的场景。</p><h3 id="4-2-Extension机制"><a href="#4-2-Extension机制" class="headerlink" title="4.2. Extension机制"></a>4.2. Extension机制</h3><p>　　通过V8的基类Extension进行能力扩展，无需和V8引擎一起编译，可以动态为引擎增加功能特性，具有很大的灵活性。</p><p>　　Extension机制的大致思路就是，V8提供一个基类Extension和一个全局注册函数，要想扩展JavaScript能力，需要经过以下步骤：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash">class MYExtension : public v8::Extension &#123;<br>    public:<br>    MYExtension() : v8::Extension(<span class="hljs-string">&quot;v8/My&quot;</span>, <span class="hljs-string">&quot;native function my();&quot;</span>) &#123;&#125;<br>    virtual v8::Handle&lt;v8::FunctionTemplate&gt; GetNativeFunction (<br>        v8::Handle&lt;v8::String&gt; name) &#123;<br>            // 可以根据name来返回不同的函数<br>            <span class="hljs-built_in">return</span> v8::FunctionTemplate::New(MYExtention::MY);<br>        &#125;<br>        static v8::Handle&lt;v8::Value&gt; MY(const v8::Arguments&amp; args) &#123;<br>            // Do sth here<br>            <span class="hljs-built_in">return</span> v8::Undefined();<br>        &#125;<br>)&#125;;<br>MYExtension extension;<br>RegisterExtension(&amp;extension);<br></code></pre></td></tr></table></figure><p>1.基于Extension基类构建一个它的子类，并实现它的虚函数—GetNativeFunction，根据参数name来决定返回实函数；</p><p>2.创建一个该子类的对象，并通过注册函数将该对象注册到V8引擎，当JavaScript调用’my’函数时就可被调用到。</p><p>　　Extension机制是调用V8的接口注入新函数，动态扩展非常方便，但没有绑定机制高效，适用于对性能要求不高的场景。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>　　在过去几年，JavaScript在很多领域得到了广泛的应用，然而限于JavaScript语言本身的不足，执行效率不高。Google也推出了一些JavaScript网络应用，如Gmail、Google Maps及Google Docs office等。这些应用的性能不仅受到服务器、网络、渲染引擎以及其他诸多因素的影响，同时也受到JavaScript本身执行速度的影响。然而既有的JavaScript引擎无法满足新的需求，而性能不佳一直是网络应用开发者最关心的。Google就开始了V8引擎的研究，将一系列新技术引入JavaScript引擎中，大大提高了JavaScript的执行效率。相信随着V8引擎的不断发展，JavaScript也会有更广泛的应用场景，前端工程师也会有更好的未来！</p><p>那么结合上面对于V8引擎的介绍，我们在编程中应注意：</p><p>类型。对于函数，JavaScript是一种动态类型语言，JavaScriptCore和V8都使用隐藏类和内嵌缓存来提高性能，为了保证缓存命中率，一个函数应该使用较少的数据类型；对于数组，应尽量存放相同类型的数据，这样就可以通过偏移位置来访问。</p><p>数据表示。简单类型数据（如整型）直接保存在句柄中，可以减少寻址时间和内存占用，如果可以使用整数表示的，尽量不要用浮点类型。</p><p>内存。虽然JavaScript语言会自己进行垃圾回收，但我们也应尽量做到及时回收不用的内存，对不再使用的对象设置为null或使用delete方法来删除(使用delete方法删除会触发隐藏类新建，需要更多的额外操作)。</p><p>优化回滚。在执行多次之后，不要出现修改对象类型的语句，尽量不要触发优化回滚，否则会大幅度降低代码的性能。</p><p>新机制。使用JavaScript引擎或者渲染引擎提供的新机制和新接口提高性能。</p><h3 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h3><p><a href="https://blog.csdn.net/swimming_in_it_/article/details/78869549?utm_source=copy">https://blog.csdn.net/swimming_in_it_&#x2F;article&#x2F;details&#x2F;78869549</a></p>]]></content>
    
    
    <categories>
      
      <category>概念知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>javascript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android的Activity的四种加载模式</title>
    <link href="/2017/08/08/android/activity/"/>
    <url>/2017/08/08/android/activity/</url>
    
    <content type="html"><![CDATA[<h1 id="Activity的四种加载模式"><a href="#Activity的四种加载模式" class="headerlink" title="Activity的四种加载模式"></a>Activity的四种加载模式</h1><p><strong>Activity的四种加载模式：</strong></p><p>1、standard </p><p>系统的默认模式，一次跳转即会生成一个新的实例。假设有一个activity命名为Act1，执行语句：</p><p>startActivity(new Intent(Act1.this, Act1.class));</p><p>后Act1将跳转到另外一个Act1，也就是现在的栈里面有 Act1 的两个实例。按返回键后你会发现仍然是在Act1（第一个）里面。</p><p>2、singleTop</p><p>singleTop 跟standard 模式比较类似。唯一的区别就是，当跳转的对象是位于栈顶的activity（应该可以理解为用户眼前所 看到的activity）时，程序将不会生成一个新的activity实例，而是直接跳到现存于栈顶的那个activity实例。拿上面的例子来说，当Act1 为 singleTop 模式时，执行跳转后栈里面依旧只有一个实例，如果现在按返回键程序将直接退出。这个貌似用得比较少。</p><p>3、singleTask</p><p>singleTask模式和后面的singleInstance模式都是只创建一个实例的。在这种模式下，无论跳转的对象是不是位于栈顶的activity，程序都不会生成一个新的实例（当然前提是栈里面已经有这个实例）。这种模式相当有用，在以后的多activity开发中， 经常会因为跳转的关系导致同个页面生成多个实例，这个在用户体验上始终有点不好，而如果你将对应的activity声明为 singleTask 模式，这种问题将不复存在。不过前阵子好像又看过有人说一般不要将除开始页面的其他页面设置为 singleTask 模式，原因暂时不明，哪位知道的可以请教下。</p><p>4、singleInstance:</p><p>设置为 singleInstance 模式的 activity 将独占一个task（感觉task可以理解为进程），独占一个task的activity与其说是activity，倒不如说是一个应用，这个应用与其他activity是独立的，它有自己的上下文activity。拿一个例子来说明：</p><p>现在有以下三个activity: Act1、Act2、Act3，其中Acti2 为 singleInstance 模式。它们之间的跳转关系为： Act1 – Act2 – Act3 ，现在在Act3中按下返回键，由于Act2位于一个独立的task中，它不属于Act3的上下文activity，所以此时将直接返回到Act1。这就是singleInstance模式。</p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>cordova插件的坑</title>
    <link href="/2017/04/01/cordova/cordova-plugin/"/>
    <url>/2017/04/01/cordova/cordova-plugin/</url>
    
    <content type="html"><![CDATA[<h1 id="cordova插件的坑"><a href="#cordova插件的坑" class="headerlink" title="cordova插件的坑"></a>cordova插件的坑</h1><p>1、jpush-phonegap-plugin</p><p>     该插件卸载再次安装的时候，在ios平台</p><p>     有个JPushConfig.plist的配置文件里面的AppKey会是空的，需要手动填写</p><p>2、cordova-plugin-camera</p><p>该插件在ios平台选择相册的图片时，压缩比参数qulity不生效，文件过大，上传失败</p><p>文件地址：</p><p><a href="https://github.com/apache/cordova-plugin-camera/blob/master/src/ios/CDVCamera.m">https://github.com/apache/cordova-plugin-camera/blob/master/src/ios/CDVCamera.m</a></p><p>该CDVCamera.m文件385行的if判断进去了，好吧，不是插件的问题，是我不会用，需要添加可编辑参数：allowEditing:true</p>]]></content>
    
    
    <categories>
      
      <category>Cordova</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Cordova</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Cordova项目打包步骤</title>
    <link href="/2017/03/20/cordova/cordova-build/"/>
    <url>/2017/03/20/cordova/cordova-build/</url>
    
    <content type="html"><![CDATA[<h1 id="Cordova项目打包步骤"><a href="#Cordova项目打包步骤" class="headerlink" title="Cordova项目打包步骤"></a>Cordova项目打包步骤</h1><p>Android:</p><ul><li>打包h5项目</li><li>检查index.html里面的viewport和cordova.js</li><li>复制到cordova项目中www文件夹下</li><li>检查config.xml里面的版本号，codepush环境</li><li>cordova build android</li><li>检查AndroidManifest.xml版本号versionName和build号versionCode</li><li>打包APK，记得检查签名</li></ul><p>IOS:</p><ul><li>打包h5项目</li><li>检查index.html里面的viewport和cordova.js</li><li>复制到cordova项目中www文件夹下</li><li>检查config.xml里面的版本号，codepush环境</li><li>cordova build ios</li><li>检查JPushConfig.plist文件下的AppKey</li><li>检查项目General目录下的版本号和build号</li><li>检查Capabilities目录下的Push Notifications开关状态</li><li>如果是发布appStore的话， 检查   Info.list下的权限备注写了没</li><li>打包，记得检查签名</li></ul><p>tip：</p><p>     查看当前插件版本：cordova plugin ls</p>]]></content>
    
    
    <categories>
      
      <category>Cordova</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Cordova</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CodePush</title>
    <link href="/2017/02/09/concept/code-push/"/>
    <url>/2017/02/09/concept/code-push/</url>
    
    <content type="html"><![CDATA[<h1 id="code-push"><a href="#code-push" class="headerlink" title="code-push"></a>code-push</h1><p>CodePush是一个微软开发的云服务器。通过它，开发者可以直接在用户的设备上部署手机应用更新。CodePush相当于一个中心仓库，开发者可以推送当前的更新（包括JS&#x2F;HTML&#x2F;CSS&#x2F;IMAGE等）到CoduPush，然后应用将会查询是否有更新。</p><p>一、安装CodePush CLI管理 CodePush 账号需要通过 NodeJS-based CLI.</p><p>只需要在控制台输入 npm install -g code-push-cli，就可以安装了。</p><p>安装完毕后，输入 code-push -v查看版本代表成功。</p><p>目前我的版本是 1.1.1-beta</p><hr><p>二、创建CodePush账号在控制台输入 code-push register 后，将会打开一个网页进行注册</p><p>CodePush账号支持 github和 Microsofe，选其中一个就可以了。</p><p>我选择的是 github，授权完毕后，网页将会显示一个token，复制它到控制台的中就成功了。成功登陆后，你的session文件将会写在 &#x2F;Users&#x2F;guanMac&#x2F;.code-push.config。相关命令</p><ul><li>code-push login 登陆</li><li>code-push loout 注销</li><li>code-push access-key ls 列出登陆的token</li><li>code-push access-key rm <accessKye> 删除某个 access-key</li></ul><hr><p>三、在CodePush服务器上注册app为了让codePush服务器知道你的app，我们需要向它注册app： code-push app add <appName>，就可以了。CODE-PUSH APP相关命令</p><ul><li>add 在账号里面添加一个新的app</li><li>remove 或者 rm 在账号里移除一个app</li><li>rename 重命名一个存在app</li><li>list 或则 ls 列出账号下面的所有app</li></ul><p>transfer 把app的所有权转移到另外一个账号</p><p>四、在app中添加SDK</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cordova plugin add cordova-plugin-code-push@latest --save<br></code></pre></td></tr></table></figure><p>     配置config.xml</p><p>     在你的 index.html 中允许安全策略，添加 <a href="https://codepush.azurewebsites.net/">https://codepush.azurewebsites.net</a> 的域名：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">&lt;meta http-equiv=<span class="hljs-string">&quot;Content-Security-Policy&quot;</span> content=<span class="hljs-string">&quot;default-src https://codepush.azurewebsites.net ... /&gt;</span><br><span class="hljs-string">部署APP相关命令</span><br></code></pre></td></tr></table></figure><ul><li>code-push deployment add <appName> 部署</li><li>code-push deployment rename <appName> 重命名</li><li>code-push deployment rm <appName> 删除部署</li><li>code-push deployment ls <appName> 列出应用的部署情况</li><li>code-push deployment ls <appName> -k 查看部署的key</li></ul><p>五、发布</p><p>     release有很多种形式</p><p>     我们用code-push release-cordova <appName> <platform> –deploymentName Production –description 我是备注</p><p><img src="/image/article/concept/code-push/2a41fd03-c725-439b-a217-0c8dc1b508c8.png"></p><p>我测试的时候使用的是ios，没想到android还不一样，下面的博客是这么写的，有时间我需要试一下</p><p><img src="/image/article/concept/code-push/b4d0e928-574d-4e69-8477-17ad466d8f7f.png"></p><p>隔了一星期，试了一下，发现这篇文章是针对react的code-push</p><p>我们使用的是cordova的code-push，还是不一样的，</p><p>尝试的结果是android和ios都是基于cordova的config文件的版本号更新的</p><p>下面是自定义的下载进程：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs bash">&lt;div&gt;<br><br>&#123;&#123;(new Number(current/total*100)).toFixed(2)+<span class="hljs-string">&quot;%&quot;</span>&#125;&#125;<br><br>&lt;/div&gt;<br><br>const downloadProgress = (progress) =&gt; &#123;<br><br>// console.log(`Downloaded <span class="hljs-variable">$&#123;progress.receivedBytes&#125;</span> of <span class="hljs-variable">$&#123;progress.totalBytes&#125;</span>`);<br><br>self.current = progress.receivedBytes;<br><br>self.total = progress.totalBytes;<br><br>&#125;<br><br>codePush.<span class="hljs-built_in">sync</span>( null, &#123;updateDialog: <span class="hljs-literal">true</span>, installMode:InstallMode.IMMEDIATE, mandatoryInstallMode: InstallMode.IMMEDIATE&#125;, downloadProgress );<br></code></pre></td></tr></table></figure><p>参考链接：</p><p><a href="http://bbs.reactnative.cn/topic/725/code-push-%E7%83%AD%E6%9B%B4%E6%96%B0%E4%BD%BF%E7%94%A8%E8%AF%A6%E7%BB%86%E8%AF%B4%E6%98%8E%E5%92%8C%E6%95%99%E7%A8%8B/2">http://bbs.reactnative.cn/topic/725/code-push-%E7%83%AD%E6%9B%B4%E6%96%B0%E4%BD%BF%E7%94%A8%E8%AF%A6%E7%BB%86%E8%AF%B4%E6%98%8E%E5%92%8C%E6%95%99%E7%A8%8B/2</a></p><p><a href="https://github.com/Microsoft/code-push/tree/master/cli#releasing-updates-general">https://github.com/Microsoft/code-push/tree/master/cli#releasing-updates-general</a></p><p><a href="https://microsoft.github.io/code-push/docs/cordova.html#link-5">https://microsoft.github.io/code-push/docs/cordova.html#link-5</a></p>]]></content>
    
    
    <categories>
      
      <category>概念知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Cordova</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ionic和Cordova的关系</title>
    <link href="/2016/11/28/cordova/Ionic-cordova/"/>
    <url>/2016/11/28/cordova/Ionic-cordova/</url>
    
    <content type="html"><![CDATA[<h1 id="Ionic和cordova的关系是什么"><a href="#Ionic和cordova的关系是什么" class="headerlink" title="Ionic和cordova的关系是什么"></a>Ionic和cordova的关系是什么</h1><p>ionic是什么：</p><p>Ionic(ionicframework)一款开源的Html5移动App开发框架,是AngularJS移动端解决方案,Ionic以流行的跨平台移动app开发框架phoengap为蓝本，让开发者可以通过命令行工具快速生成android ios移动app应用。</p><p>其实他就是基于AngularJS做了个H5，然后集成了Cordova把H5打包成APP。</p><p>cordova是什么？</p><p>cordova是一个用基于HTML，CSS和JavaScript的，创建移动跨平台移动应用程序的快速开发平台。它使开发者能够利用iPhone，Android，Palm，Symbian,WP7,WP8,Bada和Blackberry智能手机的核心功能——包括地理定位，加速器，联系人，声音和振动.</p><p>问题来了？</p><p>那我不用命令安装ionic 可以使用ionic开发app吗？答案是可以得。</p><p>就可以把ionic当作一款html5 移动app框架，把phonegap&#x2F;cordova 当作打包 并且调用原生的框架就可以了</p><p>至于：为什么ionic也可以打包，上面也说了，ionic的打包插件是基于phonegap&#x2F;cordova的</p><p>首先我们需要明确以下几个概念：</p><p>1.即使我们将移动端web页面做得和原生应用及其相似，在我们的页面中也无法像原生应用那样调用原生的能力，当然通过输入框触发键盘、图库、拍照等操作不在这里“调用原生能力”的范畴。</p><p>2.单纯的web页面不能提交到应用商店被用户使用。</p><p>然后，我们分别就它们之间的关系做出解释：</p><h2 id="Ionic和Angular"><a href="#Ionic和Angular" class="headerlink" title="Ionic和Angular"></a>Ionic和Angular</h2><p>首先要明确的是Ionic是Angular的衍生品，Angular是单独的js库，和jQuery一样能够独立用于开发应用，而Ionic只是对Angular进行了扩展，利用Angular实现了很多符合移动端应用的组件，并搭建了很完善的样式库，是对Angular最成功的应用样例。即使不使用Ionic，Angular也可与任意样式库，如Bootstrap、Foundation等搭配使用，得到想要的页面效果。</p><h2 id="Ionic-x2F-Angular和Cordova"><a href="#Ionic-x2F-Angular和Cordova" class="headerlink" title="Ionic&#x2F;Angular和Cordova"></a>Ionic&#x2F;Angular和Cordova</h2><p>可能会有人被问道：“Cordova比Ionic&#x2F;Angular好吗？”，这就很尴尬了，根本是毫无意义的问题。它们在混合开发中扮演的是不同的角色–Ionic&#x2F;Angular负责页面的实现，而Cordova负责将实现的页面包装成原生应用（Android:apk；iOS:ipa）。就像花生，最内层的花生仁是Angular，花生仁的表皮是Ionic，而最外层的花生壳则是Cordova。包装完成之后我们的页面才有可能调用设备的原生能力，最后才能上传到应用商店被用户使用。</p><h2 id="Ionic-x2F-Angular和Cordova插件"><a href="#Ionic-x2F-Angular和Cordova插件" class="headerlink" title="Ionic&#x2F;Angular和Cordova插件"></a>Ionic&#x2F;Angular和Cordova插件</h2><p>关于Cordova插件要明确以下几点：</p><ul><li>Cordova插件的作用是提供一个桥梁供页面和原生通信，首先我们的页面不能直接调用设备能力，所以需要与能够调用设备能力的原生代码（android:Java；ios:OC）通信，此时就需要Cordova插件了。</li><li>Cordova插件能够再任何Cordova工程中使用，和使用什么前端框架（如Ionic）无关。</li><li>Ionic 2中封装了Ionic Native，方便了Cordova插件的使用，但在Ionic 2中仍然可以像Ionic 1中一样使用Cordova插件，Ionic Native不是必须的。</li><li>即使在Ionic 2中使用了Ionic Native，也首先需要手动添加插件，如：cordova plugin add cordova-plugin-pluginName。</li></ul><p>Ionic整合的太多了，又是AngularJS,又是Cordova的，实际的选择是Cordova+Vue&#x2F;React</p><p>参考链接：<br><a href="https://blog.csdn.net/xiaolinlife/article/details/73548938?utm_source=copy">https://blog.csdn.net/xiaolinlife/article/details/73548938?utm_source&#x3D;copy</a></p>]]></content>
    
    
    <categories>
      
      <category>Cordova</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Cordova</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Cordova小知识</title>
    <link href="/2016/11/24/cordova/cordova-tips/"/>
    <url>/2016/11/24/cordova/cordova-tips/</url>
    
    <content type="html"><![CDATA[<h1 id="Cordova小知识"><a href="#Cordova小知识" class="headerlink" title="Cordova小知识"></a>Cordova小知识</h1><h3 id="一、概念知识"><a href="#一、概念知识" class="headerlink" title="一、概念知识"></a>一、概念知识</h3><ul><li>Cordova：Cordova 能够将你的 HTML&#x2F;JS 代码打包在一个原生的容器中运行，并且可以调用系统的各类软硬件接口（JavaScript API）。我们将这种架构称之为 hybrid app , 得益于这种架构，我们能将前端代码跨平台运行，并且得到接近原生应用的系统特性。最终发布到各大应用市场，包括苹果的 App Store。</li><li>Cordova插件：Cordova 通过插件的生态系统为开发者提供了广泛的软硬件接口支持，诸如文件读写、推送通知、解压缩、通讯录等等。这种方式保证了在开发过程中按需引入相应的功能插件，同时也加快了插件的更新维护，减少代码冗余。Cordova 插件使用 CLI 的方式经过 NPM 管理依赖并安装，十分方便。</li><li>Cross-walk：Cross-walk 是英特尔开发的一款为HTML应用提供运行时环境的开源项目，它基于最新的 Chromium 核心开发，可以提供最新的 Web 特性和一致的兼容性。随着 Cordova Android 4.0.0+ 引入了对嵌入式 webview 的支持，现在你可以方便地在你的 Cordova 应用上使用 Crosswalk 的 webview。通过使用 Crosswalk 的 webview 插件，开发者可以享用远程调试的功能，前沿的 HTML5 特性，例如WebGL, WebAudio 和 WebRTC，以及在包括 Android 4.0 Ice Cream Sandwich(ICS) 在内的 Android 设备上性能的显著提升。</li><li>CodePush：CodePush 是微软提供的一项云服务，它为开发者提供了直接向用户推送热更新 (Hot-Code-Update) 的软件支持和 CDN 分发网络。CodePush 为 Cordova 开发者提供了插件，我们可以快速地植入应用中。它提供的特性包括：版本管理、灰度更新、紧急回滚、增量更新 (Diff) 等等。它的 CDN 是世界上最大的 CDN 服务商 Akamai 提供的，稳定性和速度可想而知。未来可能收费</li></ul><h3 id="二、创建并运行项目"><a href="#二、创建并运行项目" class="headerlink" title="二、创建并运行项目"></a>二、创建并运行项目</h3><p>官方文档地址：<a href="https://cordova.apache.org/">https://cordova.apache.org/</a></p><p>安装命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">cordova create hello com.example.hello HelloWorld<br><span class="hljs-comment"># hello是文件夹</span><br><span class="hljs-comment"># com.example.hello 是包名</span><br><span class="hljs-comment"># helloworld是app名字</span><br></code></pre></td></tr></table></figure><p>1、运行ios模拟器时，需要指定版本</p><p>查看当前的模拟器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ./platforms/ios/cordova/lib/list-emulator-images<br>iPhone-4s<br>iPhone-5<br>iPhone-5s<br>iPhone-6-PlusiPhone-6<br>iPad-2<br><br>iPad-Retina<br><br>iPad-Air<br>Resizable-iPhone<br>Resizable-iPad<br></code></pre></td></tr></table></figure><p>使用命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">cordova run ios --target  iPhone-5<br><span class="hljs-comment">#iPhone 总是会不小心写错成 iphone</span><br></code></pre></td></tr></table></figure><p>2、使用ios真机调试必须先安装ios-deploy但是sudo npm install -g ios-deploy是报错的，issue参靠链接：</p><p><a href="https://github.com/phonegap/ios-deploy/issues/188">https://github.com/phonegap/ios-deploy/issues/188</a></p><p>你要是懒得看英文，那就这个吧：</p><p><a href="http://blog.csdn.net/cooldragon/article/details/50925633">http://blog.csdn.net/cooldragon/article/details/50925633</a></p><p>最终安装命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo npm install -g ios-deploy --unsafe-perm=<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>如果你安装过ios-deploy,使用模拟器就必加–emulator命令，示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cordova run ios --emulator --target  iPhone-5<br></code></pre></td></tr></table></figure><h3 id="三、使用-Cordova-插件引入-Cross-walk-webview"><a href="#三、使用-Cordova-插件引入-Cross-walk-webview" class="headerlink" title="三、使用 Cordova 插件引入 Cross-walk webview"></a>三、使用 Cordova 插件引入 Cross-walk webview</h3><p>在实际开发中，会遇到 Android 系统版本落后，原生 webview 性能差兼容性差的问题，所以我们要用 Cross-walk 替换原生的 Android webview 来运行我们的项目。 Cross-walk 开发社区已经为我们准备好了 Cordova 插件，只需要运行：  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cordova plugin add cordova-plugin-crosswalk-webview@latest —save  <br></code></pre></td></tr></table></figure><p>成功安装后再次 cordova build android ，你会发现输出了两个 apk 文件，一个对应 arm 平台，一个对应 x86 平台，体积相较原来的文件增加了 20M 左右，多出来的体积便是 crosswalk-webview 的 runtime。 </p><p>你也可以在项目的 config.xml 中设置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">&lt;plugin name=<span class="hljs-string">&quot;cordova-plugin-crosswalk-webview&quot;</span> spec=<span class="hljs-string">&quot;~2.2.0&quot;</span>&gt;<br>    &lt;variable name=<span class="hljs-string">&quot;XWALK_VERSION&quot;</span> value=<span class="hljs-string">&quot;22+&quot;</span> /&gt;<br>    &lt;variable name=<span class="hljs-string">&quot;XWALK_LITEVERSION&quot;</span> value=<span class="hljs-string">&quot;xwalk_core_library_canary:17+&quot;</span> /&gt;<br>    &lt;variable name=<span class="hljs-string">&quot;XWALK_COMMANDLINE&quot;</span> value=<span class="hljs-string">&quot;--disable-pull-to-refresh-effect&quot;</span> /&gt;<br>    &lt;variable name=<span class="hljs-string">&quot;XWALK_MODE&quot;</span> value=<span class="hljs-string">&quot;embedded&quot;</span> /&gt;<br>    &lt;variable name=<span class="hljs-string">&quot;XWALK_MULTIPLEAPK&quot;</span> value=<span class="hljs-string">&quot;true&quot;</span> /&gt;<br>&lt;/plugin&gt;<br></code></pre></td></tr></table></figure><p>把 XWALK_MULTIPLEAPK 的 value 设置为 false，即可打包出一个整合两个平台的 apk 包，当然，体积会暴增至 40M+。</p><h3 id="四、使用-Chrome-调试-Cross-walk-webview-中的项目"><a href="#四、使用-Chrome-调试-Cross-walk-webview-中的项目" class="headerlink" title="四、使用 Chrome 调试 Cross-walk webview 中的项目"></a>四、使用 Chrome 调试 Cross-walk webview 中的项目</h3><p>由于 Cross-walk 基于 Chromium，天生便具有了 Chrome 远程调试的功能。 电脑连接 Android 手机并开启 USB 调试模式，打开你的 Cordova 项目后，在 Chrome 浏览器地址栏中输入 chrome:&#x2F;&#x2F;inspect ，选择你的设备，即可打开远程控制台，真机调试变得十分方便。Vue Devtool 同样可以在此使用。</p><h3 id="五、iOS-的小优化-将-UIWebView-替换为-WKWebView"><a href="#五、iOS-的小优化-将-UIWebView-替换为-WKWebView" class="headerlink" title="五、iOS 的小优化 将 UIWebView 替换为 WKWebView"></a>五、iOS 的小优化 将 UIWebView 替换为 WKWebView</h3><p>WKWebView 是苹果在 iOS 8 中引入的新组件，目的是给出一个新的高性能的 Web View 解决方案，摆脱过去 UIWebView 的老旧笨重特别是内存占用量巨大的问题（打开一个示例项目，WKWebView 占用23M，而 UIWebView 占用85M）。 </p><p>在这里我们将使用 WKWebView 替换 Cordova 默认的 UIWebView： </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cordova plugin add cordova-plugin-wkwebview-engine@latest --save<br></code></pre></td></tr></table></figure><p> 并在 config.xml 的 <platform name="ios"> 中添加：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">&lt;feature name=<span class="hljs-string">&quot;CDVWKWebViewEngine&quot;</span>&gt;<br>    &lt;param name=<span class="hljs-string">&quot;ios-package&quot;</span> value=<span class="hljs-string">&quot;CDVWKWebViewEngine&quot;</span> /&gt;<br>&lt;/feature&gt;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Cordova</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Cordova</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常用的git命令</title>
    <link href="/2016/04/06/other/git-bash/"/>
    <url>/2016/04/06/other/git-bash/</url>
    
    <content type="html"><![CDATA[<h1 id="常用的git命令"><a href="#常用的git命令" class="headerlink" title="常用的git命令"></a>常用的git命令</h1><p>1、创建分支</p><p>     git branch temp</p><p>     或者git checkout -b temp</p><p>2、推送本地分支到远程</p><p>     git push origin temp</p><p>3、删除本地分支</p><p>     git branch -d temp</p><p>     有时候你可能需要一个大写的D</p><p>4、删除远程分支</p><p>     git v1.7.0之后可以用 </p><p>               git push origin –delete temp</p><p>    通用做法是(推动一个空分支覆盖远程分支)</p><p>            git push origin :temp</p><p>5、撤销错误的提交</p><p>     1、本地代码还原至老版本</p><p>          git reset –hard <commit-hash></p><p>     2、强制提交覆盖</p><p>          git push -f origin temp</p><p>6、创建标签</p><p>      创建普通标签</p><p>          git tag v2.3.1</p><p>     创建带注释的标签</p><p>           git tag -a v2.3.1 -m “2.3.1源码”</p><p>           git tag 是打标签的命令，-a 是添加标签，其后要跟新标签号，-m 及后面的字符串是对该标签的注释。</p><p>7、操作标签</p><p>      显示本地所有标签</p><p>          git tag</p><p>      提交标签</p><p>           git push origin v2.3.1</p><p>      一次性提交所有标签</p><p>          git push origin  –tags</p><p>      删除本地标签</p><p>          git tag -d v2.3.1</p><p>      删除远程标签</p><p>          git push origin :refs&#x2F;tags&#x2F;v2.3.1 </p><p>          或者git v1.7.0 以后和删除分支一样</p><p>          git push origin –delete v2.3.1</p><p>    拉取远程tag</p><p>        git fetch origin tag <tagname></p><p>8、直接创建并拉取远程分支，然后切换到这个分支 </p><p>   git checkout -t origin&#x2F;temp</p><p>9、远程分支已经删除了，可是本地缓存还是显示这个分支</p><p>     查看remote地址，远程分支，还有本地分支与之相对应关系 </p><p>          git remote show origin</p><p>    删除远程仓库已经不存在的分支</p><p>          git remote prune origin</p><p>10.gitignore忽略的文件还是会被提交是git缓存的问题</p><p>        git rm -r –cached .</p><p>        git add .</p><p>        git commit -m ‘update .gitignore’</p><p>11、更新remote</p><p>修改命令  git remote origin set-url URL</p><p>           先删后加</p><p>                git remote rm origin</p><p>                git remote add origin <a href="mailto:git@github.com">git@github.com</a>:Liutos&#x2F;foobar.git</p><p>           git gui</p><p>12、有一次报错，本地分支和远程分支未关联，代码拉不下来</p><p>git pull origin master –allow-unrelated-histories</p><p><img src="/image/article/other/git-bash/61ed5d55-83ea-472e-87ec-ebab70281cea.png"></p><p>13、切换git用户</p><p>先更换用户</p><p>$ git config –global user.name “your_email_prefix”</p><p>$ git config –global user.email  “your_email”</p><p>重新生成sshkey</p><p>$ ssh-keygen -t rsa -C “your_email”</p><p>把key添加到git个人信息(mac地址： ~&#x2F;.ssh&#x2F;id_rsa.pub )</p><p>把key添加到ssh agent</p><p>$ ssh-agent bash</p><p>$ ssh-add ~&#x2F;.ssh&#x2F;id_rsa</p>]]></content>
    
    
    <categories>
      
      <category>随手记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Activity的生命周期</title>
    <link href="/2015/08/14/android/activitylife/"/>
    <url>/2015/08/14/android/activitylife/</url>
    
    <content type="html"><![CDATA[<p>首先看一下Android api中所提供的Activity生命周期图(不明白的，可以看完整篇文章，在回头看一下这个图，你会明白的):<br><img src="/image/article/android/activitylife/activitylife.png" alt="Activity生命周期图"><br>Activity其实是继承了ApplicationContext这个类，我们可以重写以下方法，如下代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Activity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ApplicationContext</span> &#123;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span>;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onStart</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onRestart</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onResume</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onPause</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onStop</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onDestroy</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>为了便于大家更好的理解，我简单的写了一个Demo,不明白Activity周期的朋友们，可以亲手实践一下，大家按照我的步骤来。</p><h4 id="第一步-新建一个Android工程，我这里命名为ActivityDemo"><a href="#第一步-新建一个Android工程，我这里命名为ActivityDemo" class="headerlink" title="第一步:新建一个Android工程，我这里命名为ActivityDemo."></a>第一步:新建一个Android工程，我这里命名为ActivityDemo.</h4><h4 id="第二步-修改ActivityDemo-java-我这里重新写了以上的七种方法，主要用Log打印-代码如下"><a href="#第二步-修改ActivityDemo-java-我这里重新写了以上的七种方法，主要用Log打印-代码如下" class="headerlink" title="第二步:修改ActivityDemo.java(我这里重新写了以上的七种方法，主要用Log打印),代码如下:"></a>第二步:修改ActivityDemo.java(我这里重新写了以上的七种方法，主要用Log打印),代码如下:</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.tutor.activitydemo;<br><span class="hljs-keyword">import</span> android.app.Activity;<br><span class="hljs-keyword">import</span> android.os.Bundle;<br><span class="hljs-keyword">import</span> android.util.Log;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ActivityDemo</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Activity</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">TAG</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;ActivityDemo&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span> &#123;<br>        <span class="hljs-built_in">super</span>.onCreate(savedInstanceState);<br>        setContentView(R.layout.main);<br>        Log.e(TAG, <span class="hljs-string">&quot;start onCreate~~~&quot;</span>);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onStart</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">super</span>.onStart();<br>        Log.e(TAG, <span class="hljs-string">&quot;start onStart~~~&quot;</span>);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onRestart</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">super</span>.onRestart();<br>        Log.e(TAG, <span class="hljs-string">&quot;start onRestart~~~&quot;</span>);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onResume</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">super</span>.onResume();<br>        Log.e(TAG, <span class="hljs-string">&quot;start onResume~~~&quot;</span>);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onPause</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">super</span>.onPause();<br>        Log.e(TAG, <span class="hljs-string">&quot;start onPause~~~&quot;</span>);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onStop</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">super</span>.onStop();<br>        Log.e(TAG, <span class="hljs-string">&quot;start onStop~~~&quot;</span>);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onDestroy</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">super</span>.onDestroy();<br>        Log.e(TAG, <span class="hljs-string">&quot;start onDestroy~~~&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="第三步-运行上述工程-效果图如下-没什么特别的"><a href="#第三步-运行上述工程-效果图如下-没什么特别的" class="headerlink" title="第三步:运行上述工程,效果图如下(没什么特别的):"></a>第三步:运行上述工程,效果图如下(没什么特别的):</h4><p><img src="/image/article/android/activitylife/life3-1.jpg"><br>核心在Logcat视窗里,我们打开应用时先后执行了onCreate()-&gt;onStart()-&gt;onResume三个方法，看一下LogCat视窗如下:<br><img src="/image/article/android/activitylife/life3-2.jpg"><br>BACK键：<br>　　当我们按BACK键时，我们这个应用程序将结束，这时候我们将先后调用onPause()-&gt;onStop()-&gt;onDestory()三个方法，如下图所示:<br><img src="/image/article/android/activitylife/life3-3.jpg"><br>HOME键:<br>　　当我们打开应用程序时，比如浏览器，我正在浏览NBA新闻，看到一半时，我突然想听歌，这时候我们会选择按HOME键，然后去打开音乐应用程序，而当我们按HOME的时候，Activity先后执行了onPause()-&gt;onStop()这两个方法，这时候应用程序并没有销毁。如下图所示:<br><img src="/image/article/android/activitylife/life3-4.jpg"><br>　而当我们再次启动ActivityDemo应用程序时，则先后分别执行了onRestart()-&gt;onStart()-&gt;onResume()三个方法，如下图所示:<br><img src="/image/article/android/activitylife/life3-5.jpg"><br>这里我们会引出一个问题，当我们按HOME键，然后再进入ActivityDemo应用时，我们的应用的状态应该是和按HOME键之前的状态是一样的，同样为了方便理解，在这里我将ActivityDemo的代码作一些修改，就是增加一个EditText。</p><h4 id="第四步-修改main-xml布局文件（增加了一个EditText-代码如下"><a href="#第四步-修改main-xml布局文件（增加了一个EditText-代码如下" class="headerlink" title="第四步:修改main.xml布局文件（增加了一个EditText),代码如下:"></a>第四步:修改main.xml布局文件（增加了一个EditText),代码如下:</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;utf-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">LinearLayout</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:orientation</span>=<span class="hljs-string">&quot;vertical&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;fill_parent&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;fill_parent&quot;</span></span><br><span class="hljs-tag">&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">TextView</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;fill_parent&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;@string/hello&quot;</span></span><br><span class="hljs-tag">    /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">EditText</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/editText&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;fill_parent&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">    /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">LinearLayout</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="第五步-然后其他不变，运行ActivityDemo程序-在EditText里输入如”Frankie”字符串-如下图"><a href="#第五步-然后其他不变，运行ActivityDemo程序-在EditText里输入如”Frankie”字符串-如下图" class="headerlink" title="第五步:然后其他不变，运行ActivityDemo程序,在EditText里输入如”Frankie”字符串(如下图:)"></a>第五步:然后其他不变，运行ActivityDemo程序,在EditText里输入如”Frankie”字符串(如下图:)</h4><p><img src="/image/article/android/activitylife/life5-1.jpg"><br>这时候，大家可以按一下HOME键，然后再次启动ActivityDemo应用程序，这时候EditText里并没有我们输入的”Frankie”字样，如下图:<br><img src="/image/article/android/activitylife/life5-2.jpg"><br>这显然不能称得一个合格的应用程序，所以我们需要在Activity几个方法里自己实现，如下第六步所示:</p><h4 id="第六步修改ActivityDemo-java代码如下"><a href="#第六步修改ActivityDemo-java代码如下" class="headerlink" title="第六步修改ActivityDemo.java代码如下:"></a>第六步修改ActivityDemo.java代码如下:</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.tutor.activitydemo;<br><span class="hljs-keyword">import</span> android.app.Activity;<br><span class="hljs-keyword">import</span> android.os.Bundle;<br><span class="hljs-keyword">import</span> android.util.Log;<br><span class="hljs-keyword">import</span> android.widget.EditText;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ActivityDemo</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Activity</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">TAG</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;ActivityDemo&quot;</span>;<br>    <span class="hljs-keyword">private</span> EditText mEditText;<br>    <span class="hljs-comment">//定义一个String 类型用来存取我们EditText输入的值</span><br>    <span class="hljs-keyword">private</span> String mString;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span> &#123;<br>        <span class="hljs-built_in">super</span>.onCreate(savedInstanceState);<br>        setContentView(R.layout.main);<br>        mEditText = (EditText)findViewById(R.id.editText);<br>        Log.e(TAG, <span class="hljs-string">&quot;start onCreate~~~&quot;</span>);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onStart</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">super</span>.onStart();<br>        Log.e(TAG, <span class="hljs-string">&quot;start onStart~~~&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">//当按HOME键时，然后再次启动应用时，我们要恢复先前状态</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onRestart</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">super</span>.onRestart();<br>        mEditText.setText(mString);<br>        Log.e(TAG, <span class="hljs-string">&quot;start onRestart~~~&quot;</span>);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onResume</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">super</span>.onResume();<br>        Log.e(TAG, <span class="hljs-string">&quot;start onResume~~~&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">//当我们按HOME键时，我在onPause方法里，将输入的值赋给mString</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onPause</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">super</span>.onPause();<br>        mString = mEditText.getText().toString();<br>        Log.e(TAG, <span class="hljs-string">&quot;start onPause~~~&quot;</span>);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onStop</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">super</span>.onStop();<br>        Log.e(TAG, <span class="hljs-string">&quot;start onStop~~~&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onDestroy</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">super</span>.onDestroy();<br>        Log.e(TAG, <span class="hljs-string">&quot;start onDestroy~~~&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="第七步-重新运行ActivityDemo程序，重复第五步操作，当我们按HOME键时，再次启动应用程序时，EditText里有上次输入的”Frankie”字样，如下图如示"><a href="#第七步-重新运行ActivityDemo程序，重复第五步操作，当我们按HOME键时，再次启动应用程序时，EditText里有上次输入的”Frankie”字样，如下图如示" class="headerlink" title="第七步:重新运行ActivityDemo程序，重复第五步操作，当我们按HOME键时，再次启动应用程序时，EditText里有上次输入的”Frankie”字样，如下图如示:"></a>第七步:重新运行ActivityDemo程序，重复第五步操作，当我们按HOME键时，再次启动应用程序时，EditText里有上次输入的”Frankie”字样，如下图如示:</h4><p><img src="/image/article/android/activitylife/life7-1.jpg"><br>OK,大功基本告成，这时候大家可以在回上面看一下Activity生命周期图，我想大家应该完全了解了Activity的生命周期了，不知道你了解了没？</p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
